<Type Name="DrawingContext" FullName="System.Windows.Media.DrawingContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a5501bf2f8e9b049041293d0b34f2441556dee4a" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48628023" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class DrawingContext : System.Windows.Threading.DispatcherObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DrawingContext extends System.Windows.Threading.DispatcherObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.DrawingContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DrawingContext&#xA;Inherits DispatcherObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DrawingContext abstract : System::Windows::Threading::DispatcherObject, IDisposable" />
  <TypeSignature Language="F#" Value="type DrawingContext = class&#xA;    inherit DispatcherObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Beschreibt visuellen Inhalt mithilfe der Befehle „draw“, „push“ und „pop“.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden einer <xref:System.Windows.Media.DrawingContext> zum Auffüllen einer <xref:System.Windows.Media.Visual> oder <xref:System.Windows.Media.Drawing> mit visuellem Inhalt.  
  
 Obwohl die <xref:System.Windows.Media.DrawingContext> Draw-Methoden ähneln den Zeichenmethode des der <xref:System.Drawing.Graphics?displayProperty=nameWithType> Typ funktionieren sehr unterschiedlich, je: <xref:System.Windows.Media.DrawingContext> ist zwar mit einem System mit retained Mode-Grafiken verwendet, die <xref:System.Drawing.Graphics?displayProperty=nameWithType> Typ wird verwendet, mit einem unmittelbaren Modus Das Grafiksystem. Bei Verwendung einer <xref:System.Windows.Media.DrawingContext> des Objekts zeichnen-Befehle, speichern Sie einen Satz von Renderinganweisungen (obwohl der tatsächliche Speichermechanismus hängt vom Typ des Objekts, das angibt der <xref:System.Windows.Media.DrawingContext>), die später von Grafiken verwendet werden System; Sie werden nicht in Echtzeit auf dem Bildschirm gezeichnet. Weitere Informationen zur Funktionsweise der Windows Presentation Foundation (WPF)-Grafiksystem finden Sie unter [Grafiken Übersicht über das WPF](~/docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
 Instanziieren Sie nie direkt eine <xref:System.Windows.Media.DrawingContext>; Sie können jedoch einen Zeichnungskontext mit bestimmten Methoden, abrufen, wie z. B. <xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType> und <xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel ruft eine <xref:System.Windows.Media.DrawingContext> aus einem <xref:System.Windows.Media.DrawingVisual> und wird verwendet, um ein Rechteck zu zeichnen.  
  
 [!code-csharp[drawingvisualsample#101](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#101)]
 [!code-vb[drawingvisualsample#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#101)]  
  
 Im nächsten Beispiel wird die <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>, und <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehle. Die <xref:System.Windows.Media.DrawingContext> aus einer eine <xref:System.Windows.Media.DrawingGroup> und nutzt ein <xref:System.Windows.Controls.Image> Steuerelement.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.DrawingGroup" />
    <altmember cref="T:System.Windows.Media.Drawing" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public abstract void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.Close" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit" Usage="drawingContext.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den <see cref="T:System.Windows.Media.DrawingContext" /> und leert den Inhalt. Anschließend kann der <see cref="T:System.Windows.Media.DrawingContext" /> nicht geändert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Media.DrawingContext> muss geschlossen werden, bevor der Inhalt gerendert werden kann, aber nachdem es geschlossen wurde, nicht geändert werden kann. Dieser Aufruf erfordert keine alle Aufrufe von Push wurden per POP entfernt haben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde bereits geschlossen oder freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisposeCore">
      <MemberSignature Language="C#" Value="protected abstract void DisposeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisposeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DisposeCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DisposeCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DisposeCore();" />
      <MemberSignature Language="F#" Value="abstract member DisposeCore : unit -&gt; unit" Usage="drawingContext.DisposeCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom <see cref="T:System.Windows.Media.DrawingContext" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nicht direkt aus Ihrem Code. Verwenden Sie die <xref:System.Windows.Media.DrawingContext.System%23IDisposable%23Dispose%2A> Methode stattdessen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde bereits geschlossen oder verworfen.</exception>
        <altmember cref="M:System.Windows.Media.DrawingContext.System#IDisposable#Dispose" />
      </Docs>
    </Member>
    <Member MemberName="DrawDrawing">
      <MemberSignature Language="C#" Value="public abstract void DrawDrawing (System.Windows.Media.Drawing drawing);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawDrawing(class System.Windows.Media.Drawing drawing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawDrawing(System.Windows.Media.Drawing)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawDrawing(System::Windows::Media::Drawing ^ drawing);" />
      <MemberSignature Language="F#" Value="abstract member DrawDrawing : System.Windows.Media.Drawing -&gt; unit" Usage="drawingContext.DrawDrawing drawing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawing" Type="System.Windows.Media.Drawing" />
      </Parameters>
      <Docs>
        <param name="drawing">Die anzufügende Zeichnung.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Windows.Media.Drawing" />-Objekt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawEllipse">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Ellipse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public abstract void DrawEllipse (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Point center, double radiusX, double radiusY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawEllipse(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Point center, float64 radiusX, float64 radiusY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawEllipse(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Point,System.Double,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawEllipse(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Point center, double radiusX, double radiusY);" />
      <MemberSignature Language="F#" Value="abstract member DrawEllipse : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Point * double * double -&gt; unit" Usage="drawingContext.DrawEllipse (brush, pen, center, radiusX, radiusY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="center" Type="System.Windows.Point" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="brush">Der Pinsel, mit dem die Ellipse ausgefüllt werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Pinsel <see langword="null" /> ist, wird keine Füllung gezeichnet.</param>
        <param name="pen">Der Stift, mit dem der Strich der Ellipse gezeichnet werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Stift <see langword="null" /> ist, wird kein Strich gezeichnet.</param>
        <param name="center">Die Position des Mittelpunkts der Ellipse.</param>
        <param name="radiusX">Der horizontale Radius der Ellipse.</param>
        <param name="radiusY">Der vertikale Radius der Ellipse.</param>
        <summary>Zeichnet eine Ellipse mit dem angegebenen <see cref="T:System.Windows.Media.Brush" /> und <see cref="T:System.Windows.Media.Pen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pinsel und dem Stift werden beide `null`.  Wenn der Pinsel `null`, und klicken Sie dann keine Füllung ausgeführt wird.  Wenn der Stift `null`, wird kein Strich gezeichnet wird.  Wenn der Stift und der Pinsel sind `null`, und klicken Sie dann die Zeichnung nicht sichtbar ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public abstract void DrawEllipse (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Point center, System.Windows.Media.Animation.AnimationClock centerAnimations, double radiusX, System.Windows.Media.Animation.AnimationClock radiusXAnimations, double radiusY, System.Windows.Media.Animation.AnimationClock radiusYAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawEllipse(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Point center, class System.Windows.Media.Animation.AnimationClock centerAnimations, float64 radiusX, class System.Windows.Media.Animation.AnimationClock radiusXAnimations, float64 radiusY, class System.Windows.Media.Animation.AnimationClock radiusYAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawEllipse(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Point,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawEllipse(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Point center, System::Windows::Media::Animation::AnimationClock ^ centerAnimations, double radiusX, System::Windows::Media::Animation::AnimationClock ^ radiusXAnimations, double radiusY, System::Windows::Media::Animation::AnimationClock ^ radiusYAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawEllipse : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Point * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawEllipse (brush, pen, center, centerAnimations, radiusX, radiusXAnimations, radiusY, radiusYAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="center" Type="System.Windows.Point" />
        <Parameter Name="centerAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusXAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusY" Type="System.Double" />
        <Parameter Name="radiusYAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Der Pinsel, mit dem die Ellipse ausgefüllt werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Pinsel <see langword="null" /> ist, wird keine Füllung gezeichnet.</param>
        <param name="pen">Der Stift, mit dem der Strich der Ellipse gezeichnet werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Stift <see langword="null" /> ist, wird kein Strich gezeichnet.</param>
        <param name="center">Die Position des Mittelpunkts der Ellipse.</param>
        <param name="centerAnimations">Die Uhr, mit dem der Mittelpunkt der Ellipse animiert werden soll, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Point" />-Objekte animiert werden können.</param>
        <param name="radiusX">Der horizontale Radius der Ellipse.</param>
        <param name="radiusXAnimations">Die Uhr zum Animieren des x-Radius der Ellipse oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Double" />-Objekte animiert werden können.</param>
        <param name="radiusY">Der vertikale Radius der Ellipse.</param>
        <param name="radiusYAnimations">Die Uhr zum Animieren des y-Radius der Ellipse oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Double" />-Objekte animiert werden können.</param>
        <summary>Zeichnet eine Ellipse mit dem angegebenen <see cref="T:System.Windows.Media.Brush" /> und <see cref="T:System.Windows.Media.Pen" /> und wendet die angegebenen Animationsuhren an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pinsel und dem Stift werden beide `null`.  Wenn der Pinsel `null`, und klicken Sie dann keine Füllung ausgeführt wird.  Wenn der Stift `null`, wird kein Strich gezeichnet wird.  Wenn der Stift und der Pinsel sind `null`, und klicken Sie dann die Zeichnung nicht sichtbar ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawGeometry">
      <MemberSignature Language="C#" Value="public abstract void DrawGeometry (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Media.Geometry geometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawGeometry(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, class System.Windows.Media.Geometry geometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawGeometry(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Media.Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawGeometry(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Media::Geometry ^ geometry);" />
      <MemberSignature Language="F#" Value="abstract member DrawGeometry : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Media.Geometry -&gt; unit" Usage="drawingContext.DrawGeometry (brush, pen, geometry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="geometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="brush">Der <see cref="T:System.Windows.Media.Brush" /> zum Ausfüllen der <see cref="T:System.Windows.Media.Geometry" />. Dies ist optional und kann <see langword="null" /> sein. Wenn der Pinsel <see langword="null" /> ist, wird keine Füllung gezeichnet.</param>
        <param name="pen">Der <see cref="T:System.Windows.Media.Pen" />, mit dem die <see cref="T:System.Windows.Media.Geometry" /> gezeichnet werden soll. Dies ist optional und kann <see langword="null" /> sein. Wenn der Stift <see langword="null" /> ist, wird kein Strich gezeichnet.</param>
        <param name="geometry">Das zu zeichnende <see cref="T:System.Windows.Media.Geometry" />.</param>
        <summary>Zeichnet die angegebene <see cref="T:System.Windows.Media.Geometry" /> unter Verwendung der angegebenen <see cref="T:System.Windows.Media.Brush" />- und <see cref="T:System.Windows.Media.Pen" />-Elemente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawGlyphRun">
      <MemberSignature Language="C#" Value="public abstract void DrawGlyphRun (System.Windows.Media.Brush foregroundBrush, System.Windows.Media.GlyphRun glyphRun);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawGlyphRun(class System.Windows.Media.Brush foregroundBrush, class System.Windows.Media.GlyphRun glyphRun) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawGlyphRun(System.Windows.Media.Brush,System.Windows.Media.GlyphRun)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawGlyphRun(System::Windows::Media::Brush ^ foregroundBrush, System::Windows::Media::GlyphRun ^ glyphRun);" />
      <MemberSignature Language="F#" Value="abstract member DrawGlyphRun : System.Windows.Media.Brush * System.Windows.Media.GlyphRun -&gt; unit" Usage="drawingContext.DrawGlyphRun (foregroundBrush, glyphRun)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foregroundBrush" Type="System.Windows.Media.Brush" />
        <Parameter Name="glyphRun" Type="System.Windows.Media.GlyphRun" />
      </Parameters>
      <Docs>
        <param name="foregroundBrush">Der Pinsel zum Zeichnen des Texts.</param>
        <param name="glyphRun">Der zu zeichnende Text.</param>
        <summary>Zeichnet den angegebenen Text.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImage">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet ein Bild in dem vom angegebenen <see cref="T:System.Windows.Rect" /> definierten Bereich.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public abstract void DrawImage (System.Windows.Media.ImageSource imageSource, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawImage(class System.Windows.Media.ImageSource imageSource, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawImage(System.Windows.Media.ImageSource,System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawImage(System::Windows::Media::ImageSource ^ imageSource, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawImage : System.Windows.Media.ImageSource * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawImage (imageSource, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageSource" Type="System.Windows.Media.ImageSource" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="imageSource">Das zu zeichnende Bild.</param>
        <param name="rectangle">Der Bereich, in dem <c>bitmapSource</c> gezeichnet werden soll.</param>
        <summary>Zeichnet ein Bild in dem vom angegebenen <see cref="T:System.Windows.Rect" /> definierten Bereich.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">zum Anzeigen von Bildern, die noch keine <see cref="T:System.Net.WebPermission" /> oder <see cref="T:System.Security.Permissions.FileIOPermission" /> für zugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public abstract void DrawImage (System.Windows.Media.ImageSource imageSource, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawImage(class System.Windows.Media.ImageSource imageSource, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawImage(System.Windows.Media.ImageSource,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawImage(System::Windows::Media::ImageSource ^ imageSource, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawImage : System.Windows.Media.ImageSource * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawImage (imageSource, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageSource" Type="System.Windows.Media.ImageSource" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="imageSource">Das zu zeichnende Bild.</param>
        <param name="rectangle">Der Bereich, in dem <c>bitmapSource</c> gezeichnet werden soll.</param>
        <param name="rectangleAnimations">Die Uhr, mit der Größe und Abmessungen des Rechtecks animiert werden sollen, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Rect" />-Objekte animiert werden können.</param>
        <summary>Zeichnet ein Bild in dem vom angegebenen <see cref="T:System.Windows.Rect" /> definierten Bereich und wendet die angegebene Animationsuhr an.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">zum Anzeigen von Bildern, die noch keine <see cref="T:System.Net.WebPermission" /> oder <see cref="T:System.Security.Permissions.FileIOPermission" /> für zugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLine">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Linie mit dem angegebenen <see cref="T:System.Windows.Media.Pen" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public abstract void DrawLine (System.Windows.Media.Pen pen, System.Windows.Point point0, System.Windows.Point point1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLine(class System.Windows.Media.Pen pen, valuetype System.Windows.Point point0, valuetype System.Windows.Point point1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawLine(System.Windows.Media.Pen,System.Windows.Point,System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawLine(System::Windows::Media::Pen ^ pen, System::Windows::Point point0, System::Windows::Point point1);" />
      <MemberSignature Language="F#" Value="abstract member DrawLine : System.Windows.Media.Pen * System.Windows.Point * System.Windows.Point -&gt; unit" Usage="drawingContext.DrawLine (pen, point0, point1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="point0" Type="System.Windows.Point" />
        <Parameter Name="point1" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="pen">Der Stift, mit dem die Linie gezeichnet werden soll.</param>
        <param name="point0">Der Startpunkt der Linie.</param>
        <param name="point1">Der Endpunkt der Linie.</param>
        <summary>Zeichnet mit dem angegebenen <see cref="T:System.Windows.Media.Pen" /> eine Linie zwischen den angegebenen Punkten.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public abstract void DrawLine (System.Windows.Media.Pen pen, System.Windows.Point point0, System.Windows.Media.Animation.AnimationClock point0Animations, System.Windows.Point point1, System.Windows.Media.Animation.AnimationClock point1Animations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLine(class System.Windows.Media.Pen pen, valuetype System.Windows.Point point0, class System.Windows.Media.Animation.AnimationClock point0Animations, valuetype System.Windows.Point point1, class System.Windows.Media.Animation.AnimationClock point1Animations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawLine(System.Windows.Media.Pen,System.Windows.Point,System.Windows.Media.Animation.AnimationClock,System.Windows.Point,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawLine(System::Windows::Media::Pen ^ pen, System::Windows::Point point0, System::Windows::Media::Animation::AnimationClock ^ point0Animations, System::Windows::Point point1, System::Windows::Media::Animation::AnimationClock ^ point1Animations);" />
      <MemberSignature Language="F#" Value="abstract member DrawLine : System.Windows.Media.Pen * System.Windows.Point * System.Windows.Media.Animation.AnimationClock * System.Windows.Point * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawLine (pen, point0, point0Animations, point1, point1Animations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="point0" Type="System.Windows.Point" />
        <Parameter Name="point0Animations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point1Animations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="pen">Der Stift zum Zeichnen der Linie.</param>
        <param name="point0">Der Startpunkt der Linie.</param>
        <param name="point0Animations">Die Uhr, mit der der Anfangspunkt der Linie animiert werden soll, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Point" />-Objekte animiert werden können.</param>
        <param name="point1">Der Endpunkt der Linie.</param>
        <param name="point1Animations">Die Uhr, mit der der Endpunkt der Linie animiert werden soll, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Point" />-Objekte animiert werden können.</param>
        <summary>Zeichnet mit dem angegebenen <see cref="T:System.Windows.Media.Pen" /> eine Linie zwischen den angegebenen Punkten und wendet die angegebenen Animationsuhren an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangle">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet ein Rechteck.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawRectangle (brush, pen, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="brush">Der Pinsel, mit dem das Rechteck ausgefüllt werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Pinsel <see langword="null" /> ist, wird keine Füllung gezeichnet.</param>
        <param name="pen">Der Stift, mit dem der Strich des Rechtecks gezeichnet werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Stift <see langword="null" /> ist, wird kein Strich gezeichnet.</param>
        <param name="rectangle">Das zu zeichnende Rechteck.</param>
        <summary>Zeichnet ein Rechteck mit dem angegebenen <see cref="T:System.Windows.Media.Brush" /> und <see cref="T:System.Windows.Media.Pen" />. Der Stift und der Pinsel können <see langword="null" /> sein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pinsel und dem Stift werden beide `null`.  Wenn der Pinsel `null`, und klicken Sie dann keine Füllung ausgeführt wird.  Wenn der Stift `null`, wird kein Strich gezeichnet wird.  Wenn der Stift und der Pinsel sind `null`, und klicken Sie dann die Zeichnung nicht sichtbar ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawRectangle (brush, pen, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Der Pinsel, mit dem das Rechteck ausgefüllt werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Pinsel <see langword="null" /> ist, wird keine Füllung gezeichnet.</param>
        <param name="pen">Der Stift, mit dem der Strich des Rechtecks gezeichnet werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Stift <see langword="null" /> ist, wird kein Strich gezeichnet.</param>
        <param name="rectangle">Das zu zeichnende Rechteck.</param>
        <param name="rectangleAnimations">Die Uhr, mit der Größe und Abmessungen des Rechtecks animiert werden sollen, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Rect" />-Objekte animiert werden können.</param>
        <summary>Zeichnet ein Rechteck mit dem angegebenen <see cref="T:System.Windows.Media.Brush" /> und <see cref="T:System.Windows.Media.Pen" /> und wendet die angegebenen Animationsuhren an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pinsel und dem Stift werden beide `null`.  Wenn der Pinsel `null`, und klicken Sie dann keine Füllung ausgeführt wird.  Wenn der Stift `null`, wird kein Strich gezeichnet wird.  Wenn der Stift und der Pinsel sind `null`, und klicken Sie dann die Zeichnung nicht sichtbar ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRoundedRectangle">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet ein abgerundetes Rechteck.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRoundedRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRoundedRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, double radiusX, double radiusY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRoundedRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, float64 radiusX, float64 radiusY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRoundedRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Double,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRoundedRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, double radiusX, double radiusY);" />
      <MemberSignature Language="F#" Value="abstract member DrawRoundedRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * double * double -&gt; unit" Usage="drawingContext.DrawRoundedRectangle (brush, pen, rectangle, radiusX, radiusY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="brush">Der zum Ausfüllen des Rechtecks verwendete Pinsel.</param>
        <param name="pen">Der zum Zeichnen des Strichs für das Rechteck verwendete Stift.</param>
        <param name="rectangle">Das zu zeichnende Rechteck.</param>
        <param name="radiusX">Der Radius in der x-Dimension der abgerundeten Ecken.  Dieser Wert wird an den Bereich von 0 bis <see cref="P:System.Windows.Rect.Width" />/2 geklammert.</param>
        <param name="radiusY">Der Radius in der y-Dimension der abgerundeten Ecken.  Dieser Wert wird an einen Wert zwischen 0 und <see cref="P:System.Windows.Rect.Height" />/2 geklammert.</param>
        <summary>Zeichnet ein abgerundetes Rechteck mit dem angegebenen <see cref="T:System.Windows.Media.Brush" /> und <see cref="T:System.Windows.Media.Pen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pinsel und dem Stift werden beide `null`.  Wenn der Pinsel `null`, und klicken Sie dann keine Füllung ausgeführt wird.  Wenn der Stift `null`, wird kein Strich gezeichnet wird.  Wenn der Stift und der Pinsel sind `null`, und klicken Sie dann die Zeichnung nicht sichtbar ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRoundedRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRoundedRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations, double radiusX, System.Windows.Media.Animation.AnimationClock radiusXAnimations, double radiusY, System.Windows.Media.Animation.AnimationClock radiusYAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRoundedRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations, float64 radiusX, class System.Windows.Media.Animation.AnimationClock radiusXAnimations, float64 radiusY, class System.Windows.Media.Animation.AnimationClock radiusYAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRoundedRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRoundedRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations, double radiusX, System::Windows::Media::Animation::AnimationClock ^ radiusXAnimations, double radiusY, System::Windows::Media::Animation::AnimationClock ^ radiusYAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawRoundedRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawRoundedRectangle (brush, pen, rectangle, rectangleAnimations, radiusX, radiusXAnimations, radiusY, radiusYAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusXAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusY" Type="System.Double" />
        <Parameter Name="radiusYAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Der zum Ausfüllen des Rechtecks verwendete Pinsel oder <see langword="null" /> für keine Füllung.</param>
        <param name="pen">Der zum Zeichnen des Strichs für das Rechteck verwendete Stift, oder <see langword="null" /> für keinen Strich.</param>
        <param name="rectangle">Das zu zeichnende Rechteck.</param>
        <param name="rectangleAnimations">Die Uhr, mit der Größe und Abmessungen des Rechtecks animiert werden sollen, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Rect" />-Objekte animiert werden können.</param>
        <param name="radiusX">Der Radius in der x-Dimension der abgerundeten Ecken.  Dieser Wert wird an den Bereich von 0 bis <see cref="P:System.Windows.Rect.Width" />/2 geklammert.</param>
        <param name="radiusXAnimations">Die Uhr, mit der der <c>radiusX</c>-Wert des Rechtecks animiert werden soll, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Double" />-Werte animiert werden können.</param>
        <param name="radiusY">Der Radius in der y-Dimension der abgerundeten Ecken.  Dieser Wert wird an einen Wert zwischen 0 und <see cref="P:System.Windows.Rect.Height" />/2 geklammert.</param>
        <param name="radiusYAnimations">Die Uhr, mit der der <c>radiusY</c>-Wert des Rechtecks animiert werden soll, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Double" />-Werte animiert werden können.</param>
        <summary>Zeichnet ein abgerundetes Rechteck mit dem angegebenen <see cref="T:System.Windows.Media.Brush" /> und <see cref="T:System.Windows.Media.Pen" /> und wendet die angegebenen Animationsuhren an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pinsel und dem Stift werden beide `null`.  Wenn der Pinsel `null`, und klicken Sie dann keine Füllung ausgeführt wird.  Wenn der Stift `null`, wird kein Strich gezeichnet wird.  Wenn der Stift und der Pinsel sind `null`, und klicken Sie dann die Zeichnung nicht sichtbar ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawText">
      <MemberSignature Language="C#" Value="public void DrawText (System.Windows.Media.FormattedText formattedText, System.Windows.Point origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawText(class System.Windows.Media.FormattedText formattedText, valuetype System.Windows.Point origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawText(System.Windows.Media.FormattedText,System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawText(System::Windows::Media::FormattedText ^ formattedText, System::Windows::Point origin);" />
      <MemberSignature Language="F#" Value="member this.DrawText : System.Windows.Media.FormattedText * System.Windows.Point -&gt; unit" Usage="drawingContext.DrawText (formattedText, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattedText" Type="System.Windows.Media.FormattedText" />
        <Parameter Name="origin" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="formattedText">Der zu zeichnende formatierte Text.</param>
        <param name="origin">Die Position, an der der Text gezeichnet werden soll.</param>
        <summary>Zeichnet formatierten Text an der angegebenen Position.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde bereits geschlossen oder verworfen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawVideo">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet ein Video im angegebenen Bereich.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawVideo">
      <MemberSignature Language="C#" Value="public abstract void DrawVideo (System.Windows.Media.MediaPlayer player, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawVideo(class System.Windows.Media.MediaPlayer player, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawVideo(System.Windows.Media.MediaPlayer,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawVideo (player As MediaPlayer, rectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawVideo(System::Windows::Media::MediaPlayer ^ player, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawVideo : System.Windows.Media.MediaPlayer * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawVideo (player, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="player" Type="System.Windows.Media.MediaPlayer" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="player">Das zu zeichnende Medium.</param>
        <param name="rectangle">Der Bereich, in dem <c>player</c> gezeichnet werden soll.</param>
        <summary>Zeichnet ein Video im angegebenen Bereich.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die Medien gestreckt werden, entsprechend innerhalb des Bereichs, der durch den Rechteckparameter definiert. Wenn das Rechteck und Medien unterschiedliche Seitenverhältnisse aufweisen, erfolgt Verzerrung zu darzustellen. Zur besseren Steuerung, wie Medien verwendet werden, um einen Bereich zu füllen, verwenden Sie die <xref:System.Windows.Media.DrawingContext.DrawRectangle%2A> Befehl aus, um ein Rechteck zu zeichnen, und füllen Sie es mit einer <xref:System.Windows.Media.VisualBrush> , die Medien enthält.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Medien angezeigt, die noch keine <see cref="T:System.Net.WebPermission" /> oder <see cref="T:System.Security.Permissions.FileIOPermission" /> für zugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DrawVideo">
      <MemberSignature Language="C#" Value="public abstract void DrawVideo (System.Windows.Media.MediaPlayer player, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawVideo(class System.Windows.Media.MediaPlayer player, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawVideo(System.Windows.Media.MediaPlayer,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawVideo (player As MediaPlayer, rectangle As Rect, rectangleAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawVideo(System::Windows::Media::MediaPlayer ^ player, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawVideo : System.Windows.Media.MediaPlayer * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawVideo (player, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="player" Type="System.Windows.Media.MediaPlayer" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="player">Das zu zeichnende Medium.</param>
        <param name="rectangle">Der Bereich, in dem das Medium gezeichnet werden soll.</param>
        <param name="rectangleAnimations">Die Uhr, mit der Größe und Abmessungen des Rechtecks animiert werden sollen, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Rect" />-Objekte animiert werden können.</param>
        <summary>Zeichnet ein Video im angegebenen Bereich und wendet die angegebene Animationsuhr an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die Medien gestreckt werden, entsprechend innerhalb des Bereichs, der durch den Rechteckparameter definiert. Wenn das Rechteck und Medien unterschiedliche Seitenverhältnisse aufweisen, erfolgt Verzerrung zu darzustellen. Zur besseren Steuerung, wie Medien verwendet werden, um einen Bereich zu füllen, verwenden Sie die <xref:System.Windows.Media.DrawingContext.DrawRectangle%2A> Befehl aus, um ein Rechteck zu zeichnen, und füllen Sie es mit einer <xref:System.Windows.Media.VisualBrush> , die Medien enthält.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Medien angezeigt, die noch keine <see cref="T:System.Net.WebPermission" /> oder <see cref="T:System.Security.Permissions.FileIOPermission" /> für zugreifen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public abstract void Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.Pop" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Pop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Pop();" />
      <MemberSignature Language="F#" Value="abstract member Pop : unit -&gt; unit" Usage="drawingContext.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Holt den letzten Vorgang für Durchlässigkeitsmaske, Durchlässigkeit, Clip, Effekt oder Transformation, der im Zeichnungskontext abgelegt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem ein Vorgang per pop ausgelesen wird, ist es nicht mehr auf nachfolgende Zeichnungsbefehle angewendet werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Auswirkungen der <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehl.  
  
 [!code-csharp[DrawingContext_procedural_snip#PopExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PopExample.cs#popexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PopExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/popexample.vb#popexamplewholepage)]  
  
 Die folgende Abbildung zeigt die Ausgabe dieses Beispiels:  
  
 ![Mit unterschiedlichen Deckkraftwerten gezeichnete Rechtecke](~/add/media/graphicsmm-drawingcontextpopexample.gif "mit unterschiedlichen Deckkraftwerten gezeichnete Rechtecke")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushClip">
      <MemberSignature Language="C#" Value="public abstract void PushClip (System.Windows.Media.Geometry clipGeometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushClip(class System.Windows.Media.Geometry clipGeometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushClip(System.Windows.Media.Geometry)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushClip (clipGeometry As Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushClip(System::Windows::Media::Geometry ^ clipGeometry);" />
      <MemberSignature Language="F#" Value="abstract member PushClip : System.Windows.Media.Geometry -&gt; unit" Usage="drawingContext.PushClip clipGeometry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipGeometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="clipGeometry">Der Ausschneidebereich, der auf nachfolgende Zeichnungsbefehle angewendet werden soll.</param>
        <summary>Legt den angegebenen Ausschneidebereich im Zeichnungskontext ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Clip-Bereich gilt für alle nachfolgenden zeichnen-Befehle auf, bis sie vom entfernt wird die <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehl.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushEffect">
      <MemberSignature Language="C#" Value="public abstract void PushEffect (System.Windows.Media.Effects.BitmapEffect effect, System.Windows.Media.Effects.BitmapEffectInput effectInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushEffect(class System.Windows.Media.Effects.BitmapEffect effect, class System.Windows.Media.Effects.BitmapEffectInput effectInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushEffect(System.Windows.Media.Effects.BitmapEffect,System.Windows.Media.Effects.BitmapEffectInput)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushEffect (effect As BitmapEffect, effectInput As BitmapEffectInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushEffect(System::Windows::Media::Effects::BitmapEffect ^ effect, System::Windows::Media::Effects::BitmapEffectInput ^ effectInput);" />
      <MemberSignature Language="F#" Value="abstract member PushEffect : System.Windows.Media.Effects.BitmapEffect * System.Windows.Media.Effects.BitmapEffectInput -&gt; unit" Usage="drawingContext.PushEffect (effect, effectInput)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="effect" Type="System.Windows.Media.Effects.BitmapEffect" />
        <Parameter Name="effectInput" Type="System.Windows.Media.Effects.BitmapEffectInput" />
      </Parameters>
      <Docs>
        <param name="effect">Der Effekt, der auf nachfolgende Zeichnungen angewendet werden soll.</param>
        <param name="effectInput">Der Bereich, auf den der Effekt angewendet wird, oder <see langword="null" />, wenn der Effekt auf den gesamten Bereich nachfolgender Zeichnungen angewendet werden soll.</param>
        <summary>Legt den angegebenen <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> im Zeichnungskontext ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Effekt auf alle nachfolgenden Zeichenvorgänge angewendet wird, bis sie von entfernt ist die <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehl.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>, und <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehle.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushGuidelineSet">
      <MemberSignature Language="C#" Value="public abstract void PushGuidelineSet (System.Windows.Media.GuidelineSet guidelines);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushGuidelineSet(class System.Windows.Media.GuidelineSet guidelines) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushGuidelineSet(System.Windows.Media.GuidelineSet)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushGuidelineSet (guidelines As GuidelineSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushGuidelineSet(System::Windows::Media::GuidelineSet ^ guidelines);" />
      <MemberSignature Language="F#" Value="abstract member PushGuidelineSet : System.Windows.Media.GuidelineSet -&gt; unit" Usage="drawingContext.PushGuidelineSet guidelines" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guidelines" Type="System.Windows.Media.GuidelineSet" />
      </Parameters>
      <Docs>
        <param name="guidelines">Der auf nachfolgende Zeichnungen anzuwendende Satz von Richtlinien.</param>
        <summary>Legt den angegebenen <see cref="T:System.Windows.Media.GuidelineSet" /> im Zeichnungskontext ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Richtliniensatz gilt für alle nachfolgenden zeichnen-Befehle auf, bis sie von entfernt ist die <xref:System.Windows.Media.DrawingContext.Pop%2A> Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.GuidelineSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PushOpacity">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt die angegebene Durchlässigkeitseinstellung im Zeichnungskontext ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushOpacity">
      <MemberSignature Language="C#" Value="public abstract void PushOpacity (double opacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacity(float64 opacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacity (opacity As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacity(double opacity);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacity : double -&gt; unit" Usage="drawingContext.PushOpacity opacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacity" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opacity">Der Durchlässigkeitsfaktor, der auf nachfolgende Zeichnungsbefehle angewendet werden soll. Dieser Faktor wird durch vorherige <see cref="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" />-Operationen erhöht.</param>
        <summary>Legt die angegebene Durchlässigkeitseinstellung im Zeichnungskontext ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Deckkraft wird in allen nachfolgenden Zeichnungsbefehlen übernommen, bis sie von entfernt wird die <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehl.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>, und <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehle.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushOpacity">
      <MemberSignature Language="C#" Value="public abstract void PushOpacity (double opacity, System.Windows.Media.Animation.AnimationClock opacityAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacity(float64 opacity, class System.Windows.Media.Animation.AnimationClock opacityAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacity (opacity As Double, opacityAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacity(double opacity, System::Windows::Media::Animation::AnimationClock ^ opacityAnimations);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacity : double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.PushOpacity (opacity, opacityAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacity" Type="System.Double" />
        <Parameter Name="opacityAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="opacity">Der Durchlässigkeitsfaktor, der auf nachfolgende Zeichnungsbefehle angewendet werden soll. Dieser Faktor wird durch vorherige <see cref="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" />-Operationen erhöht.</param>
        <param name="opacityAnimations">Die Uhr, mit der der Durchlässigkeitswert animiert werden soll, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Double" />-Werte animiert werden können.</param>
        <summary>Legt die angegebene Durchlässigkeitseinstellung im Zeichnungskontext ab und wendet die angegebene Animationsuhr an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Deckkraft wird in allen nachfolgenden Zeichnungsbefehlen übernommen, bis sie von entfernt wird die <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehl.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushOpacityMask">
      <MemberSignature Language="C#" Value="public abstract void PushOpacityMask (System.Windows.Media.Brush opacityMask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacityMask(class System.Windows.Media.Brush opacityMask) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacityMask(System.Windows.Media.Brush)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacityMask (opacityMask As Brush)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacityMask(System::Windows::Media::Brush ^ opacityMask);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacityMask : System.Windows.Media.Brush -&gt; unit" Usage="drawingContext.PushOpacityMask opacityMask" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacityMask" Type="System.Windows.Media.Brush" />
      </Parameters>
      <Docs>
        <param name="opacityMask">Die Durchlässigkeitsmaske, die auf nachfolgende Zeichnungen angewendet werden soll. Die Alphawerte dieses Pinsels bestimmen die Durchlässigkeit der Zeichnung, auf die er angewendet wird.</param>
        <summary>Legt die angegebene Durchlässigkeitsmaske im Zeichnungskontext ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Maske wird auf alle nachfolgende Zeichnungsbefehle angewendet, bis sie von entfernt ist die <xref:System.Windows.Media.DrawingContext.Pop%2A> Vorgang.  
  
 Weitere Informationen zum Erstellen von Durchlässigkeitsmasken, finden Sie unter [Übersicht über Durchlässigkeitsmasken](~/docs/framework/wpf/graphics-multimedia/opacity-masks-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushTransform">
      <MemberSignature Language="C#" Value="public abstract void PushTransform (System.Windows.Media.Transform transform);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushTransform(class System.Windows.Media.Transform transform) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushTransform(System.Windows.Media.Transform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushTransform(System::Windows::Media::Transform ^ transform);" />
      <MemberSignature Language="F#" Value="abstract member PushTransform : System.Windows.Media.Transform -&gt; unit" Usage="drawingContext.PushTransform transform" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transform" Type="System.Windows.Media.Transform" />
      </Parameters>
      <Docs>
        <param name="transform">Die Transformation, die auf nachfolgende Zeichnungsbefehle angewendet werden soll.</param>
        <summary>Legt den angegebenen <see cref="T:System.Windows.Media.Transform" /> im Zeichnungskontext ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Transformation wird für alle nachfolgenden zeichnen-Befehle, bis sie von entfernt ist die <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehl.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dieser Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyApiNonstructuralChange">
      <MemberSignature Language="C#" Value="protected virtual void VerifyApiNonstructuralChange ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void VerifyApiNonstructuralChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.VerifyApiNonstructuralChange" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub VerifyApiNonstructuralChange ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void VerifyApiNonstructuralChange();" />
      <MemberSignature Language="F#" Value="abstract member VerifyApiNonstructuralChange : unit -&gt; unit&#xA;override this.VerifyApiNonstructuralChange : unit -&gt; unit" Usage="drawingContext.VerifyApiNonstructuralChange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dieser Member unterstützt die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>