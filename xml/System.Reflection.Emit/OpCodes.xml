<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b90a20583f24b5370819a5d643b5b26bb93210ac" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37643730" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Felddarstellungen der MSIL (Microsoft Intermediate Language)-Anweisungen für die Ausgabe durch die <see cref="T:System.Reflection.Emit.ILGenerator" />-Klassenmember bereit, beispielsweise <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine detaillierte Beschreibung von der Memberopcodes finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere "Partition III: CIL Instruction Set" und "Partition II: Metadata Definition and Semantics". Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](http://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Erstellung von einer dynamischen Methode mit <xref:System.Reflection.Emit.ILGenerator> ausgeben `OpCodes` in einem <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Addiert zwei Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|58|Hinzufügen|Addiert zwei numerische Werte, einen neuen numerischen Wert zurückgeben.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `value1` hinzugefügt `value2`.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Überlauf ist nicht für Ganzzahloperationen (richtige Überlaufdaten, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Ganze Zahl hinzufügen, und nicht das Sättigungsverfahren. Beispiel: vorausgesetzt der 8-Bit-Ganzzahlen, in denen `value1` auf 255 festgelegt und `value2` festgelegt ist auf 1 fest, das umschlossene Ergebnis lautet 0 und 256.  
  
 Gleitkommaüberlauf gibt `+inf` (`PositiveInfinity`) oder `-inf` (`NegativeInfinity`).  
  
 Die zulässigen Operandentypen und ihre entsprechenden Ergebnis-Datentyp werden in der folgenden Tabelle aufgeführt. Wenn kein Eintrag für eine bestimmte vorhanden ist (z. B. `int32` und `float`; `int32` und `int64`), dabei handelt es sich eine ungültige Microsoft Intermediate Language (MSIL) wird ein Fehler generiert.  
  
|Operand|value1-Typ|value2-Typ|Ergebnistyp|  
|-------------|-----------------|-----------------|-----------------|  
|Hinzufügen|`int32`|`int32`|`int32`|  
|Hinzufügen|`int32`|`native int`|`native int`|  
|Hinzufügen|`int32`|`&`|`&`|  
|Hinzufügen|`int32`|`*`|`*`|  
|Hinzufügen|`int64`|`int64`|`int64`|  
|Hinzufügen|`native int`|`int32`|`native int`|  
|Hinzufügen|`native int`|`native int`|`native int`|  
|Hinzufügen|`native int`|`&`|`&`|  
|Hinzufügen|`native int`|`*`|`*`|  
|Hinzufügen|`F`|`F`|`F`|  
|Hinzufügen|`&`|`int32`|`&`|  
|Hinzufügen|`&`|`native int`|`&`|  
|Hinzufügen|`*`|`int32`|`*`|  
|Hinzufügen|`*`|`native int`|`*`|  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `add` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Addiert zwei ganze Zahlen, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D6|Add.ovf|Addiert zwei ganze Zahl mit Vorzeichen-Werte, mit der eine überlaufprüfung.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `value1` hinzugefügt `value2` durch eine Suche nach einem Überlauf.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt wird.  
  
 Sie können diesen Vorgang auf Ganzzahlen mit Vorzeichen ausführen. Verwenden Sie für Gleitkommawerte, <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Die zulässigen Operandentypen und ihre entsprechenden Ergebnis-Datentyp werden in der folgenden Tabelle aufgeführt. Wenn kein Eintrag für eine bestimmte vorhanden ist (z. B. `int32` und `float`; `int32` und `int64`), dabei handelt es sich eine ungültige Anweisung für die Microsoft Intermediate Language (MSIL) wird ein Fehler generiert.  
  
|Operand|value1-Typ|value2-Typ|Ergebnistyp|  
|-------------|-----------------|-----------------|-----------------|  
|Hinzufügen|`int32`|`int32`|`int32`|  
|Hinzufügen|`int32`|`native int`|`native int`|  
|Hinzufügen|`int32`|`&`|`&`|  
|Hinzufügen|`int32`|`*`|`*`|  
|Hinzufügen|`int64`|`int64`|`int64`|  
|Hinzufügen|`native int`|`int32`|`native int`|  
|Hinzufügen|`native int`|`native int`|`native int`|  
|Hinzufügen|`native int`|`&`|`&`|  
|Hinzufügen|`native int`|`*`|`*`|  
|Hinzufügen|`F`|`F`|`F`|  
|Hinzufügen|`&`|`int32`|`&`|  
|Hinzufügen|`&`|`native int`|`&`|  
|Hinzufügen|`*`|`int32`|`*`|  
|Hinzufügen|`*`|`native int`|`*`|  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `add.ovf` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Addiert zwei Ganzzahlwerte ohne Vorzeichen, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D7|Add.ovf.un|Fügt zwei Ganzzahlwerte ohne Vorzeichen mit eine überlaufprüfung hinzu.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `value1` hinzugefügt `value2` durch eine Suche nach einem Überlauf.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt wird.  
  
 Sie können diesen Vorgang auf Ganzzahlen mit Vorzeichen ausführen. Verwenden Sie für Gleitkommawerte, <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Die zulässigen Operandentypen und ihre entsprechenden Ergebnis-Datentyp werden in der folgenden Tabelle aufgeführt. Wenn kein Eintrag für eine bestimmte vorhanden ist (z. B. `int32` und `float`; `int32` und `int64`), dabei handelt es sich eine ungültige Anweisung für die Microsoft Intermediate Language (MSIL) wird ein Fehler generiert.  
  
|Operand|value1-Typ|value2-Typ|Ergebnistyp|  
|-------------|-----------------|-----------------|-----------------|  
|Hinzufügen|`int32`|`int32`|`int32`|  
|Hinzufügen|`int32`|`native int`|`native int`|  
|Hinzufügen|`int32`|`&`|`&`|  
|Hinzufügen|`int32`|`*`|`*`|  
|Hinzufügen|`int64`|`int64`|`int64`|  
|Hinzufügen|`native int`|`int32`|`native int`|  
|Hinzufügen|`native int`|`native int`|`native int`|  
|Hinzufügen|`native int`|`&`|`&`|  
|Hinzufügen|`native int`|`*`|`*`|  
|Hinzufügen|`F`|`F`|`F`|  
|Hinzufügen|`&`|`int32`|`&`|  
|Hinzufügen|`&`|`native int`|`&`|  
|Hinzufügen|`*`|`int32`|`*`|  
|Hinzufügen|`*`|`native int`|`*`|  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `add.ovf.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Berechnet das bitweise AND für zwei Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Anweisung|Beschreibung |  
|------------|-----------------|-----------------|  
|5F|und|Bestimmt, das bitweise AND von zwei ganzzahligen Werten.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value1` und `value2` werden aus den Stapel geholt, das bitweise AND von zwei Werten berechnet wird.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `and` Anweisung berechnet das bitweise AND für die beiden obersten Werte im Stapel, und das Ergebnis auf dem Stapel verbleibt.  
  
 `And` ist ein Vorgang für die ganze Zahlen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `and` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen nicht verwalteten Zeiger auf die Argumentliste der aktuellen Methode zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 00|arglist|Gibt ein Handle des Argument-Liste für die aktuelle Methode zurück.|  
  
 Keine Auswertung Stack Verhalten werden durch diesen Vorgang ausgeführt.  
  
 Die `arglist` Anweisung zurückgibt, ein nicht transparentes Handle (ein nicht verwalteter Zeiger, Typ `native int`), die die Argumentliste der aktuellen Methode darstellt. Dieses Handle ist nur während der Lebensdauer der aktuellen Methode gültig. Sie können jedoch das Handle an andere Methoden übergeben, solange die aktuelle Methode für den Thread des Steuerelements ist. Sie können nur ausführen, die `arglist` Anweisung innerhalb einer Methode, die eine Variable Anzahl von Argumenten akzeptiert.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `arglist` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn zwei Werte übereinstimmen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|Branch für die zielanweisung am Offset `target` , wenn die beiden Werte gleich sind.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `beq` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` gleich `value2`. Der Effekt ist derselbe wie das Ausführen einer `ceq` Anweisung, gefolgt von einem `brtrue` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Die zulässigen Operandentypen werden unter folgenden Werten gekapselt:  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe.  
  
 Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden (solche Übertragungen sind stark eingeschränkt und müssen die <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung stattdessen).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `beq` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn zwei Werte übereinstimmen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq.s `target`|Branch für die zielanweisung am Offset `target` wenn gleich, Kurzform|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `beq.s` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` gleich `value2`. Der Effekt ist derselbe wie das Ausführen einer `ceq` Anweisung, gefolgt von einem `brtrue` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als einer signierten 1-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Die zulässigen Operandentypen werden unter folgenden Werten gekapselt:  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe.  
  
 Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden (solche Übertragungen sind stark eingeschränkt und müssen die <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung stattdessen).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `beq.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert größer oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|Die Verzweigung für die zielanweisung mit dem angegebenen Offset aus, wenn der erste Wert größer als oder gleich dem zweiten Wert ist.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist größer als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bge` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als oder gleich `value2`. Der Effekt ist identisch mit der Ausführung einer `clt.un` Anweisung, gefolgt von einem `brfalse` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `bge` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert größer oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge.s `target`|Die Verzweigung für die zielanweisung mit dem angegebenen Offset ist der erste Wert größer als oder gleich dem zweiten Wert, Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist größer als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bge.s` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als oder gleich `value2`. Der Effekt ist identisch mit der Ausführung einer `clt.un` Anweisung, gefolgt von einem `brfalse` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als einer signierten 1-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `bge.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.un `target`|Die Verzweigung für die zielanweisung mit dem angegebenen Offset aus, wenn der erste Wert größer als oder gleich dem zweiten Wert (Werte ohne Vorzeichen).|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist größer als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bge.un` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als oder gleich `value2`, wenn Sie mithilfe von-Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `clt` Anweisung, gefolgt von einem `brfalse` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `bge.un` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|Die Verzweigung für die zielanweisung mit dem angegebenen Offset ist der erste Wert größer als oder gleich dem zweiten Wert (Werte ohne Vorzeichen), Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist größer als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bge.un.s` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als oder gleich `value2`, wenn Sie mithilfe von-Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `clt` Anweisung, gefolgt von einem `brfalse` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als einer signierten 1-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `bge.un.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|3D < `int32` >|bgt `target`|Die Verzweigung für die zielanweisung mit dem angegebenen Offset aus, wenn der erste Wert größer als der zweite Wert ist.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist größer als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bgt` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als `value2`. Der Effekt ist identisch mit der Ausführung einer `cgt` Anweisung, gefolgt von einem `brtrue` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `bgt` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt.s `target`|Die Verzweigung für die zielanweisung mit dem angegebenen Offset aus, wenn der erste Wert größer als der zweite Wert ist, kurzes Format ist.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist größer als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bgt.s` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als `value2`. Der Effekt ist identisch mit der Ausführung einer `cgt` Anweisung, gefolgt von einem `brtrue` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als einer signierten 1-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `bgt.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un `target`|Die Verzweigung für die zielanweisung mit dem angegebenen Offset aus, wenn der erste Wert größer als der zweite Wert (Werte ohne Vorzeichen) ist.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist größer als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bgt.un` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als `value2`, wenn Sie mithilfe von-Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `cgt.un` Anweisung, gefolgt von einem `brtrue` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `bgt.un` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|Die Verzweigung für die zielanweisung mit dem angegebenen Offset ist der erste Wert größer als der zweite Wert (Werte ohne Vorzeichen), Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist größer als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bgt.un.s` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als `value2`, wenn Sie mithilfe von-Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `cgt.un` Anweisung, gefolgt von einem `brtrue` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als einer signierten 1-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `bgt.un.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert kleiner oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|3E `<int32>`|ble `target`|Die Verzweigung für die zielanweisung mit dem angegebenen Offset aus, wenn der erste Wert kleiner oder gleich dem zweiten Wert ist.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist kleiner als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `ble` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als oder gleich `value2`. Der Effekt ist identisch mit der Ausführung einer `cgt` Anweisung (`cgt.un` für float) gefolgt von einem `brfalse` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ble` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert kleiner oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble.s `target`|Die Verzweigung für die zielanweisung mit dem angegebenen Offset aus, wenn der erste Wert kleiner als oder gleich der zweite Wert ist, kurzes Format ist.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist kleiner als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `ble.s` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als oder gleich `value2`. Der Effekt ist identisch mit der Ausführung einer `cgt` Anweisung (`cgt.un` für float) Anweisung, gefolgt von einem`brfalse` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als einer signierten 1-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ble.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble.un `target`|Die Verzweigung für die zielanweisung mit dem angegebenen Offset aus, wenn der erste Wert kleiner oder gleich dem zweiten Wert (Werte ohne Vorzeichen) ist.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist kleiner als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `ble.un` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als oder gleich `value2`, wenn Sie mithilfe von-Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `cgt.un` Anweisung (`cgt` für float) gefolgt von einem `brfalse` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ble.un` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble.un.s `target`|Die Verzweigung für die zielanweisung mit dem angegebenen Offset aus, wenn der erste Wert kleiner oder gleich dem zweiten Wert (Werte ohne Vorzeichen), Kurzform ist.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist kleiner als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `ble.un.s` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als oder gleich `value2`, wenn Sie mithilfe von-Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `cgt.un` Anweisung (`cgt` für float) gefolgt von einem `brfalse` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als einer signierten 1-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ble.un.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert kleiner als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|3F &LT; `int32` >|blt `target`|Die Verzweigung, die zielanweisung, in dem angegebenen Offset aus, wenn der erste Wert ist kleiner als der zweite Wert.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist kleiner als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `blt` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als oder gleich `value2`. Der Effekt ist identisch mit der Ausführung einer `clt` Anweisung, gefolgt von einem `brtrue` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `blt` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert kleiner als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt.s `target`|Die Verzweigung für die zielanweisung auf dem angegebenen Offset aus, wenn der erste Wert ist kleiner als der zweite Wert, Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist kleiner als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `blt.s` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als `value2`. Der Effekt ist identisch mit der Ausführung einer `clt` Anweisung, gefolgt von einem `brtrue` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als einer signierten 1-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `blt.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt.un `target`|Die Verzweigung, die zielanweisung, in dem angegebenen Offset aus, wenn der erste Wert ist kleiner als der zweite Wert (Werte ohne Vorzeichen).|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist kleiner als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `blt.un` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als `value2`, wenn Sie mithilfe von-Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `clt.un` Anweisung, gefolgt von einem `brtrue` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `blt.un` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|Die Verzweigung, die zielanweisung, in dem angegebenen Offset aus, wenn der erste Wert ist kleiner als der zweite Wert (Werte ohne Vorzeichen), Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist kleiner als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `blt.un` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als `value2`, wenn Sie mithilfe von-Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `clt.un` Anweisung, gefolgt von einem `brtrue` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `blt.un.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn zwei Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte ungleich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.un `target`|Verzweigung an das Ziel der Anweisung mit dem angegebenen Offset aus, wenn zwei Ganzzahlwerte ohne Vorzeichen sind (Werte ohne Vorzeichen) nicht gleich.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist nicht gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bne.un` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist nicht gleich `value2`, wenn Sie mithilfe von-Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `ceq` Anweisung, gefolgt von einem `brfalse` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `bne.un` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn zwei Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte ungleich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|Verzweigung an das Ziel die Anweisung mit dem angegebenen Offset aus, wenn zwei Ganzzahlwerte ohne Vorzeichen sind, nicht gleich (Werte ohne Vorzeichen), Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt, wenn `value1` ist nicht gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bne.un` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist nicht gleich `value2`, wenn Sie mithilfe von-Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `ceq` Anweisung, gefolgt von einem `brfalse` Branch die bestimmte zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `bne.un.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert einen Werttyp in einen Objektverweis (Typ <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|8C < `T` >|Feld `valTypeToken`|Konvertiert einen Werttyp (des Typs im angegebenen `valTypeToken`) in einen Objektverweis für die "true".|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Werttyp ist auf dem Stapel abgelegt.  
  
2.  Der Werttyp wird vom Stapel geholt. die `box` Vorgang ausgeführt wird.  
  
3.  Ein Objektverweis auf den resultierenden Typ von "geschachtelten" Wert ist auf dem Stapel abgelegt.  
  
 Ein Werttyp verfügt über zwei separate Darstellungen in der Common Language Infrastructure (CLI):  
  
-   Eine "raw" Form verwendet, wenn ein Werttyp in ein anderes Objekt oder auf dem Stapel eingebettet ist.  
  
-   Ein "geschachtelte" Formular, in denen die Daten in den Werttyp in ein Objekt umschlossen (geschachtelt) ist, sodass es als unabhängige Einheit vorhanden ist.  
  
 Die `box` -Anweisung konvertiert den für "raw" (nicht geschachtelten)-Werttyp in einen Objektverweis (Typ `O`). Dies wird erreicht, indem Sie ein neues Objekt erstellen und Kopieren der Daten aus dem Werttyp in das neu zugeordnete Objekt. `valTypeToken` ist ein Metadatentoken, das den Typ des Werttyps auf dem Stapel angibt.  
  
 <xref:System.OutOfMemoryException> wird ausgelöst, wenn nicht genügend zum Erfüllen der Anforderung Arbeitsspeicher.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn Microsoft Intermediate Language (MSIL) in systemeigenen Code anstelle einer zur Laufzeit konvertiert wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `box` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung bedingungslos an eine Zielanweisung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|Branches an eine zielanweisung am angegebenen Offset.|  
  
 Keine Auswertung Stack Verhalten werden durch diesen Vorgang ausgeführt.  
  
 Die `br` -Anweisung überträgt die Steuerung bedingungslos an eine zielanweisung. Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `br` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung bedingungslos an eine Zielanweisung (Kurzform).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|Branches an eine zielanweisung am angegebenen Offset, Kurzform.|  
  
 Keine Auswertung Stack Verhalten werden durch diesen Vorgang ausgeführt.  
  
 Die `br.s` -Anweisung überträgt die Steuerung bedingungslos an eine zielanweisung. Bei der zielinstruktion wird als einer signierten 1-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `br.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Signalisiert CLI (Common Language Infrastructure), den Debugger darüber zu informieren, dass ein Haltepunkt erreicht wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|01|break|Informieren Sie einem Debugger, dass ein Haltepunkt erreicht wird.|  
  
 Keine Auswertung Stack Verhalten werden durch diesen Vorgang ausgeführt.  
  
 Die `break` Anweisung ist für die Debugunterstützung. Es signalisiert die CLI, um den Debugger darüber zu informieren, dass ein Haltepunkt erreicht wurde. Es wurde keine anderen Auswirkungen auf den Interpreter-Zustand.  
  
 Die `break` Anweisung weist den kleinsten mögliche-Anweisung Größe aktivieren Code einen Haltepunkt Patchen und minimale Unruhen, um den umgebenden Code zu generieren.  
  
 Die `break` Anweisung an einen Debugger abgefangen, keine Aktion durchführen oder eine Sicherheitsausnahme auslösen kann. Das genaue Verhalten ist implementierungsdefiniert.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `break` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn <paramref name="value" /> entweder <see langword="false" />, ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic) oder 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|Branches an eine zielanweisung am angegebenen Offset bei `false`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird durch einen vorherigen Vorgang auf dem Stapel abgelegt.  
  
2.  `value` wird vom Stapel geholt. Wenn `value` ist `false`, branch `target`.  
  
 Die `brfalse` Anweisung (und seiner Aliase `brnull` und `brzero`) überträgt die Steuerung an den angegebenen zielanweisung Wenn `value` (des Typs `int32`, `int64`, Objektverweis `O`verwaltete Zeiger `&`, flüchtigen Zeiger `*`, `native int`) 0 (null) (`false`). Wenn `value` ungleich Null (`true`) die Ausführung wird fortgeführt, bei der nächsten Anweisung.  
  
 Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `brfalse` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn <paramref name="value" /> entweder <see langword="false" />, ein NULL-Verweis oder 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|2C &LT;`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|Branches an eine zielanweisung am angegebenen Offset bei `false`, Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird durch einen vorherigen Vorgang auf dem Stapel abgelegt.  
  
2.  `value` wird vom Stapel geholt. Wenn `value` ist `false`, branch `target`.  
  
 Die `brfalse.s` Anweisung (und seiner Aliase `brnull` und `brzero`) überträgt die Steuerung an den angegebenen zielanweisung Wenn `value` (des Typs `int32`, `int64`, Objektverweis `O`verwaltete Zeiger `&`, flüchtigen Zeiger `*`, `native int`) 0 (null) (`false`). Wenn `value` ungleich Null (`true`) die Ausführung wird fortgeführt, bei der nächsten Anweisung.  
  
 Bei der zielinstruktion wird als einer signierten 1-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `brfalse.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn <paramref name="value" /> entweder <see langword="true" />, nicht NULL oder ungleich 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|Branch an eine zielanweisung am angegebenen Offset NULL ungleich (`true`).|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird durch einen vorherigen Vorgang auf dem Stapel abgelegt.  
  
2.  `value` wird vom Stapel geholt. Wenn `value` ist `true`, branch `target`.  
  
 Die `brtrue` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value` (Typ `native int`) ungleich NULL ist (`true`). Wenn `value` ist 0 (null) (`false`) die Ausführung wird fortgeführt, bei der nächsten Anweisung.  
  
 Wenn `value` ist ein Objektverweis (Typ `O`) klicken Sie dann `brinst` (ein Alias für `brtrue`) überträgt die Steuerung, wenn es sich um eine Instanz eines Objekts darstellt (z. B. ist dies nicht der null-Objektverweis; finden Sie unter <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Bei der zielinstruktion wird als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `brtrue` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn <paramref name="value" /> entweder <see langword="true" />, nicht NULL oder ungleich 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|Branch an eine zielanweisung am angegebenen Offset NULL ungleich (`true`), Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird durch einen vorherigen Vorgang auf dem Stapel abgelegt.  
  
2.  `value` wird vom Stapel geholt. Wenn `value` ist `true`, branch `target`.  
  
 Die `brtrue.s` -Anweisung überträgt die Steuerung an den angegebenen zielanweisung Wenn `value` (Typ `native int`) ungleich NULL ist (`true`). Wenn `value` ist 0 (null) (`false`) die Ausführung wird fortgeführt, bei der nächsten Anweisung.  
  
 Wenn `value` ist ein Objektverweis (Typ `O`) klicken Sie dann `brinst` (ein Alias für `brtrue`) überträgt die Steuerung, wenn es sich um eine Instanz eines Objekts darstellt (z. B. ist dies nicht der null-Objektverweis; finden Sie unter <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Bei der zielinstruktion wird als einer signierten 1-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `brtrue.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Methode auf, die der übergebene Methodendeskriptor angibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|28 < `T` >|Rufen Sie `methodDesc`|Rufen Sie die Methode, die beschriebenen `methodDesc`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Methodenargumente `arg1` über `argN` auf dem Stapel abgelegt werden.  
  
2.  Methodenargumente `arg1` über `argN` werden aus den Stapel geholt Aufruf der Methode mit diesen Argumenten ausgeführt wird und die Steuerung an die Methode, die von der Methodendeskriptor bezeichnet. Nach Abschluss des Vorgangs ist ein Wert von der aufgerufenermethode generiert und an den Aufrufer gesendet.  
  
3.  Der Rückgabewert ist auf dem Stapel abgelegt.  
  
 Die `call` -Anweisung ruft die Methode, die mit der Anweisung übergeben Methodendeskriptor verweist. Der Methodendeskriptor ist ein Metadatentoken, das gibt die Methode an den Aufruf und die Anzahl, Typ und Reihenfolge der Argumente, die auf dem Stapel an die Methode als auch für die Aufrufkonvention, die verwendet werden zu übergebenden platziert wurden. Der `call` Anweisung kann unmittelbar vorangestellt werden, wird eine `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) Präfix-Anweisung, um anzugeben, dass der aktuelle Methodenzustand freigegeben werden sollen, bevor die Steuerung zu übertragen. Der Aufruf Steuerelement auf eine höhere Vertrauensstellung als die Origin-Methode übertragen, wird der Stapelrahmen nicht freigegeben. Stattdessen wird die Ausführung im Hintergrund fortgesetzt als ob die `tail` hatte, wurde nicht angegeben. Das Metadatentoken enthält genügend Informationen, um zu bestimmen, ob eine statische Methode, eine Instanzmethode, eine virtuelle Methode oder eine globale Funktion aufgerufen wird. In all diesen Fällen die Zieladresse wird vollständig von der Methodendeskriptor bestimmt (vergleichen Sie dies mit der <xref:System.Reflection.Emit.OpCodes.Callvirt> Anweisung zum Aufrufen von virtueller Methoden, in denen hängt von der Zieladresse auch die Common Language Runtime-Typ der Instanz Referenz zu übertragen, bevor die <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Die Argumente werden auf dem Stapel in links-nach-rechts-Reihenfolge platziert. Das erste Argument ist, also berechnet und auf dem Stapel, auf das zweite Argument und dann auf die dritte, platziert werden, bis alle erforderlichen Argumente auf dem Stapel in absteigender Reihenfolge sind. Es gibt drei wichtige Sonderfälle:  
  
 1. Aufrufe mit einer Instanz (oder virtuell) Methode muss mithilfe von Push übertragen, Instanzverweis vor allen für den Benutzer sichtbare Argumenten. Die Instanzverweis muss kein null-Verweis sein. Die Signatur in den Metadaten enthält einen Eintrag in der Parameterliste für keine der `this` Zeiger; stattdessen wird ein wenig an, ob die Methode übergeben werden muss die `this` Zeiger.  
  
 2. Es ist zulässig, rufen Sie eine virtuelle Methode mit `call` (statt `callvirt`); Dies bedeutet, dass die Methode besteht darin, mit der Klasse, die Methode statt als dynamisch vom aufgerufenen Objekt angegebenen aufgelöst werden.  
  
 3. Beachten Sie, dass ein Delegat des `Invoke` Methode kann aufgerufen werden, entweder mit der `call` oder `callvirt` Anweisung.  
  
 <xref:System.Security.SecurityException> kann ausgelöst werden, wenn die Sicherheit des Systems den Aufrufer Zugriff an die aufgerufene Methode nicht gewährt. Die sicherheitsüberprüfung kann auftreten, wenn die Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code nicht zur Laufzeit konvertiert werden.  
  
> [!NOTE]
>  Beim Aufrufen von Methoden, die "System.Object" für Werttypen, erwägen Sie die Verwendung der `constrained` mit dem Präfix die `callvirt` Anweisung anstelle von Ausgeben einer `call` Anweisung. Dies besteht keine Notwendigkeit zum Ausgeben von anderen Integritätsstufe abhängig davon, ob der Typ die Methode überschreibt, die ein potenzielles Problem der versionsverwaltung vermeiden. Erwägen Sie die Verwendung der `constrained` Präfix beim Aufrufen von Methoden für Werttypen, da der Value-Type-Methode implementiert die Schnittstellenmethode kann geändert werden, mithilfe einer `MethodImpl`. Diese Probleme werden ausführlicher beschrieben. die <xref:System.Reflection.Emit.OpCodes.Constrained> Opcode.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `call` Opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode, MethodInfo, Type  
  
> [!NOTE]
>  Die <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> Methode dient zur `varargs` aufrufen. Verwenden der <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methode für die normale Aufrufe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die angegebene Methode auf dem Auswertungsstapel (als Zeiger auf einen Einstiegspunkt) mit Argumenten auf, die durch eine Aufrufkonvention beschrieben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|29 < `T` >|die calli `callSiteDescr`|Ruft die Methode, die auf den verwiesen wird mit Argumenten, die durch die Aufrufkonvention beschrieben wird.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Methodenargumente `arg1` über `argN` auf dem Stapel abgelegt werden.  
  
2.  Die Zeiger auf den Eintrag ist auf dem Stapel abgelegt.  
  
3.  Methodenargumente `arg1` über `argN` und die Zeiger auf den Eintrag vom Stapel geholt werden; der Aufruf der Methode erfolgt. Nach Abschluss des Vorgangs ist ein Wert von der aufgerufenermethode generiert und an den Aufrufer gesendet.  
  
4.  Der Rückgabewert ist auf dem Stapel abgelegt.  
  
 Die `calli` Anweisung ruft den Eintrag Zeiger mit den Argumenten `arg1` über `argN`. Die Typen der diese Argumente werden durch die bestimmte Aufrufkonvention beschrieben (`callSiteDesc`). Die `calli` Anweisung kann unmittelbar vorangestellt werden eine `tail` Präfix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) angeben, dass der aktuelle Methodenzustand freigegeben werden sollen, bevor die Steuerung zu übertragen. Wenn der Aufruf übertragen würden wird Steuerelement auf eine höhere Vertrauensstellung als die Origin-Methode der Stapelrahmen nicht freigegeben. stattdessen die Ausführung im Hintergrund fortgesetzt wird wie die `tail` hatte, wurde nicht angegeben.  
  
 Die Zeiger auf den Eintrag wird davon ausgegangen, dass ein bestimmter Zeiger in systemeigenen Code (des Zielcomputers) sein, die mit den Argumenten, die durch die Aufrufkonvention (ein Metadatentoken für eine eigenständige Signatur) beschriebenen legitim aufgerufen werden kann. Ein solchen Zeiger kann erstellt werden, mithilfe der <xref:System.Reflection.Emit.OpCodes.Ldftn> oder <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> Anweisungen oder von nativem Code übergeben.  
  
 Die Aufrufkonvention nicht dynamisch aktiviert wird, sodass code mit einem `calli` Anweisung funktioniert nicht ordnungsgemäß, wenn das Ziel die angegebene Aufrufkonvention nicht tatsächlich verwendet.  
  
 Die Argumente werden auf dem Stapel in links-nach-rechts-Reihenfolge platziert. Das erste Argument ist, also berechnet und auf dem Stapel, auf das zweite Argument und dann auf die dritte, platziert werden, bis alle erforderlichen Argumente auf dem Stapel in absteigender Reihenfolge sind. Die Reihenfolge der Argument-Erstellung-Codes für eine Instanz oder eine virtuelle Methode muss mithilfe von Push übertragen, Instanz-Verweis (der keine null-Verweis sein muss) vor allen für den Benutzer sichtbare Argumenten.  
  
 <xref:System.Security.SecurityException> kann ausgelöst werden, wenn die Sicherheit des Systems den Aufrufer Zugriff an die aufgerufene Methode nicht gewährt werden. Die sicherheitsüberprüfung kann auftreten, wenn die Microsoft Intermediate Language (MSIL)-Anweisungen nicht zur Laufzeit, sondern in systemeigenen Code konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> Methoden können verwendet werden, um das Ausführen einer `calli` Anweisung auf dem Stapel. Beachten Sie, dass `calli` aufgerufen werden soll, über die unten aufgeführten Methoden mithilfe der <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Klasse, um die Anweisung direkt auf dem Stapel platzieren.  
  
-   ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.  
  
-   ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine spät gebundene Methode für ein Objekt auf und legt den Rückgabewert auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|6F &LT; `T` >|callvirt `method`|Ruft eine bestimmte Methode zugeordnete `obj`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `obj` wird auf dem Stapel abgelegt.  
  
2.  Methodenargumente `arg1` über `argN` auf dem Stapel abgelegt werden.  
  
3.  Methodenargumente `arg1` über `argN` und der Objektverweis `obj` werden aus den Stapel geholt Aufruf der Methode mit diesen Argumenten ausgeführt wird und die Steuerung an die Methode in `obj` verweist die-Methode Metadatentoken. Nach Abschluss des Vorgangs ist ein Wert von der aufgerufenermethode generiert und an den Aufrufer gesendet.  
  
4.  Der Rückgabewert ist auf dem Stapel abgelegt.  
  
 Die `callvirt` Anweisung ruft eine spät gebundene Methode für ein Objekt. D. h. die Methode basierend auf den Laufzeittyp der ausgewählt wird `obj` statt der während der Kompilierung-Klasse, die in den Zeiger auf den angezeigt. `Callvirt` Dient zum Aufrufen von virtuellen Methoden und Instanzenmethoden. Die `callvirt` Anweisung kann unmittelbar vorangestellt werden, wird eine `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) Präfix, um anzugeben, dass der aktuelle Stapelrahmen freigegeben werden sollen, bevor die Steuerung zu übertragen. Steuerung auf eine höhere Vertrauensstellung als die ursprüngliche Methode den Stapelrahmen wird nicht freigegeben werden, wenn der Aufruf übertragen würden.  
  
 Das Metadatentoken der Methode stellt den Namen, die Klasse und die Signatur der Methode aufgerufen. Die zugeordnete Klasse `obj` ist die Klasse, von denen, die es eine Instanz ist. Wenn die Klasse eine nicht statische Methode, die den Namen angegebenen Methode und der Signatur entspricht definiert, wird diese Methode aufgerufen. Andernfalls werden alle Klassen in der Kette der Basisklasse dieser Klasse in der Reihenfolge überprüft. Es ist ein Fehler, wenn keine Methode gefunden wird.  
  
 `Callvirt` Holt vor dem Aufrufen der Methode das Objekt und die zugehörigen Argumente aus dem Auswertungsstapel ab. Wenn die Methode einen Rückgabewert verfügt, wird es auf dem Stapel nach Abschluss der Methode abgelegt. Klicken Sie auf der aufgerufenen Seite das `obj` Parameter als Argument 0 (null) zugegriffen wird `arg1` als Argument 1 und So weiter.  
  
 Die Argumente werden auf dem Stapel in links-nach-rechts-Reihenfolge platziert. Das erste Argument ist, also berechnet und auf dem Stapel, auf das zweite Argument und dann auf die dritte, platziert werden, bis alle erforderlichen Argumente auf dem Stapel in absteigender Reihenfolge sind. Den Instanzverweis `obj` (immer erforderlich, für die `callvirt`) muss vor allen für den Benutzer sichtbare Argumenten abgelegt werden. Die Signatur (in das Metadatentoken) muss keinen Eintrag in der Parameterliste für diesen Zeiger.  
  
 Beachten Sie, dass eine virtuelle Methode auch aufgerufen werden kann, mit der <xref:System.Reflection.Emit.OpCodes.Call> Anweisung.  
  
 <xref:System.MissingMethodException> wird ausgelöst, wenn eine nicht statische Methode mit dem angegebenen Namen und die Signatur nicht konnte, können Sie in der zugeordneten Klasse gefunden werden `obj` oder einer seiner Basisklassen. Dies wird in der Regel erkannt, wenn Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code anstelle einer zur Laufzeit konvertiert werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn Obj null ist.  
  
 <xref:System.Security.SecurityException> wird ausgelöst, wenn die Sicherheit des Systems den Aufrufer Zugriff an die aufgerufene Methode nicht gewährt. Die sicherheitsüberprüfung kann auftreten, wenn die CIL in systemeigenen Code nicht zur Laufzeit konvertiert wird.  
  
> [!NOTE]
>  Beim Aufrufen von Methoden, die "System.Object" für Werttypen, erwägen Sie die Verwendung der `constrained` mit dem Präfix die `callvirt` Anweisung. Dies besteht keine Notwendigkeit zum Ausgeben von anderen Integritätsstufe abhängig davon, ob der Typ die Methode überschreibt, die ein potenzielles Problem der versionsverwaltung vermeiden. Erwägen Sie die Verwendung der `constrained` Präfix beim Aufrufen von Methoden für Werttypen, da der Value-Type-Methode implementiert die Schnittstellenmethode kann geändert werden, mithilfe einer `MethodImpl`. Diese Probleme werden ausführlicher beschrieben. die <xref:System.Reflection.Emit.OpCodes.Constrained> Opcode.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `callvirt` Opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode, MethodInfo, Type  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wandelt ein als Verweis übergebenes Objekt in die angegebene Klasse um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|Wandelt ein Objekt in ein neues Objekt des Typs `class`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Es ist ein Objektverweis auf dem Stapel abgelegt.  
  
2.  Der Objektverweis wird vom Stapel geholt. Das referenzierte Objekt umgewandelt wird wie die angegebene `class`.  
  
3.  Bei erfolgreicher Ausführung wird ein neuen Objektverweis auf dem Stapel abgelegt.  
  
 Die `castclass` -Anweisung wird den Objektverweis umgewandelt (Typ `O`) auf dem Stapel zu einer angegebenen Klasse. Die neue Klasse, die durch ein Metadatentoken, das angibt, der gewünschten Klasse angegeben ist. Wenn die Klasse des Objekts oben im Stapel nicht die neue Klasse implementiert (vorausgesetzt, die neue Klasse ist eine Schnittstelle) und keine abgeleitete Klasse von der neuen Klasse wird eine <xref:System.InvalidCastException> ausgelöst. Wenn der Objektverweis auf einen null-Verweis ist `castclass` erfolgreich ist, und gibt das neue Objekt als null-Verweis zurück.  
  
 <xref:System.InvalidCastException> wird ausgelöst, wenn Obj Klasse umgewandelt werden kann.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn eine Anweisung für die Microsoft Intermediate Language (MSIL) in systemeigenen Code statt zur Laufzeit konvertiert wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `castclass` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht zwei Werte. Wenn sie gleich sind, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 01|ceq|1 überträgt, wenn `value1` gleich `value2`ist, andernfalls 0 überträgt.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `value1` im Vergleich zu `value2`.  
  
4.  Wenn `value1` gleich `value2`, 1 auf dem Stapel abgelegt wird; andernfalls wird 0 auf dem Stapel abgelegt.  
  
 Die `ceq` Anweisung vergleicht `value1` und `value2`. Wenn `value1` gleich `value2`, dann 1 (des Typs `int32`) auf dem Stapel abgelegt wird. Andernfalls 0 (des Typs `int32`) auf dem Stapel abgelegt wird.  
  
 Bei Gleitkommazahlen `ceq` gibt 0 zurück, wenn die Zahlen nicht sortiert sind (eine oder beide sind NaN). Die Werte unendlich sind gleich auf sich selbst.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ceq` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht zwei Werte. Wenn der erste Wert größer als der zweite Wert ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 02|cgt|1 überträgt, wenn `value1` ist größer als `value2`ist, andernfalls 0 überträgt.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `cgt` testet, ob `value1` ist größer als `value2`.  
  
4.  Wenn `value1` ist größer als `value2`, 1 auf dem Stapel abgelegt wird; andernfalls wird 0 auf dem Stapel abgelegt.  
  
 Die `cgt` Anweisung vergleicht `value1` und `value2`. Wenn `value1` ist größer als `value2`, und klicken Sie dann eine `int32` Wert 1 auf dem Stapel abgelegt wird. Andernfalls ein `int32` ist der Wert 0 auf dem Stapel abgelegt.  
  
-   Für Gleitkommazahlen `cgt` gibt 0 zurück, wenn die Zahlen nicht sortiert sind (d.h., wenn ein oder beide Argumente NaN sind).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `cgt` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht zwei Werte ohne Vorzeichen oder zwei ungeordnete Werte. Wenn der erste Wert größer als der zweite Wert ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|1 überträgt, wenn `value1` ist größer als `value2`ist, andernfalls 0 (Werte ohne Vorzeichen) überträgt.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `cgt.un` testet, ob `value1` ist größer als `value2`.  
  
4.  Wenn `value1` ist größer als `value2`, 1 auf dem Stapel abgelegt wird; andernfalls wird 0 auf dem Stapel abgelegt.  
  
 Ein `int32` Wert 1 wird auf dem Stapel abgelegt, wenn eine der folgenden `true` :  
  
 Für Gleitkommazahlen `value1` ist nicht in Bezug auf geordnet `value2`.  
  
 Bei Ganzzahlwerten gibt `value1` ist größer als `value2` Wenn Sie als Zahlen ohne Vorzeichen interpretiert.  
  
 Andernfalls ein `int32` ist der Wert 0 auf dem Stapel abgelegt.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `cgt.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst <see cref="T:System.ArithmeticException" /> aus, wenn der Wert keine endliche Zahl ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|C3|ckfinite|löst <xref:System.ArithmeticException> Wenn der Wert keine endliche Zahl ist.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` ist auf dem Stapel abgelegt...  
  
2.  `value` wird das Element vom Stapel geholt und `ckfinite` Anweisung wird für diese ausgeführt.  
  
3.  `value` wird zurück auf dem Stapel abgelegt werden, wenn keine Ausnahme ausgelöst wird.  
  
 Die `ckfinite instruction` löst <xref:System.ArithmeticException> Wenn `value` (Gleitkommazahl) ist entweder ein "not a Number", Wert (NaN) oder ein `+-` Infinity-Wert. `Ckfinite` jedes Mal, wenn keine Ausnahme ausgelöst wird, lässt der Wert im Stapel. Ausführung ist nicht festgelegt, wenn `value` keine Gleitkommazahl ist.  
  
 <xref:System.ArithmeticException> wird ausgelöst, wenn `value` ist keine Zahl 'normale'.  
  
 Beachten Sie, dass eine spezielle Ausnahme oder eine abgeleitete Klasse von <xref:System.ArithmeticException> möglicherweise besser geeignet, den falschen Wert an den Ausnahmehandler übergeben.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ckfinite` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht zwei Werte. Wenn der erste Wert kleiner als der zweite Wert ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 04|clt|1 überträgt, wenn `value1` ist kleiner als `value2`ist, andernfalls 0 überträgt.|  
  
 Im Stapel-laufen in sequenzieller Reihenfolge ist: `value1` wird auf dem Stapel abgelegt.  
  
1.  `value2` wird auf dem Stapel abgelegt.  
  
2.  `value2` und `value1` werden aus den Stapel geholt `clt` testet, ob `value1` ist kleiner als `value2`.  
  
3.  Wenn `value1` ist kleiner als `value2`, 1 auf dem Stapel abgelegt wird; andernfalls wird 0 auf dem Stapel abgelegt.  
  
 Die `clt` Anweisung vergleicht `value1` und `value2`. Wenn `value1` ist kleiner als `value2`, und klicken Sie dann eine `int32` Wert 1 auf dem Stapel abgelegt wird. Andernfalls ein `int32` ist der Wert 0 auf dem Stapel abgelegt.  
  
-   Für Gleitkommazahlen `clt` gibt 0 zurück, wenn die Zahlen nicht sortiert sind (d.h., wenn ein oder beide Argumente NaN sind).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `clt` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht die Werte ohne Vorzeichen oder die ungeordneten Werte <paramref name="value1" /> und <paramref name="value2" />. Wenn <paramref name="value1" /> kleiner als <paramref name="value2" /> ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 05|clt.un|1 überträgt, wenn `value1` ist kleiner als `value2`ist, andernfalls 0 (Werte ohne Vorzeichen) überträgt.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `clt.un` testet, ob `value1` ist kleiner als `value2`.  
  
4.  Wenn `value1` ist kleiner als `value2`, 1 auf dem Stapel abgelegt wird; andernfalls wird 0 auf dem Stapel abgelegt.  
  
 Die `clt.un` Anweisung vergleicht `value1` und `value2`. Ein `int32` Wert 1 wird auf dem Stapel abgelegt, wenn eine der folgenden Aussagen zutrifft:  
  
-   `value1` ist kleiner als `value2` (wie bei `clt`).  
  
-   Für Gleitkommazahlen `value1` ist nicht in Bezug auf geordnet `value2`.  
  
-   Bei Ganzzahlwerten gibt `value1` ist kleiner als `value2` Wenn Sie als Zahlen ohne Vorzeichen interpretiert.  
  
 Andernfalls ein `int32` ist der Wert 0 auf dem Stapel abgelegt.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `clt.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Schränkt den Typ ein, für den eine virtuelle Methode aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und Microsoft intermediate Language (MSIL) Assembly-Format, sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 16 < `T` >|eingeschränkt. `thisType`|Aufruf eine virtuelle Methode für einen Typ eingeschränkten Typ `T`.|  
  
 Die `constrained` Präfix ist nur zulässig, einen `callvirt` Anweisung.  
  
 Der Status des MSIL-Stapels an diesem Punkt muss wie folgt lauten:  
  
1.  Ein verwalteter Zeiger, `ptr`, auf dem Stapel abgelegt wird. Der Typ des `ptr` muss ein verwalteter Zeiger sein (`&`) zu `thisType`. Beachten Sie, dass dies der Fall, der einem schmalzeichenliteral ohne Präfix unterscheidet `callvirt` -Anweisung, die einen Verweis erwartet `thisType`.  
  
2.  Methodenargumente `arg1` über `argN` werden auf den Stapel abgelegt, genau wie bei einem schmalzeichenliteral ohne Präfix `callvirt` Anweisung.  
  
 Die `constrained` Präfix soll es ermöglicht `callvirt` Anweisungen, um eine einheitliche Weise unabhängig davon, ob erfolgen `thisType` ist ein Werttyp oder ein Verweistyp.  
  
 Wenn eine `callvirt` `method` Anweisung vorangestellt `constrained` `thisType`, die Anweisung wird wie folgt ausgeführt:  
  
-   Wenn `thisType` ist ein Verweistyp (im Gegensatz zu einem Werttyp) `ptr` dereferenziert und übergeben Sie als der "this"-Zeiger an die `callvirt` von `method`.  
  
-   Wenn `thisType` ist ein Werttyp und `thisType` implementiert `method` dann `ptr` unverändert als das "this"-Zeiger zu übergeben eine `call` `method` -Anweisung, für die Implementierung von `method` von `thisType`.  
  
-   Wenn `thisType` ist ein Werttyp und `thisType` implementiert nicht `method` dann `ptr` dereferenziert, geschachtelt und als das "this"-Zeiger zu übergeben, die `callvirt` `method` Anweisung.  
  
 Dieser letzte Fall tritt nur dann, wenn `method` definiert wurde <xref:System.Object>, <xref:System.ValueType>, oder <xref:System.Enum> und nicht überschrieben werden, indem `thisType`. In diesem Fall führt das Boxing eine Kopie des ursprünglichen Objekts vorgenommen werden. Aber da keine der Methoden der <xref:System.Object>, <xref:System.ValueType>, und <xref:System.Enum> ändern den Zustand des Objekts, die diese Tatsache nicht erkannt werden.  
  
 Die `constrained` Präfix unterstützt IL-Generatoren, generischen Code zu erstellen. Normalerweise die `callvirt` Anweisung gilt nicht für Werttypen. Stattdessen ist es erforderlich, dass die IL-Compiler die "this" Transformation, die zum Zeitpunkt der Kompilierung, je nach Art des oben beschriebenen umfassend `ptr` und die-Methode aufgerufen wird. Aber wenn `ptr` ist ein generischer Typ, der zum Zeitpunkt der Kompilierung unbekannt ist es ist nicht möglich, um diese Transformation zum Zeitpunkt der Kompilierung zu machen.  
  
 Die `constrained` Opcode bietet IL-Compilern einen Aufruf einer virtuellen Funktion in eine einheitliche Weise unabhängig davon, ob `ptr` ist ein Werttyp oder ein Verweistyp. Obwohl es für den Fall vorgesehen ist, in denen `thisType` wird eine Variablen des generischen Typs, der `constrained` Präfix auch funktioniert für nicht generische Typen und können vereinfachen Sie die zum Generieren von virtuelle Aufrufe in Sprachen, die der Unterschied zwischen Werttypen und Verweistypen.  
  
 Mithilfe der `constrained` Präfix können auch Versionskonflikte mit Werttypen vermeiden. Wenn die `constrained` Präfix nicht verwendet wird, je nachdem, ob ein Wert eine Methode von System.Object überschreibt andere IL ausgegeben werden muss. Wenn ein Werttyp z. B. `V` überschreibt die Object.ToString()-Methode eine `call` `V.ToString()` Anweisung wird ausgegeben, wenn nicht, eine `box` Anweisung und eine `callvirt` `Object.ToString()` Anweisung ausgegeben werden. Ein Problem für die versionsverwaltung kann im ersten Fall, wenn die Überschreibung später entfernt wird, und klicken Sie im zweiten Fall auftreten, wenn eine Überschreibung später hinzugefügt wird.  
  
 Die `constrained` Präfix kann auch für das Aufrufen von Methoden für Werttypen verwendet werden, da die Value-Type-Methode implementiert die Schnittstellenmethode geändert werden kann, mithilfe einer `MethodImpl`. Wenn die `constrained` Präfix wird nicht verwendet, wird der Compiler gezwungen, des Werts der Methoden zum Binden an zum Zeitpunkt der Kompilierung des Typs auswählen. Mithilfe der `constrained` Präfix ermöglicht die MSIL für die Methode zu binden, die Schnittstellenmethode zur Laufzeit anstatt zur Kompilierzeit implementiert.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `constrained` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D3|conv.i|Konvertieren in `native int`, Ablegevorgänge `native int` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.i` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf auftritt, ist die Konvertierung von eines Gleitkommatyps in eine ganze Zahl, die den Rückgabewert nicht angegeben.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.i` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int8" /> und erweitert ihn dann zu <see langword="int32" /> (durch Auffüllen).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|67|i1|Konvertieren in `int8`, Ablegevorgänge `int32` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.i1` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf auftritt, ist die Konvertierung von eines Gleitkommatyps in eine ganze Zahl, die den Rückgabewert nicht angegeben.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.i1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int16" /> und erweitert ihn dann zu <see langword="int32" /> (durch Auffüllen).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|68|i2|Konvertieren in `int16`, Ablegevorgänge `int32` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.i2` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf auftritt, ist die Konvertierung von eines Gleitkommatyps in eine ganze Zahl, die den Rückgabewert nicht angegeben.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.i2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|69|i4|Konvertieren in `int32`, Ablegevorgänge `int32` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.i4` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf auftritt, ist die Konvertierung von eines Gleitkommatyps in eine ganze Zahl, die den Rückgabewert nicht angegeben.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.i4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|6A|i8|Konvertieren in `int64`, Ablegevorgänge `int64` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.i8` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf auftritt, ist die Konvertierung von eines Gleitkommatyps in eine ganze Zahl, die den Rückgabewert nicht angegeben.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.i8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="native int" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|Konvertieren in ein `native int` (auf dem Stapel als `native int`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.i` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="native int" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|Konvertiert einen Wert ohne Vorzeichen zu einem `native int` (auf dem Stapel als `native int`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i.un` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.i.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int8" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|Konvertieren in ein `int8` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i1` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.i1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int8" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|Konvertiert einen Wert ohne Vorzeichen zu einem `int8` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i1.un` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.i1.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int16" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B5|conv.ovf. i2|Konvertieren in ein `int16` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i2` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.i2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int16" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|Konvertiert einen Wert ohne Vorzeichen zu einem `int16` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i2.un` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.i2.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int32" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B7|conv.ovf. i4|Konvertieren in ein `int32` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i4` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.i4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int32" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|Konvertiert einen Wert ohne Vorzeichen zu einem `int32` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i4.un` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.i4.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int64" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B9|i8|Konvertieren in ein `int64` (auf dem Stapel als `int64`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i8` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.i8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int64" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|Konvertiert einen Wert ohne Vorzeichen zu einem `int64` (auf dem Stapel als `int64`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i8.un` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.i8.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned native int" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|Konvertieren in ein `unsigned native int` (auf dem Stapel als `native int`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.u` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned native int" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|8 B|conv.ovf.u.un|Konvertiert Wert ohne Vorzeichen in eine `unsigned native int` (auf dem Stapel als `native int`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u.un` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.uvf.u.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int8" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B4|conv.ovf. U1|Konvertieren in ein `unsigned int8` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u1` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.u1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int8" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|Konvertiert einen Wert ohne Vorzeichen zu einem `unsigned int8` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u1.un` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.u1.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int16" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B6|conv.ovf. u2|Konvertieren in ein `unsigned int16` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u2` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.u2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int16" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|Konvertiert einen Wert ohne Vorzeichen zu einem `unsigned int16` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u2.un` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.u2.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int32" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B8|U4|Konvertieren in ein `unsigned int32` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u4` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.u4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int32" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|Konvertiert einen Wert ohne Vorzeichen zu einem `unsigned int32` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u4.un` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.u4.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int64" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|BA|U8|Konvertieren in ein `unsigned int64` (auf dem Stapel als `int64`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u8` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.u8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int64" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|Konvertiert einen Wert ohne Vorzeichen zu einem `unsigned int64` (auf dem Stapel als `int64`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u8.un` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und setzt konvertierten Wert oben im Stapel angegeben. Wenn der Wert zu groß oder zu klein, um durch den Typ des dargestellt ist, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, wird in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.ovf.u8.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Ganzzahlwert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|76|conv.r.un|Convert-Ganzzahl ohne Vorzeichen in Gleitkommazahlen mithilfe von Push übertragen `F` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.r.un` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf tritt auf, Konvertieren von einem Gleitkommatyp in eine ganze Zahl die `result` zurückgegeben, ist nicht angegeben. Die `conv.r.un` Vorgang eine Ganzzahl vom Stapel akzeptiert, wird als ohne Vorzeichen interpretiert und ersetzt diese durch eine Gleitkommazahl, die ganze Zahl darstellt: entweder ein `float32`, wenn es sich um breit genug ist, um die ganze Zahl ohne Genauigkeitsverlust darstellen, oder andernfalls handelt eine `float64`.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.r.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|6B|R4|Konvertieren in `float32`, Ablegevorgänge `F` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.r4` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf auftritt, ist die Konvertierung von eines Gleitkommatyps in eine ganze Zahl, die den Rückgabewert nicht angegeben.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.r4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|6C|conv. r8|Konvertieren in `float64`, Ablegevorgänge `F` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.r8` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf auftritt, ist die Konvertierung von eines Gleitkommatyps in eine ganze Zahl, die den Rückgabewert nicht angegeben.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.r8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned native int" /> und erweitert ihn dann zu <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|E0|conv.u|Konvertieren in `unsigned native int`, Ablegevorgänge `native int` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.u` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf auftritt, ist die Konvertierung von eines Gleitkommatyps in eine ganze Zahl, die den Rückgabewert nicht angegeben.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.u` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int8" /> und erweitert ihn dann zu <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D2|conv. U1|Konvertieren in `int8`, Ablegevorgänge `int32` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.u1` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf auftritt, ist die Konvertierung von eines Gleitkommatyps in eine ganze Zahl, die den Rückgabewert nicht angegeben.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.u1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int16" /> und erweitert ihn dann zu <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D1|conv. u2|Konvertieren in `int16`, Ablegevorgänge `int32` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.u2` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf auftritt, ist die Konvertierung von eines Gleitkommatyps in eine ganze Zahl, die den Rückgabewert nicht angegeben.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.u2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int32" /> und erweitert ihn dann zu <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|6D|U4|Konvertieren in `unsigned int32`, Ablegevorgänge `int32` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.u4` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf auftritt, ist die Konvertierung von eines Gleitkommatyps in eine ganze Zahl, die den Rückgabewert nicht angegeben.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.u4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int64" /> und erweitert ihn dann zu <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|6E|U8|Konvertieren in `int64`, Ablegevorgänge `int64` auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.u8` Opcode konvertiert die `value` oberster Position des Stapels in den Typ in den Opcode, und lässt konvertierten Wert oben im Stapel angegeben. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden auf dem Auswertungsstapel ab (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). Gleitkommawerte werden konvertiert, um die `F` Typ.  
  
 Konvertierung von Gleitkommazahlen in ganzzahlige Werte werden die Zahlen in Richtung Null abgeschnitten. Bei der Konvertierung von einer `float64` auf eine `float32`, Genauigkeit unterbrochen werden kann. Wenn `value` ist zu groß für eine `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich (Wenn `value` ist ein negativer Wert) wird zurückgegeben. Wenn Überlauf Konvertieren einer Ganzzahl-Typ in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist, geben Sie den Slot signaturerweitert.  
  
 Wenn ein Überlauf auftritt, ist die Konvertierung von eines Gleitkommatyps in eine ganze Zahl, die den Rückgabewert nicht angegeben.  
  
 Ständig werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `conv.u8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert eine angegebene Anzahl von Bytes von einer Quelladresse an eine Zieladresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Kopieren von Daten aus einem Speicherblock zu einem anderen.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Die Zieladresse wird auf dem Stapel abgelegt.  
  
2.  Die Quelladresse wird auf dem Stapel abgelegt.  
  
3.  Die Anzahl der zu kopierenden Bytes wird auf dem Stapel abgelegt.  
  
4.  Die Anzahl der Bytes, die Quelladresse und die Zieladresse werden vom Stapel geholt. die angegebene Anzahl von Bytes, werden von der Quelladresse zur Zieladresse kopiert.  
  
 Die `cpblk` -Anweisung kopiert eine Zahl (Typ `unsigned int32`) von Bytes, die von einer Quelladresse (des Typs `*`, `native int`, oder `&`) an eine Zieladresse (des Typs `*`, `native int`, oder `&`). Das Verhalten der `cpblk` ist undefiniert, wenn die Quell- und Zielbereiche überlappen.  
  
 `cpblk` wird davon ausgegangen, dass sowohl die Quell- und Zieladresse an die Größe des Computers ausgerichtet sind. Die `cpblk` Anweisung kann unmittelbar vorangestellt werden die `unaligned.<prefix>` Anweisung, um anzugeben, dass die Quelle oder das Ziel nicht ausgerichtete ist.  
  
 Den Betrieb der `cpblk` Anweisung kann geändert werden, einen unmittelbar vorangehenden <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `cpblk` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert den Werttyp, der an der Adresse eines Objekts gespeichert ist (Typ <see langword="&amp;" />, <see langword="*" /> oder <see langword="native int" />), an die Adresse des Zielobjekts (Typ <see langword="&amp;" />, <see langword="*" /> oder <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|Geben Sie Kopien, die einen Wert von einem Quellobjekt zu einem Zielobjekt.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Zielobjektverweis wird auf dem Stapel abgelegt.  
  
2.  Der Objektverweis für die Quelle wird auf dem Stapel abgelegt.  
  
3.  Die zwei Objektverweise werden vom Stapel geholt. kopiert der Werttyp an der Adresse des Quellobjekts an die Adresse des Zielobjekts.  
  
 Das Verhalten der `cpobj` ist nicht angegeben, ob die Quelle und Ziel-Objekt Verweise sind nicht auf Instanzen der durch das Klassentoken dargestellten Klasse `classTok` (eine `typeref` oder `typedef`), oder wenn `classTok` stellt keinen dar. ein ein Werttyp.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `cpobj` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dividiert zwei Werte und legt das Ergebnis als Gleitkommawert (Typ <see langword="F" />) oder Quotient (Typ <see langword="int32" />) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|5B|div|Dividiert zwei Werte und gibt Quotient oder Gleitkommaergebnis zurück.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `value1` wird geteilt durch `value2`.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 `result` = `value1` Div value2 werden die folgenden Bedingungen erfüllt:  
  
 &#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:  
  
 Sign (`result`) = +, wenn anmelden (`value1`) = Vorzeichen (`value2`), "oder"-, wenn anmelden (`value1`) ~ = Vorzeichen (`value2`)  
  
 Die `div` Anweisung berechnet das Ergebnis und per Pushvorgang auf den Stapel.  
  
 Division ganzer Zahlen abgeschnitten in Richtung 0 (null).  
  
 Division einer begrenzten Zahl durch 0 (null), erzeugt die ordnungsgemäß signierten unendlichen Wert.  
  
 Division von 0 (null) von 0 (null) oder unendlich durch unendlich wird den Wert von NaN (Not-A-Number). Eine beliebige Anzahl geteilt durch unendlich erzeugt einen NULL-Wert.  
  
 Ganzzahloperationen lösen <xref:System.ArithmeticException> Wenn das Ergebnis im Ergebnistyp dargestellt werden kann. Dies kann passieren, wenn `value1` ist der Höchstwert von negativen und `value2` ist-1.  
  
 Ganzzahloperationen lösen <xref:System.DivideByZeroException> Wenn `value2` ist 0 (null).  
  
 Beachten Sie, dass auf Intel-basierten Plattformen eine <xref:System.OverflowException> wird ausgelöst, wenn (Minint div-1). Gleitkommaoperationen lösen niemals Ausnahmen (sie erzeugt NaN oder unendlich stattdessen) aus.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `div` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dividiert zwei Ganzzahlwerte ohne Vorzeichen und legt das Ergebnis (<see langword="int32" />) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|5C|div.un|Dividiert zwei Werte ohne Vorzeichen und gibt einen Quotienten zurück.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `value1` wird geteilt durch `value2`.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `div.un` Anweisung berechnet `value1` geteilt durch `value2`, beide als ganze Zahlen ohne Vorzeichen und Push-Vorgänge die `result` auf dem Stapel.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `div.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert den obersten Wert auf dem Auswertungsstapel und legt die Kopie dann auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|25|Dup|Den Wert des Stapels wird dupliziert.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` der Stapel für die Duplizierung per pop ausgelesen wird.  
  
3.  `value` zurück wird auf dem Stapel abgelegt.  
  
4.  Ein doppelter Wert wird auf dem Stapel abgelegt.  
  
 Die `dup` Anweisung dupliziert das oberste Element des Stapels und bewirkt, dass zwei identische Werte auf sie.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `dup` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung von der <see langword="filter" />-Klausel einer Ausnahme zurück an den CLI-Ausnahmehandler (Common Language Infrastructure).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 11|endfilter|End-Filter-Klausel der SEH-Ausnahmebehandlung.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` wird vom Stapel geholt. `endfilter` ausgeführt wird und die Steuerung an den Ausnahmehandler übergeben.  
  
 `Value` (die muss vom Typ `int32` und ist von einem bestimmten Satz von Werten) von der Filterklausel zurückgegeben wird. Es sollte möglich:  
  
-   `exception_continue_search` (`value` = 0) Suche nach einem Ausnahmehandler fortgesetzt werden  
  
-   `exception_execute_handler` (`value` = 1) starten Sie die zweite Phase der Behandlung von Ausnahmen, in dem finally-Blöcke ausgeführt werden, bis diese Filter-Klausel der Handler zugeordnete, gefunden wird. Bei der Ermittlung wird der Handler ausgeführt.  
  
 Andere ganzzahlige Werte werden führen zu undefinierten Ergebnissen.  
  
 Der Einstiegspunkt eines Filters, muss die erste Anweisung im Codeblock des Filters wie in der Methode die Ausnahmetabelle, dargestellt sein. Die `endfilter` Anweisung muss die letzte Anweisung im Codeblock des Filters (daher gibt es nur möglich `endfilter` für alle einzelnen Filter-Block). Nach dem Ausführen der `endfilter` -Anweisung, logisch ablaufsteuerung an der Befehlszeilenschnittstelle Ausnahmebehandlungsmechanismus.  
  
 Steuerelement kann nicht in einen Filterblock, mit Ausnahme von über den Ausnahmemechanismus übertragen werden. Steuerelement kann nicht übertragen werden, aus eines Filterblocks außer durch die Verwendung von einem `throw` Anweisung oder durch Ausführen den letzten `endfilter` Anweisung. Kann nicht eingebettet werden eine `try` -Block in einem `filter` Block. Wenn eine Ausnahme, in ausgelöst wird der `filter` -Block abgefangen wird und den Wert 0 (`exception_continue_search`) wird zurückgegeben.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `endfilter` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung aus der <see langword="fault" />-Klausel oder <see langword="finally" />-Klausel eines Ausnahmeblockes zurück an den CLI-Ausnahmehandler (Common Language Infrastructure).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|DOMÄNENCONTROLLER|endfinally<br /><br /> Fault|Beendet die `finally` oder `fault` -Klausel eines Ausnahmeblockes.|  
  
 Es gibt kein Stapel Übergangsverhalten für diese Anweisung.  
  
 `Endfinally` und `endfault` signalisiert das Ende der `finally` oder `fault` Klausel, sodass diese stapelentladung fortfahren kann, bis der Ausnahmehandler aufgerufen wird. Die `endfinally` oder `endfault` -Anweisung überträgt die Steuerung wieder an den CLI-Ausnahmemechanismus. Der Mechanismus und sucht nach der nächsten `finally` -Klausel in der Kette, wenn der geschützte Block mit eine verlassen-Anweisung beendet wurde. Wenn der geschützte Block mit einer Ausnahme beendet wurde, sucht die CLI für die nächsten `finally` oder `fault`, oder geben Sie den Ausnahmehandler, der während der ersten Phase der Ausnahmebehandlung ausgewählt wurde.  
  
 Ein `endfinally` Anweisung scheinen nur lexikalisch innerhalb einer `finally` Block. Im Gegensatz zu den `endfilter` -Anweisung, besteht keine Notwendigkeit, das Beenden des Blocks mit einer `endfinally` -Anweisung, und es können beliebig viele werden `endfinally` Anweisungen innerhalb des Blocks nach Bedarf. Diese gleichen Einschränkungen gelten für die `endfault` Anweisung und die `fault` Block.  
  
 Steuerelement kann nicht übertragen werden, in einem `finally` (oder `fault`)-block, außer über den Ausnahmemechanismus. Steuerelement kann nicht übertragen werden, von einer `finally` (oder `fault`)-block, außer mithilfe des eine `throw` Anweisung oder in der Ausführung der `endfinally` (oder `endfault`) Anweisung. Sie nicht "können Sie" von einer `finally` (oder `fault`) Block oder zum Ausführen einer <xref:System.Reflection.Emit.OpCodes.Ret> oder <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung innerhalb einer `finally` (oder `fault`) Block.  
  
 Beachten Sie, dass die `endfault` und `endfinally` Anweisungen sind Aliase – sie entsprechen den gleichen Opcode.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `endfinally` (`endfault`) Opcode, als auch die `ILGenerator` Methode <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Initialisiert einen angegebenen Speicherblock an einer bestimmten Adresse mit einer angegebenen Größe und einem angegebenen Anfangswert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 18|initblk|Legen Sie jeden Standort in einen Speicherblock auf einen angegebenen Wert ein.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Die Startadresse ist auf dem Stapel abgelegt.  
  
2.  Ein Initialisierungswert ist auf dem Stapel abgelegt.  
  
3.  Die Anzahl der zu initialisierenden Bytes wird auf dem Stapel abgelegt.  
  
4.  Die Anzahl der Bytes, den Initialisierungswert und die Startadresse vom Stapel geholt werden, und die Initialisierung erfolgt gemäß der jeweiligen Werte.  
  
 Die `initblk` -Anweisung legt die Anzahl (`unsigned int32`) von Bytes, beginnend ab der angegebenen Adresse (des Typs `native int`, `&`, oder `*`) auf den Initialisierungswert (des Typs `unsigned int8`). `initblk` wird davon ausgegangen, dass die Startadresse an die Größe des Computers ausgerichtet ist.  
  
 Der Vorgang von der `initblk` Anweisungen können geändert werden, ein unmittelbar vor <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `initblk` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Initialisiert alle Felder des Werttyps an einer angegebenen Adresse mit einem NULL-Verweis oder dem Wert 0 des entsprechenden primitiven Typs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 15 < `T` >|`initobj` `typeTok`|Initialisiert einen Werttyp an.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Die Adresse des Werttyps initialisiert wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Werttyp an der angegebenen Adresse wird als Typ initialisiert `typeTok`.  
  
 Die `initobj` Anweisung initialisiert alle Felder des Werttyps angegebene Adresse (des Typs `native int`, `&`, oder `*`) auf einen null-Verweis oder 0 des entsprechenden primitiven Typs. Nachdem diese Methode aufgerufen wurde, ist die Instanz kann eine Konstruktormethode aufgerufen werden. Wenn `typeTok` ein Verweistyp handelt, wird diese Anweisung hat dieselbe Wirkung wie das `ldnull` gefolgt von `stind.ref`.  
  
 Im Gegensatz zu <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` wird nicht die Konstruktormethode aufgerufen. `Initobj` wird zum Initialisieren von Werttypen vorgesehen, während er sich `newobj` dient zum Zuordnen und Initialisieren von Objekten.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `initobj` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überprüft, ob ein Objektverweis (Typ <see langword="O" />) eine Instanz einer bestimmten Klasse ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|Testet, ob ein Objektverweis auf eine Instanz ist `class`, zurückgeben, entweder einen null-Verweis oder eine Instanz dieser Klasse oder Schnittstelle.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Es ist ein Objektverweis auf dem Stapel abgelegt.  
  
2.  Der Objektverweis ist vom Stapel geholt und getestet werden, um festzustellen, ob es sich um eine Instanz der Klasse übergeben ist `class`.  
  
3.  Das Ergebnis (einen Objektverweis oder ein null-Verweis) wird auf dem Stapel abgelegt.  
  
 `Class` ist ein Metadatentoken, das die gewünschte Klasse angibt. Wenn die Klasse des Objekts oben im Stapel implementiert `class` (Wenn `class` ist eine Schnittstelle) oder eine abgeleitete Klasse von `class` (Wenn `class` eine normale Klasse ist) und sie in den Typ umgewandelt wird `class` und das Ergebnis wird auf dem Stapel abgelegt. genau als ob <xref:System.Reflection.Emit.OpCodes.Castclass> war aufgerufen wurde. Andernfalls wird ein null-Verweis auf dem Stapel abgelegt. Wenn der Objektverweis selbst ein null-Verweis dann ist `isinst` ebenso einen null-Verweis zurückgibt.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn die Microsoft Intermediate Language (MSIL)-Anweisungen nicht zur Laufzeit, sondern in systemeigenen Code konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `isinst` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beendet die aktuelle Methode und wechselt zur angegebenen Methode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|27 < `T` >|"jmp" `method`|Beendet die aktuelle Methode aus, und fahren Sie mit der angegebenen Methode.|  
  
 Es gibt kein Stapel Übergangsverhalten für diese Anweisung.  
  
 Die `jmp` (springen)-Anweisung überträgt die Steuerung an die Methode angegeben werden, `method`, d.h. ein Metadatentoken für einen Methodenverweis. Die aktuellen Argumente werden an die Zielmethode übertragen.  
  
 Auswertungsstapels muss leer sein, wenn diese Anweisung ausgeführt wird. Die Aufrufkonvention, Anzahl und Typ der Argumente an die Zieladresse müssen mit der aktuellen Methode übereinstimmen.  
  
 Die `jmp` Anweisung kann nicht verwendet werden, um das Übertragen der Steuerung aus einer `try`, `filter`, `catch`, oder `finally` Block.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `jmp` Opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt ein Argument, auf das ein angegebener Indexwert verweist, in den Stapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|Lädt das Argument am `index` Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert des Arguments an `index` wird auf dem Stapel abgelegt.  
  
 Die `ldarg` Anweisung legt das Argument am `index`, wobei die Argumente von 0 oder höher, auf dem Auswertungsstapel ab Indizierung werden. Die `ldarg` Anweisung kann verwendet werden, um das Kopieren aus einem eingehenden Argument ein Werttyp oder ein primitiver Wert im Stapel zu laden. Der Typ des Argumentwerts ist identisch mit dem Typ des Arguments, gemäß der aktuellen Methodensignatur.  
  
 Für Prozeduren, die eine Argumentliste variabler Länge, kann die `ldarg` Anweisung kann nur auf die festen Argumente, nicht auf die in der Variable Teil der Signatur verwendet werden (finden Sie unter den <xref:System.Reflection.Emit.OpCodes.Arglist> Anleitungen für die weitere Details).  
  
 Argumente, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang Typ erweitert `int32` werden beim Laden auf den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldarg` Opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument am Index 0 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|02|ldarg.0|Lädt das Argument 0 Stapel|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert des Arguments am Index 0 wird auf dem Stapel abgelegt.  
  
 Die `ldarg.0` Anweisung ist eine effiziente Codierung für das Laden des Argumentwerts am Index 0.  
  
 Die `ldarg.0` -Anweisung legt das Argument mit dem Index 0 auf dem Auswertungsstapel ab. Die `ldarg.0` Anweisung kann verwendet werden, um das Kopieren aus einem eingehenden Argument ein Werttyp oder ein primitiver Wert im Stapel zu laden. Der Typ des Argumentwerts ist identisch mit dem Typ des Arguments, gemäß der aktuellen Methodensignatur.  
  
 Argumente, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang Typ erweitert `int32` werden beim Laden auf den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldarg.0` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument am Index 1 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|03|ldarg. 1|Laden Sie das Argument 1 Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert des Arguments am Index 1 wird auf dem Stapel abgelegt.  
  
 Die `ldarg.1` Anweisung ist eine effiziente Codierung für das Laden des Argumentwerts am Index 1.  
  
 Die `ldarg.1` -Anweisung legt das Argument mit dem Index 1 auf dem Auswertungsstapel ab. Die `ldarg.1` Anweisung kann verwendet werden, um das Kopieren aus einem eingehenden Argument ein Werttyp oder ein primitiver Wert im Stapel zu laden. Der Typ des Argumentwerts ist identisch mit dem Typ des Arguments, gemäß der aktuellen Methodensignatur.  
  
 Argumente, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang Typ erweitert `int32` werden beim Laden auf den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldarg.1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument am Index 2 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|04|ldarg. 2|Laden Sie Argument 2 in den Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert des Arguments am Index 2 ist auf dem Stapel abgelegt.  
  
 Die `ldarg.2` Anweisung ist eine effiziente Codierung für das Laden des Argumentwerts am Index 2.  
  
 Die `ldarg.2` Anweisung legt das Argument auf 2 auf dem Auswertungsstapel ab. Die `ldarg.2` Anweisung kann verwendet werden, um das Kopieren aus einem eingehenden Argument ein Werttyp oder ein primitiver Wert im Stapel zu laden. Der Typ des Argumentwerts ist identisch mit dem Typ des Arguments, gemäß der aktuellen Methodensignatur.  
  
 Argumente, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang Typ erweitert `int32` werden beim Laden auf den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldarg.2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument am Index 3 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|05|ldarg. 3|Lädt das Argument 3 Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert des Arguments am Index 3 wird auf dem Stapel abgelegt.  
  
 Die `ldarg.3` Anweisung ist eine effiziente Codierung für das Laden des Argumentwerts am Index 3.  
  
 Die `ldarg.3` -Anweisung legt das Argument mit dem Index 3 auf dem Auswertungsstapel ab. Die `ldarg.3` Anweisung kann verwendet werden, um das Kopieren aus einem eingehenden Argument ein Werttyp oder ein primitiver Wert im Stapel zu laden. Der Typ des Argumentwerts ist identisch mit dem Typ des Arguments, gemäß der aktuellen Methodensignatur.  
  
 Argumente, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang Typ erweitert `int32` werden beim Laden auf den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldarg.3` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument, auf das ein angegebener Kurzformindex verweist, in den Stapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg.s `index`|Lädt das Argument am `index` in den Stapel, Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert des Arguments an `index` wird auf dem Stapel abgelegt.  
  
 Die `ldarg.s` -Anweisung ist eine effiziente Codierung für das Laden der Argumente, die aus 4 bis 255 indiziert.  
  
 Die `ldarg.s` Anweisung legt das Argument am `index`, wobei die Argumente von 0 oder höher, auf dem Auswertungsstapel ab Indizierung werden. Die `ldarg.s` Anweisung kann verwendet werden, um das Kopieren aus einem eingehenden Argument ein Werttyp oder ein primitiver Wert im Stapel zu laden. Der Typ des Argumentwerts ist identisch mit dem Typ des Arguments, gemäß der aktuellen Methodensignatur.  
  
 Für Prozeduren, die eine Argumentliste variabler Länge, kann die `ldarg.s` Anweisung kann nur auf die festen Argumente, nicht auf die in der Variable Teil der Signatur verwendet werden (finden Sie unter den <xref:System.Reflection.Emit.OpCodes.Arglist> Anleitungen für die weitere Details).  
  
 Argumente, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang Typ erweitert `int32` werden beim Laden auf den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldarg.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt eine Argumentadresse in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga `index`|Ruft die Adresse des Arguments ab, das von `index`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Die Adresse `addr` des Arguments ab, indem `index` wird auf dem Stapel abgelegt.  
  
 Die `ldarga` -Anweisung ruft die Adresse (des Typs `*`) des Arguments ab, indem `index`, wobei die Argumente von 0 oder höher Indizierung. Die Adresse `addr` immer auf dem Zielcomputer eine natürliche Grenze ausgerichtet ist.  
  
 Für Prozeduren, die eine Argumentliste variabler Länge, kann die `ldarga` Anweisung kann nur auf die festen Argumente, nicht auf die in der Variable Teil der Signatur verwendet werden.  
  
 `ldarga` wird für durch Verweis übergeben von Parametern verwendet. In anderen Fällen <xref:System.Reflection.Emit.OpCodes.Ldarg> und <xref:System.Reflection.Emit.OpCodes.Starg> verwendet werden soll.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldarga` Opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt eine Argumentadresse in Kurzform in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|0F &LT; `unsigned int8` >|ldarga.s `index`|Ruft die Adresse des Arguments ab, das von `index`, Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Die Adresse `addr` des Arguments ab, indem `index` wird auf dem Stapel abgelegt.  
  
 `ldarga.s` (die Kurzform der `ldarga`) sollte verwendet werden, für die Argumente von 0 bis 255 und ist ein effizienter Codierung.  
  
 Die `ldarga.s` -Anweisung ruft die Adresse (des Typs`*`) des Arguments ab, indem `index`, wobei die Argumente von 0 oder höher Indizierung. Die Adresse `addr` immer auf dem Zielcomputer eine natürliche Grenze ausgerichtet ist.  
  
 Für Prozeduren, die eine Argumentliste variabler Länge, kann die `ldarga.s` Anweisung kann nur auf die festen Argumente, nicht auf die in der Variable Teil der Signatur verwendet werden.  
  
 `ldarga.s` wird für durch Verweis übergeben von Parametern verwendet. In anderen Fällen <xref:System.Reflection.Emit.OpCodes.Ldarg_S> und <xref:System.Reflection.Emit.OpCodes.Starg_S> verwendet werden soll.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldarga.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen bereitgestellten Wert vom Typ <see langword="int32" /> als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc. i4 `num`|Legt den Wert `num` im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert `num` wird auf dem Stapel abgelegt.  
  
 Beachten Sie, dass besondere Codierungen mit kurze (und daher eine effizientere) für die ganzen Zahlen-128 bis 127, und besonders kurze Codierungen für – 1 bis 8. Alle kurze Codierungen werden 4 Bytes langen ganzen Zahlen auf dem Stapel übertragen. Längere Codierungen werden verwendet, für die 8-Byte-Ganzzahlen, 4 und 8 Byte-Gleitkommazahlen, sowie 4-Byte-Werte, die nicht in die Kurzformen passen. Es gibt drei Möglichkeiten, eine 8-Byte-Ganzzahlkonstante im Stapel mithilfe von Push übertragen  
  
 1. Verwenden der <xref:System.Reflection.Emit.OpCodes.Ldc_I8> Anleitungen für die Konstanten, die mehr als 32 Bits ausgedrückt werden müssen.  
  
 2. Verwenden der <xref:System.Reflection.Emit.OpCodes.Ldc_I4> Anweisung, gefolgt von einem <xref:System.Reflection.Emit.OpCodes.Conv_I8> für Konstanten, die von 9 bis 32 Bits erforderlich sind.  
  
 3. Verwenden Sie eine Kurzform-Anweisung, gefolgt von einem <xref:System.Reflection.Emit.OpCodes.Conv_I8> für Konstanten, die in 8 oder weniger Bit ausgedrückt werden können.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i4` Opcode:  
  
-   ILGenerator.Emit (OpCode, Int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 0 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|Überträgt 0 auf den Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert 0 wird auf dem Stapel abgelegt.  
  
 Dies ist eine spezielle kurze Codierung für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen werden 4 Bytes langen ganzen Zahlen auf dem Stapel übertragen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i4.0` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 1 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|Legt die 1 auf den Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert 1 wird auf dem Stapel abgelegt.  
  
 Dies ist eine spezielle kurze Codierung für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen werden 4 Bytes langen ganzen Zahlen auf dem Stapel übertragen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i4.1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 2 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|Legt die 2 in den Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert 2 ist auf dem Stapel abgelegt.  
  
 Dies ist eine spezielle kurze Codierung für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen werden 4 Bytes langen ganzen Zahlen auf dem Stapel übertragen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i4.2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 3 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|Legt die 3 auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert 3 wird auf dem Stapel abgelegt.  
  
 Dies ist eine spezielle kurze Codierung für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen werden 4 Bytes langen ganzen Zahlen auf dem Stapel übertragen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i4.3` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 4 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|Legt die 4 im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert 4 ist auf dem Stapel abgelegt.  
  
 Dies ist eine spezielle kurze Codierung für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen werden 4 Bytes langen ganzen Zahlen auf dem Stapel übertragen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i4.4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 5 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|Legt die 5 im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert 5 ist auf dem Stapel abgelegt.  
  
 Dies ist eine spezielle kurze Codierung für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen werden 4 Bytes langen ganzen Zahlen auf dem Stapel übertragen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i4.5` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 6 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|Legt die 6 auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert 6 wird auf dem Stapel abgelegt.  
  
 Dies ist eine spezielle kurze Codierung für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen werden 4 Bytes langen ganzen Zahlen auf dem Stapel übertragen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i4.6` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 7 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|Legt die 7 auf den Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert 7 wird auf dem Stapel abgelegt.  
  
 Dies ist eine spezielle kurze Codierung für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen werden 4 Bytes langen ganzen Zahlen auf dem Stapel übertragen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i4.7` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 8 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|Überträgt 8 auf den Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert 8 ist auf dem Stapel abgelegt.  
  
 Dies ist eine spezielle kurze Codierung für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen werden 4 Bytes langen ganzen Zahlen auf dem Stapel übertragen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i4.8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert -1 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|Legt-1 auf dem Stapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert-1 wird auf dem Stapel abgelegt.  
  
 Dies ist eine spezielle kurze Codierung für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen werden 4 Bytes langen ganzen Zahlen auf dem Stapel übertragen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i4.m1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den bereitgestellten <see langword="int8" />-Wert als <see langword="int32" />, Kurzform, auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|1F &LT; `int8` >|ldc.i4.s `num`|Überträgt `num` als in den Stapel `int32`, Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert `num` wird auf dem Stapel abgelegt.  
  
 `ldc.i4.s` ist ein effizienter Codierung für die ganzen Zahlen von-128 bis 127 zu übertragen, auf dem Auswertungsstapel ab.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i4.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen bereitgestellten Wert vom Typ <see langword="int64" /> als <see langword="int64" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc. i8 `num`|Überträgt `num` als in den Stapel `int64`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert `num` wird auf dem Stapel abgelegt.  
  
 Diese Codierung legt eine `int64` in den Stapel.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.i8` Opcode:  
  
-   ILGenerator.Emit (OpCode, long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen bereitgestellten Wert vom Typ <see langword="float32" /> als Typ <see langword="F" /> (Gleitkommawert) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc. r4 `num`|Überträgt `num` als in den Stapel `F`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert `num` wird auf dem Stapel abgelegt.  
  
 Diese Codierung legt eine `float32` in den Stapel.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.r4` Opcode:  
  
-   ILGenerator.Emit(OpCode, single)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen bereitgestellten Wert vom Typ <see langword="float64" /> als Typ <see langword="F" /> (Gleitkommawert) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|23 < `float64` >|r8 `num`|Überträgt `num` als in den Stapel `F`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert `num` wird auf dem Stapel abgelegt.  
  
 Diese Codierung legt eine `float64` in den Stapel.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldc.r8` Opcode:  
  
-   ILGenerator.Emit (OpCode, double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element an einem angegebenen Arrayindex als der in der Anweisung angegebene Typ auf die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und Microsoft intermediate Language (MSIL) Assembly-Format, sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|Lädt das Element an `index` an die oberste Position des Stapels als Typ `typeTok`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` werden aus dem Stapel per POP entfernt den Wert an Position abgelegt `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem` Anweisung lädt den Wert der Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Typ des Rückgabewerts wird angegeben, durch das Token `typeTok` in der Anweisung.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die obere Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelem` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="native int" /> an einem angegebenen Arrayindex als <see langword="native int" /> auf die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|97|ldelem.i|Lädt das Element mit dem Typ `native int` am `index` an die oberste Position des Stapels als eine `native int`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` werden aus dem Stapel per POP entfernt den Wert an Position abgelegt `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.i` Anweisung lädt den Wert der Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.i` ist `native int`.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelem.i` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="int8" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|90|i1|Lädt das Element mit dem Typ `int8` am `index` an die oberste Position des Stapels als ein `int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` werden aus dem Stapel per POP entfernt den Wert an Position abgelegt `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.i1` Anweisung lädt den Wert der Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.i1` ist `int8`.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelem.i1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="int16" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|92|i2|Lädt das Element mit dem Typ `int16` am `index` an die oberste Position des Stapels als ein `int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` werden aus dem Stapel per POP entfernt den Wert an Position abgelegt `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.i2` Anweisung lädt den Wert der Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.i2` ist `int16`.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelem.i2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="int32" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|94|i4|Lädt das Element mit dem Typ `int32` am `index` an die oberste Position des Stapels als ein `int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` werden aus dem Stapel per POP entfernt den Wert an Position abgelegt `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.i4` Anweisung lädt den Wert der Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.i4` ist `int32`.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelem.i4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="int64" /> an einem angegebenen Arrayindex als <see langword="int64" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|96|i8|Lädt das Element mit dem Typ `int64` am `index` an die oberste Position des Stapels als ein `int64`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` werden aus dem Stapel per POP entfernt den Wert an Position abgelegt `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.i8` Anweisung lädt den Wert der Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.i8` ist `int64`.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelem.i8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element vom Typ <see langword="float32" /> an einem angegebenen Arrayindex als Typ <see langword="F" /> (Gleitkommawert) an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|98|R4|Lädt das Element mit dem Typ `float32` am `index` an die oberste Position des Stapels als Typ `F`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` werden aus dem Stapel per POP entfernt den Wert an Position abgelegt `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.r4` Anweisung lädt den Wert der Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.r4` ist `float32`.  
  
 Gleitkommazahlen-Punktwerte sind in den Typ konvertiert `F` beim Laden auf dem Auswertungsstapel ab.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelem.r4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element vom Typ <see langword="float64" /> an einem angegebenen Arrayindex als Typ <see langword="F" /> (Gleitkommawert) an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|99|r8|Lädt das Element mit dem Typ `float64` am `index` an die oberste Position des Stapels als Typ `F`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` werden aus dem Stapel per POP entfernt den Wert an Position abgelegt `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.r8` Anweisung lädt den Wert der Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.r8` ist `float64`.  
  
 Gleitkommazahlen-Punktwerte sind in den Typ konvertiert `F` beim Laden auf dem Auswertungsstapel ab.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelem.r8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit Objektverweis an einem angegebenen Arrayindex als Typ <see langword="O" /> (Objektverweis) an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|Lädt das Element mit Objektverweis an `index` an die oberste Position des Stapels als Typ `O`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` werden aus dem Stapel per POP entfernt den Wert an Position abgelegt `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.ref` Anweisung lädt den Wert der Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.ref` Typ `O` (Objektverweis).  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelem.ref` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="unsigned int8" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|91|ldelem. U1|Lädt das Element mit dem Typ `unsigned int8` am `index` an die oberste Position des Stapels als ein `int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` werden aus dem Stapel per POP entfernt den Wert an Position abgelegt `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.u1` Anweisung lädt den Wert der Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.u1` ist `int8`.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelem.u1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="unsigned int16" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|93|U2|Lädt das Element mit dem Typ `unsigned int16` am Index, an die oberste Position des Stapels als ein `int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` werden aus dem Stapel per POP entfernt den Wert an Position abgelegt `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.u2` Anweisung lädt den Wert der Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.u2` ist `int16`.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelem.u2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="unsigned int32" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|95|U4|Lädt das Element mit dem Typ `unsigned int32` am Index, an die oberste Position des Stapels als ein `int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` werden aus dem Stapel per POP entfernt den Wert an Position abgelegt `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.u4` Anweisung lädt den Wert der Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.u4` ist `int32`.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn Arrays nicht Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelem.u4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die Adresse des Arrayelements an einem angegebenen Arrayindex als Typ <see langword="&amp;" /> (verwalteter Zeiger) an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|8F &LT; `T` >|ldelema `class`|Lädt die Adresse des Arrayelements an `index` an die oberste Position des Auswertungsstapels als Typ `&` (verwalteter Zeiger).|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `array` wird auf dem Stapel abgelegt.  
  
2.  Ein Indexwert `index` wird auf dem Stapel abgelegt.  
  
3.  `index` und `array` , die von den Stapel geholt werden an der Position gespeicherte Adresse `index` in `array` gesucht wird.  
  
4.  Die Adresse wird auf dem Stapel abgelegt.  
  
 Die `ldelema` dient zum Abrufen der Adresse eines Objekts an einem bestimmten Index in ein Array von Objekten (des Typs `class`). Die `ldelema` Anweisung lädt die Adresse der den Wert am Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Wert muss vom Typ `class` mit der Anweisung übergeben.  
  
 Der Rückgabewert für `ldelema` ist ein verwalteter Zeiger (Typ `&`).  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldelema` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sucht den Wert eines Felds in dem Objekt, für das sich derzeit ein Verweis auf dem Auswertungsstapel befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|Legt den Wert eines Felds in ein angegebenes Objekt im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis (oder Zeiger) wird auf dem Stapel abgelegt.  
  
2.  Der Objektverweis (oder Zeiger) wird vom Stapel geholt. der Wert des angegebenen Felds in dem Objekt wurde gefunden.  
  
3.  Der Wert im Feld gespeicherten wird auf dem Stapel abgelegt.  
  
 Die `ldfld` -Anweisung legt den Wert eines Felds in einem Objekt im Stapel befindet. Das Objekt muss auf dem Stapel als einen Objektverweis (Typ `O`), einen verwalteten Zeiger (Typ `&`), einen nicht verwalteten Zeiger (Typ `native int`), einen flüchtigen Zeiger (Typ `*`), oder eine Instanz eines Werttyps. Die Verwendung eines nicht verwalteten Zeigers ist nicht in überprüfbarem Code zulässig. Das Feld des Objekts wird durch ein Metadatentoken angegeben, die auf einen Feldmember verweisen muss. Der Rückgabetyp ist identisch mit dem Feld zugeordnet. Das Feld kann ein Instanzfeld (in diesem Fall das Objekt kein null-Verweis sein muss) oder ein statisches Feld sein.  
  
 Die `ldfld` Anweisung kann vorangestellt werden eine oder beide der <xref:System.Reflection.Emit.OpCodes.Unaligned> und <xref:System.Reflection.Emit.OpCodes.Volatile> Präfixe.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn das Objekt null ist, und das Feld nicht statisch ist.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn das angegebene Feld in den Metadaten nicht gefunden wird. Dies ist in der Regel aktiviert, wenn Microsoft Intermediate Language (MSIL)-Anweisungen nicht zur Laufzeit in nativen Code konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldfld` Opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sucht die Adresse eines Felds in dem Objekt, für das sich derzeit ein Verweis auf dem Auswertungsstapel befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|Legt die Adresse eines `field` in ein angegebenes Objekt im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis (oder Zeiger) wird auf dem Stapel abgelegt.  
  
2.  Der Objektverweis (oder Zeiger) wird vom Stapel geholt. die Adresse des angegebenen Felds in dem Objekt wurde gefunden.  
  
3.  Die Adresse des angegebenen Felds wird auf dem Stapel abgelegt.  
  
 Die `ldflda` Anweisung legt die Adresse eines Felds in einem Objekt im Stapel befindet. Das Objekt muss auf dem Stapel als einen Objektverweis (Typ `O`), einen verwalteten Zeiger (Typ `&`), einen nicht verwalteten Zeiger (Typ `native int`), einen flüchtigen Zeiger (Typ `*`), oder eine Instanz eines Werttyps. Die Verwendung eines nicht verwalteten Zeigers ist nicht in überprüfbarem Code zulässig. Das Feld des Objekts wird durch ein Metadatentoken angegeben, die auf einen Feldmember verweisen muss.  
  
 Der Rückgabewert von `ldflda` ist ein verwalteter Zeiger (Typ `&`), wenn das Objekt wird als ein nicht verwalteter Zeiger in den Stapel abgelegt, in diesem Fall die Absenderadresse ist auch ein nicht verwalteter Zeiger (Typ `native int`).  
  
 Die `ldflda` Anweisung kann vorangestellt werden eine oder beide der <xref:System.Reflection.Emit.OpCodes.Unaligned> und <xref:System.Reflection.Emit.OpCodes.Volatile> Präfixe.  
  
 <xref:System.InvalidOperationException> wird ausgelöst, wenn das Objekt nicht innerhalb der Anwendungsdomäne ist von dem sie zugegriffen wird. Die Adresse eines Felds, das nicht innerhalb der Zugriff auf die Anwendungsdomäne ist, kann nicht geladen werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn das Objekt null ist, und das Feld nicht statisch ist.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn das angegebene Feld in den Metadaten nicht gefunden wird. Dies ist in der Regel aktiviert, wenn Microsoft Intermediate Language (MSIL)-Anweisungen nicht zur Laufzeit in nativen Code konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldflda` Opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen nicht verwalteten Zeiger (Typ <see langword="native int" />) auf dem Auswertungsstapel ab. Dieser Zeiger zeigt auf den systemeigenen Code, der eine bestimmte Methode implementiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|ldftn `method`|Legt einen Zeiger auf eine Methode verweist `method` auf dem Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der nicht verwaltete Zeiger auf eine bestimmte Methode wird auf dem Stapel abgelegt.  
  
 Die spezifische Methode (`method`) kann aufgerufen werden, mithilfe der <xref:System.Reflection.Emit.OpCodes.Calli> Anweisung, wenn er verweist auf eine verwaltete Methode (oder einen Stub, der Übergang von verwaltetem zu nicht verwaltetem Code).  
  
 Der zurückgegebene Wert zeigt in systemeigenen Code mit der CLR, die Aufrufkonvention. Diese Methodenzeiger sollten nicht in nicht verwalteten nativen Code als Rückrufroutine übergeben werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldftn` Opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="native int" /> indirekt als <see langword="native int" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|4D|ldind.i|Lädt die `native int` Wert unter Adresse `addr` im Stapel als eine `native int`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert bei der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.i` -Anweisung indirekt lädt eine `native int` Wert aus der angegebenen Adresse (des Typs `native int`, `&`, oder *) als in den Stapel eine `native int`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende Wertklasse für den integrierten angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab. Gleitkommazahlen-Punktwerte werden in konvertiert `F` Geben Sie beim Laden auf dem Auswertungsstapel ab.  
  
 Ordnungsgemäß formatierte Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die ursprünglich auf dem Stapel abgelegt muss ausgerichtet sein, an die Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anleitungen für die vorbeugende Maßnahmen). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Für Datentypen, die größer als 1 Byte ist die Anordnung der Bytes abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldind.i` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="int8" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|46|ldind. i1|Lädt die `int8` Wert unter Adresse `addr` im Stapel als ein `int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert bei der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert ist auf dem Stapel abgelegt...  
  
 Die `ldind.i1` -Anweisung indirekt lädt ein `int8` Wert aus der angegebenen Adresse (des Typs `native int`, `&`, oder *) als in den Stapel eine `int32`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende Wertklasse für den integrierten angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab. Gleitkommazahlen-Punktwerte werden in konvertiert `F` Geben Sie beim Laden auf dem Auswertungsstapel ab.  
  
 Ordnungsgemäß formatierte Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die ursprünglich auf dem Stapel abgelegt muss ausgerichtet sein, an die Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anleitungen für die vorbeugende Maßnahmen). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Für Datentypen, die größer als 1 Byte ist die Anordnung der Bytes abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldind.i1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="int16" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|48|ldind. i2|Lädt die `int16` Wert unter Adresse `addr` im Stapel als ein `int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert bei der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.i2` -Anweisung indirekt lädt ein `int16` Wert aus der angegebenen Adresse (des Typs `native int`, `&`, oder *) als in den Stapel eine `int32`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende Wertklasse für den integrierten angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab. Gleitkommazahlen-Punktwerte werden in konvertiert `F` Geben Sie beim Laden auf dem Auswertungsstapel ab.  
  
 Ordnungsgemäß formatierte Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die ursprünglich auf dem Stapel abgelegt muss ausgerichtet sein, an die Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anleitungen für die vorbeugende Maßnahmen). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Für Datentypen, die größer als 1 Byte ist die Anordnung der Bytes abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldind.i2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="int32" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|4A|i4|Lädt die `int32` Wert unter Adresse `addr` im Stapel als ein `int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert bei der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.i4` -Anweisung indirekt lädt ein `int32` Wert aus der angegebenen Adresse (des Typs `native int`, `&`, oder *) als in den Stapel eine `int32`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende Wertklasse für den integrierten angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab. Gleitkommazahlen-Punktwerte werden in konvertiert `F` Geben Sie beim Laden auf dem Auswertungsstapel ab.  
  
 Ordnungsgemäß formatierte Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die ursprünglich auf dem Stapel abgelegt muss ausgerichtet sein, an die Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anleitungen für die vorbeugende Maßnahmen). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Für Datentypen, die größer als 1 Byte ist die Anordnung der Bytes abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldind.i4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="int64" /> indirekt als <see langword="int64" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|4C|i8|Lädt die `int64` Wert unter Adresse `addr` im Stapel als ein `int64`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert bei der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.i8` -Anweisung indirekt lädt ein `int64` Wert aus der angegebenen Adresse (des Typs `native int`, `&`, oder *) als in den Stapel eine `int64`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende Wertklasse für den integrierten angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab. Gleitkommazahlen-Punktwerte werden in konvertiert `F` Geben Sie beim Laden auf dem Auswertungsstapel ab.  
  
 Ordnungsgemäß formatierte Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die ursprünglich auf dem Stapel abgelegt muss ausgerichtet sein, an die Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anleitungen für die vorbeugende Maßnahmen). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Für Datentypen, die größer als 1 Byte ist die Anordnung der Bytes abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldind.i8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="float32" /> indirekt als Typ <see langword="F" /> (Gleitkommawert) in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|4E|ldind. r4|Lädt die `float32` Wert unter Adresse `addr` als einen Typ in den Stapel `F`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert bei der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.r4` -Anweisung indirekt lädt eine `float32` Wert aus der angegebenen Adresse (des Typs `native int`, `&`, oder *) als einen Typ in den Stapel `F`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende Wertklasse für den integrierten angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab. Gleitkommazahlen-Punktwerte werden in konvertiert `F` Geben Sie beim Laden auf dem Auswertungsstapel ab.  
  
 Ordnungsgemäß formatierte Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die ursprünglich auf dem Stapel abgelegt muss ausgerichtet sein, an die Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anleitungen für die vorbeugende Maßnahmen). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Für Datentypen, die größer als 1 Byte ist die Anordnung der Bytes abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldind.r4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="float64" /> indirekt als Typ <see langword="F" /> (Gleitkommawert) in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|4F|ldind. r8|Lädt die `float64` Wert unter Adresse `addr` als einen Typ in den Stapel `F`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert bei der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.r8` -Anweisung indirekt lädt eine `float64` Wert aus der angegebenen Adresse (des Typs `native int`, `&`, oder *) als in den Stapel eine `float64`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende Wertklasse für den integrierten angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab. Gleitkommazahlen-Punktwerte werden in konvertiert `F` Geben Sie beim Laden auf dem Auswertungsstapel ab.  
  
 Ordnungsgemäß formatierte Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die ursprünglich auf dem Stapel abgelegt muss ausgerichtet sein, an die Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anleitungen für die vorbeugende Maßnahmen). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Für Datentypen, die größer als 1 Byte ist die Anordnung der Bytes abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldind.r8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Objektverweis indirekt als Typ <see langword="O" /> (Objektverweis) in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|50|ldind.ref|Lädt den Objektverweis Downloadadresse `addr` als einen Typ in den Stapel `O`|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. Der Objektverweis, der an der Adresse gespeichert, wird abgerufen.  
  
3.  Der abgerufene Verweis wird auf dem Stapel abgelegt.  
  
 Die `ldind.ref` -Anweisung lädt indirekt den Objektverweis der angegebenen Adresse (des Typs `native int`, `&`, oder *) als Typ in den Stapel `O`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende Wertklasse für den integrierten angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab. Gleitkommazahlen-Punktwerte werden in konvertiert `F` Geben Sie beim Laden auf dem Auswertungsstapel ab.  
  
 Ordnungsgemäß formatierte Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die ursprünglich auf dem Stapel abgelegt muss ausgerichtet sein, an die Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anleitungen für die vorbeugende Maßnahmen). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Für Datentypen, die größer als 1 Byte ist die Anordnung der Bytes abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldind.ref` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="unsigned int8" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|47|ldind. U1|Lädt die `unsigned int8` Wert unter Adresse `addr` im Stapel als ein `int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert bei der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.u1` -Anweisung indirekt lädt ein `unsigned int8` Wert aus der angegebenen Adresse (des Typs`native int`, `&`, oder *) als in den Stapel eine `int32`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende Wertklasse für den integrierten angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab. Gleitkommazahlen-Punktwerte werden in konvertiert `F` Geben Sie beim Laden auf dem Auswertungsstapel ab.  
  
 Ordnungsgemäß formatierte Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die ursprünglich auf dem Stapel abgelegt muss ausgerichtet sein, an die Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anleitungen für die vorbeugende Maßnahmen). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Für Datentypen, die größer als 1 Byte ist die Anordnung der Bytes abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldind.u1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="unsigned int16" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|49|ldind. u2|Lädt die `unsigned int16` Wert unter Adresse `addr` im Stapel als ein `int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert bei der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.u2` -Anweisung indirekt lädt ein `unsigned int16` Wert aus der angegebenen Adresse (des Typs `native int`, `&`, oder *) als in den Stapel eine `int32`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende Wertklasse für den integrierten angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab. Gleitkommazahlen-Punktwerte werden in konvertiert `F` Geben Sie beim Laden auf dem Auswertungsstapel ab.  
  
 Ordnungsgemäß formatierte Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die ursprünglich auf dem Stapel abgelegt muss ausgerichtet sein, an die Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anleitungen für die vorbeugende Maßnahmen). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Für Datentypen, die größer als 1 Byte ist die Anordnung der Bytes abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldind.u2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="unsigned int32" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|4 B|U4|Lädt die `unsigned int32` Wert unter Adresse `addr` im Stapel als ein `int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert bei der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.u4` -Anweisung indirekt lädt ein `unsigned int32` Wert aus der angegebenen Adresse (des Typs `native int`, `&`, oder *) als in den Stapel eine `int32`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende Wertklasse für den integrierten angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf ausgedehnt werden `int32` (nicht `native int`) werden beim Laden auf dem Auswertungsstapel ab. Gleitkommazahlen-Punktwerte werden in konvertiert `F` Geben Sie beim Laden auf dem Auswertungsstapel ab.  
  
 Ordnungsgemäß formatierte Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die ursprünglich auf dem Stapel abgelegt muss ausgerichtet sein, an die Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anleitungen für die vorbeugende Maßnahmen). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Für Datentypen, die größer als 1 Byte ist die Anordnung der Bytes abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldind.u4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Anzahl der Elemente eines nullbasierten, eindimensionalen Arrays auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|8E|ldlen|Legt die Länge (des Typs `natural unsigned int`) eines Arrays auf dem Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis auf ein Array ist auf dem Stapel abgelegt.  
  
2.  Der Arrayverweis als aus dem Stapel per pop ausgelesen wird, und die Länge berechnet wird.  
  
3.  Die Länge ist auf dem Stapel abgelegt.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Die Länge wird zurückgegeben, als eine `natural unsigned int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn der Arrayverweis als null-Verweis ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldlen` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable an einem bestimmten Index in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc `index`|Lädt die lokale Variable am Index `index` Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert der lokale Variable am angegebenen Index ist auf dem Stapel abgelegt.  
  
 Die `ldloc` -Anweisung legt den Inhalt der lokalen Variable Zahl am durchlaufenen Index in den Auswertungsstapel, wo die lokalen Variablen oder höher 0 nummeriert sind. Lokale Variablen werden vor der Eingabe der Methode, nur dann, wenn das Initialisierungsflag für die Methode "true" ist auf 0 initialisiert. Es gibt 65.535 (2 ^ 16 - 1) lokale Variablen möglich (0-65.534). Index 65.535 ist ungültig, da wahrscheinliche Implementierungen eine 2-Byte-Ganzzahl verwenden werden, um sowohl eine lokale Index zusammen mit der Gesamtanzahl der lokalen Variablen für eine bestimmte Methode nachzuverfolgen. Wenn ein Index der 65535 gültig vorgenommen wurden hatte, müssten eine größere ganze Zahl, um die Anzahl der lokalen Variablen in einer solchen Methode nachzuverfolgen.  
  
 Die `ldloc.0`, `ldloc.1`, `ldloc.2`, und `ldloc.3` Anweisungen ermöglichen eine effiziente Codierung für den Zugriff auf die ersten vier lokalen Variablen.  
  
 Der Typ des Werts ist identisch mit den Typ der lokalen Variablen, die in das Method-Header angegeben ist. Finden Sie unter Partition i lokale Variablen, die kleiner sind als 4 Byte lange erweitert werden, geben Sie `int32` werden beim Laden auf den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `ldloc` Opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable am Index 0 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|06|ldloc.0|Lädt die lokale Variable am Index 0 in den Auswertungsstapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert der lokale Variable am Index 0 wird auf dem Stapel abgelegt.  
  
 `ldloc.0` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc>, ermöglicht den Zugriff auf die lokale Variable am Index 0.  
  
 Der Typ des Werts ist identisch mit den Typ der lokalen Variablen, die in das Method-Header angegeben ist. Lokale Variablen, die kleiner als 4 Byte lang sind Typ erweitert `int32` werden beim Laden auf den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldloc.0` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable am Index 1 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|07|ldloc. 1|Lädt die lokale Variable am Index 1 in den Auswertungsstapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert der lokale Variable am Index 1 wird auf dem Stapel abgelegt.  
  
 `ldloc.1` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc>, ermöglicht den Zugriff auf die lokale Variable am Index 1.  
  
 Der Typ des Werts ist identisch mit den Typ der lokalen Variablen, die in das Method-Header angegeben ist. Lokale Variablen, die kleiner als 4 Byte lang sind Typ erweitert `int32` werden beim Laden auf den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldloc.1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable am Index 2 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|08|ldloc.2|Lädt die lokale Variable am Index 2 in den Auswertungsstapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert der lokale Variable am Index 2 ist auf dem Stapel abgelegt.  
  
 `ldloc.2` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc>, ermöglicht den Zugriff auf die lokale Variable am Index 2.  
  
 Der Typ des Werts ist identisch mit den Typ der lokalen Variablen, die in das Method-Header angegeben ist. Lokale Variablen, die kleiner als 4 Byte lang sind Typ erweitert `int32` werden beim Laden auf den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldloc.2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable am Index 3 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|09|ldloc. 3|Lädt die lokale Variable am Index 3 in den Auswertungsstapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert der lokale Variable am Index 3 wird auf dem Stapel abgelegt.  
  
 `ldloc.3` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc>, ermöglicht den Zugriff auf die lokale Variable am Index 3.  
  
 Der Typ des Werts ist identisch mit den Typ der lokalen Variablen, die in das Method-Header angegeben ist. Lokale Variablen, die kleiner als 4 Byte lang sind Typ erweitert `int32` werden beim Laden auf den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldloc.3` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable an einem bestimmten Index in den Auswertungsstapel, Kurzform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|Lädt die lokale Variable am Index `index` in den Stapel, Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert der lokale Variable am angegebenen Index ist auf dem Stapel abgelegt.  
  
 Die `ldloc.s` -Anweisung legt den Inhalt der lokalen Variable Zahl am durchlaufenen Index in den Auswertungsstapel, wo die lokalen Variablen oder höher 0 nummeriert sind. Lokale Variablen werden vor der Eingabe der Methode, wenn das Initialisierungsflag für die Methode "true" ist auf 0 initialisiert. Es sind 256 (2 ^ 8) lokale Variablen (0-255) in der Kurzform möglich Dies ist eine effizientere Codierung als `ldloc`.  
  
 Der Typ des Werts ist identisch mit den Typ der lokalen Variablen, die in das Method-Header angegeben ist. Finden Sie unter Partition i lokale Variablen, die kleiner sind als 4 Byte lange erweitert werden, geben Sie `int32` werden beim Laden auf den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `ldloc.s` Opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die Adresse der lokalen Variablen am angegebenen Index in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FRONT-END-OD &LT; `unsigned int16` >|ldloca `index`|Lädt die Adresse der lokalen Variablen am `index` auf dem Auswertungsstapel ab.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  In der lokalen Variablen am angegebenen Index gespeicherte Adresse wird auf dem Stapel abgelegt.  
  
 Die `ldloca` Anweisung legt die Adresse der lokalen Variable Zahl am durchlaufenen Index auf den Stapel, in dem lokale Variablen 0 nummeriert oder höher. Der Wert, der auf dem Stapel abgelegt wurde bereits ordnungsgemäß ausgerichtet für die Verwendung mit Anweisungen wie <xref:System.Reflection.Emit.OpCodes.Ldind_I> und <xref:System.Reflection.Emit.OpCodes.Stind_I>. Das Ergebnis ist eine vorübergehende Zeiger (Typ `*`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldloca` Opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die Adresse der lokalen Variablen am angegebenen Index in den Auswertungsstapel, Kurzform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|Lädt die Adresse der lokalen Variablen am `index` in den Auswertungsstapel, Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  In der lokalen Variablen am angegebenen Index gespeicherte Adresse wird auf dem Stapel abgelegt.  
  
 Die `ldloca.s` Anweisung legt die Adresse der lokalen Variable Zahl am durchlaufenen Index auf den Stapel, in dem lokale Variablen 0 nummeriert oder höher. Der Wert, der auf dem Stapel abgelegt wurde bereits ordnungsgemäß ausgerichtet für die Verwendung mit Anweisungen wie <xref:System.Reflection.Emit.OpCodes.Ldind_I> und <xref:System.Reflection.Emit.OpCodes.Stind_I>. Das Ergebnis ist eine vorübergehende Zeiger (Typ `*`).  
  
 Die `ldloca.s` Anweisung bietet eine effiziente Codierung für die Verwendung mit der lokalen Variablen von 0 bis 255.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldloca.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen NULL-Verweis (Typ <see langword="O" />) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|14|ldnull|einen null-Verweis auf den Stapel mithilfe von Push übertragen|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein null-Objektverweis ist auf dem Stapel abgelegt.  
  
 `ldnull` Legt einen null-Verweis (Typ `O`) auf dem Stapel. Hiermit wird die Speicherorte initialisiert, bevor sie mit Daten aufgefüllt werden, oder wenn sie veraltet sind.  
  
 `ldnull` enthält einen null-Verweis, der Größe unabhängig ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldnull` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert das Werttypobjekt, auf das eine Adresse zeigt, an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Kopiert eine Instanz des Werttyps `class` auf den Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Die Adresse eines Objekts vom Typ Wert wird auf dem Stapel abgelegt.  
  
2.  Die Adresse aus dem Stapel per pop ausgelesen wird, und die Instanz an der betreffenden Adresse gesucht wird.  
  
3.  Der Wert des Objekts an dieser Adresse gespeichert wird auf dem Stapel abgelegt.  
  
 Die `ldobj` Anweisung wird verwendet, um einen Werttyp als Parameter übergeben.  
  
 Die `ldobj` -Anweisung kopiert den Wert verweist `addrOfValObj` (des Typs `&`, `*`, oder `native int`) am Anfang des Stapels. Die Anzahl der kopierten Bytes hängt von der Größe der Klasse (gemäß der `class` Parameter). Die `class` -Parameter ist ein Metadatentoken, das den Werttyp darstellt.  
  
 Den Betrieb der `ldobj` Anweisung kann geändert werden, einen unmittelbar vorangehenden <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn die Microsoft Intermediate Language (MSIL)-Anweisung in systemeigenen Code statt zur Laufzeit konvertiert wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldobj` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Wert eines statischen Felds auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|Legt den Wert von `field` auf dem Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert des Felds wird auf dem Stapel abgelegt.  
  
 Die `ldsfld` -Anweisung legt den Wert eines statischen (freigegeben für alle Instanzen einer Klasse) Feld auf dem Stapel. Der Rückgabetyp ist, die dem übergebenen Metadatentoken zugeordnet `field`.  
  
 Die `ldsfld` Anweisung haben eine <xref:System.Reflection.Emit.OpCodes.Volatile> Präfix.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldsfld` Opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Adresse eines statischen Felds auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|7F &LT; `T` >|ldsflda `field`|Legt die Adresse von `field` auf dem Stapel|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Die Adresse eines bestimmten Felds wird auf dem Stapel abgelegt.  
  
 Die `ldsflda` Anweisung legt die Adresse eines statischen (freigegeben für alle Instanzen einer Klasse) Feld auf dem Stapel. Die Adresse dargestellt werden kann, als einen flüchtigen Zeiger (Typ `*`) Wenn das Metadatentoken `field` verweist auf einen Typ, dessen Speicher verwaltet wird. Andernfalls entspricht es einen nicht verwalteten Zeiger (Typ `native int`). Beachten Sie, dass `field` möglicherweise ein statischen global mit einer zugewiesenen relative virtuelle Adresse (der Offset des Felds aus der Basisadresse, der seine PE-Datei in den Arbeitsspeicher geladen wird), in dem der Arbeitsspeicher wird nicht verwaltet.  
  
 Die `ldsflda` Anweisung haben eine <xref:System.Reflection.Emit.OpCodes.Volatile> Präfix.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn Feld in den Metadaten nicht gefunden wird. Dies ist in der Regel aktiviert, wenn Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code, nicht zur Laufzeit konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldsflda` Opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen neuen Objektverweis auf ein in den Metadaten gespeichertes Zeichenfolgenliteral mittels Push ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|Legt ein Zeichenfolgenobjekt, das für den-Metadatenzeichenfolgetoken `mdToken`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis auf eine Zeichenfolge wird auf dem Stapel abgelegt.  
  
 Die `ldstr` -Anweisung legt einen Objektverweis (Typ `O`), ein neues Zeichenfolgenobjekt, das in den Metadaten gespeicherte Zeichenfolgenliteral darstellt. Die `ldstr` Anweisung weist die erforderliche Menge an Arbeitsspeicher und führt Konvertierung erforderlich, um das Formular, in der Datei in das Zeichenfolgenformat, das zur Laufzeit erforderlich verwendet das Zeichenfolgenliteral konvertieren.  
  
 Die Common Language Infrastructure (CLI) wird sichergestellt, dass das Ergebnis von zwei `ldstr` Anweisungen verweisen auf zwei Metadatentoken verwendet, die die gleiche Sequenz von Zeichen zurück, genau das gleiche Zeichenfolgenobjekt (ein Prozess als "Internalisieren von Zeichenfolgen" bezeichnet).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldstr` Opcode:  
  
-   ILGenerator.Emit(OpCode, string)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert ein Metadatentoken in seine Laufzeitdarstellung und legt es auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken `token`|Konvertiert ein Metadatentoken in seine laufzeitdarstellung an.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Das übergebene Token wird in konvertiert eine `RuntimeHandle` und auf dem Stapel abgelegt.  
  
 Die `ldtoken` Anweisung Pushvorgänge einen `RuntimeHandle` für das angegebene Metadatentoken. Ein `RuntimeHandle` kann eine `fieldref/fielddef`, `methodref/methoddef`, oder ein `typeref/typedef`.  
  
 Der Wert, der auf dem Stapel abgelegt kann verwendet werden, in Aufrufen von `Reflection` Methoden in der System-Klassenbibliothek.  
  
 Informationen über Laufzeithandles finden Sie die folgenden Klassen: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, und <xref:System.RuntimeMethodHandle>.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `ldtoken` Opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen nicht verwalteten Zeiger (Typ <see langword="native int" />) auf systemeigenen Code auf dem Auswertungsstapel ab. Dieser Code implementiert eine bestimmte virtuelle Methode, die einem angegebenen Objekt zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|Legt einen Zeiger auf ein Objekt der virtuellen Methode `method` auf dem Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Es ist ein Objektverweis auf dem Stapel abgelegt.  
  
2.  Der Objektverweis per pop ausgelesen wird aus dem Stapel und die Adresse des Einstiegspunkts der-Methode (entsprechend der Angabe durch das Metadatentoken `method`) gesucht wird.  
  
3.  Der Zeiger auf `method` wird auf dem Stapel abgelegt.  
  
 Der resultierende nicht verwaltete Zeiger auf den Stapel von übertragen die `ldvirtftn` Anweisung kann aufgerufen werden, mithilfe der <xref:System.Reflection.Emit.OpCodes.Calli> Anweisung, wenn er verweist auf eine verwaltete Methode (oder einen Stub, der Übergang von verwaltetem zu nicht verwaltetem Code).  
  
 Der nicht verwaltete Zeiger verweist auf systemeigenen Code mit der CLR, die Aufrufkonvention. Diese Methodenzeiger sollten nicht in nicht verwalteten nativen Code als Rückrufroutine übergeben werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ldvirtftn` Opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beendet einen geschützten Codebereich, wobei die Steuerung bedingungslos an eine bestimmte Zielanweisung übertragen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|TT &LT; `int32` >|Lassen Sie `target`|Beendet einen geschützten Codebereich an.|  
  
 Es gibt keine Zustandswechsel, die für diese Anweisung angegeben.  
  
 Die `leave` -Anweisung überträgt die Steuerung bedingungslos an die bestimmte zielanweisung, dargestellt als mit 4-Byte-Offset vom Anfang der aktuelle Anweisung folgenden.  
  
 Die `leave` Anweisung ähnelt der `br` -Anweisung, aber es kann verwendet werden, um das Beenden einer `try`, `filter`, oder `catch` blockieren, während die normale verzweigungsanweisungen nur in solchen Blocks können zum Übertragen des Steuerelements in verwendet werden Es ist. Die `leave` Anweisung leert den Auswertungsstapel und stellt sicher, dass die entsprechenden umgebenden `finally` -blocke ausgeführt werden.  
  
 Können keine `leave` Anweisungen zum Beenden einer `finally` Block. Um die codegenerierung für Ausnahmehandler zu erleichtern es innerhalb eines Catch-Blocks verwenden gültig ist eine `leave` -Anweisung die Steuerung an eine beliebige Anweisung in der zugeordneten übertragen `try` Block.  
  
 Weist eine Anweisung auf einen oder mehrere Präfix-Codes, können nur werden die Steuerung an die erste dieser Präfixe.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `leave` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beendet einen geschützten Codebereich, wobei die Steuerung bedingungslos an eine bestimmte Zielanweisung übertragen wird, Kurzform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|DE < `int8` >|leave.s `target`|Beendet einen geschützten Codebereich, Kurzform.|  
  
 Es gibt keine Zustandswechsel, die für diese Anweisung angegeben.  
  
 Die `leave.s` -Anweisung überträgt die Steuerung bedingungslos an die übergebene zielanweisung, als mit 1-Byte-Offset vom Anfang der aktuelle Anweisung folgenden dargestellt.  
  
 Die `leave.s` Anweisung ähnelt der `br` -Anweisung, aber es kann verwendet werden, um das Beenden einer `try`, `filter`, oder `catch` blockieren, während die normale verzweigungsanweisungen nur in solchen Blocks können zum Übertragen des Steuerelements in verwendet werden Es ist. Die `leave.s` Anweisung leert den Auswertungsstapel und stellt sicher, dass die entsprechenden umgebenden `finally` -blocke ausgeführt werden.  
  
 Können keine `leave.s` Anweisungen zum Beenden einer `finally` Block. Um die codegenerierung für Ausnahmehandler zu erleichtern es innerhalb eines Catch-Blocks verwenden gültig ist eine `leave.s` -Anweisung die Steuerung an eine beliebige Anweisung in der zugeordneten übertragen `try` Block.  
  
 Weist eine Anweisung auf einen oder mehrere Präfix-Codes, können nur werden die Steuerung an die erste dieser Präfixe.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `leave.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Belegt eine bestimmte Anzahl von Bytes aus dem lokalen dynamischen Speicherpool und legt die Adresse (einen flüchtigen Zeiger, Typ <see langword="*" />) des ersten reservierten Bytes auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FRONT-END-0F|localloc|Speicherplatz wird vom lokalen Heap zuordnen.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Die Anzahl der Bytes, die zugeordnet werden, wird auf dem Stapel abgelegt.  
  
2.  Die Anzahl von Bytes wird vom Stapel geholt. Größe des Arbeitsspeichers, die für die Größe wird vom lokalen Heap zugeordnet.  
  
3.  Ein Zeiger auf das erste Byte der belegte Arbeitsspeicher ist auf dem Stapel abgelegt.  
  
 Die `localloc` Anweisung ordnet `size` (Typ `natural unsigned int`) Bytes aus dem lokalen dynamischen Arbeitsspeicher pool und die Adresse zurückgibt (einen flüchtigen Zeiger, Typ `*`) des ersten reservierten Bytes. Der Speicherblock, der zurückgegeben wird nur dann, wenn das Initialisierungsflag für die Methode wird mit 0 initialisiert `true`. Wenn die aktuelle Methode führt eine <xref:System.Reflection.Emit.OpCodes.Ret>, lokalen Speicherpool für die erneute Verwendung zur Verfügung gestellt wird.  
  
 Die resultierende Adresse orientiert, damit alle primitiven Datentyp es gespeichert werden kann, mit der `stind` Anweisungen (z. B. <xref:System.Reflection.Emit.OpCodes.Stind_I4>) und geladen, mit der `ldind` Anweisungen (z. B. <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 Die `localloc` Anweisung kann nicht auftreten, in einem `filter`, `catch`, `finally`, oder `fault` Block.  
  
 <xref:System.StackOverflowException> wird ausgelöst, wenn nicht genügend zur Verarbeitung die Anfrage Arbeitsspeicher.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `localloc` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen typisierten Verweis auf eine Instanz eines bestimmten Typs auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany `class`|Legt einen typisierten Verweis des Typs `class` im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Zeiger auf Daten auf dem Stapel abgelegt wird.  
  
2.  Der Zeiger wird per pop ausgelesen und in einen typisierten Verweis des Typs konvertiert `class`.  
  
3.  Die typisierte Verweis wird auf dem Stapel abgelegt.  
  
 Die `mkrefany` -Anweisung unterstützt das Übergeben von dynamisch typisierten verweisen. Der Zeiger muss vom Typ `&`, `*`, oder `native int`, und halten Sie die gültige Adresse eines Datenelements. `Class` Beschreibt das Klassentoken den Typ der Daten, auf der Zeiger verweist. `Mkrefany` Legt einen typisierten Verweis auf dem Stapel, wobei ein nicht transparenten Deskriptor des Zeigers und der Typ `class`.  
  
 Der einzige zulässige Operation auf einen typisierten Verweis ist auf eine Methode übergeben, die einen typisierten Verweis als Parameter erforderlich. Der aufgerufene können Sie dann die <xref:System.Reflection.Emit.OpCodes.Refanytype> und <xref:System.Reflection.Emit.OpCodes.Refanyval> Anweisungen, um den Typ (Klasse) und die Adresse bzw. abgerufen.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn `class` wurde nicht gefunden. Dies wird in der Regel erkannt, wenn Microsoft Intermediate Language (MSIL)-Anweisungen nicht zur Laufzeit, sondern in systemeigenen Code konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `mkrefany` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multipliziert zwei Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|5A|mul|Multipliziert zwei Werte im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `value1` multipliziert wird `value2`.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `mul` -Anweisung multipliziert `value1` von `value2` und legt das Ergebnis im Stapel. Operationen mit ganzen Zahlen abgeschnitten werden, automatisch die höherwertigen Bits bei einem Überlauf.  
  
 Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> für eine ganze Zahlen multiply-Vorgang mit der Bearbeitung von Überlaufdaten.  
  
 Für die Gleitkommatypen 0 * Unendlich = NaN.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `mul` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multipliziert zwei Ganzzahlwerte, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D8|mul.ovf|Multipliziert zwei Ganzzahlwerte auf dem Stapel mit eine überlaufprüfung an.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `value1` multipliziert wird `value2`, mit der eine überlaufprüfung.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `mul.ovf` Anweisung multipliziert die ganze Zahl `value1` durch eine ganze Zahl `value2` und legt das Ergebnis im Stapel. Eine Ausnahme wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp passen.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `mul.ovf` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multipliziert zwei Ganzzahlwerte ohne Vorzeichen, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|Multipliziert zwei Werte, die auf dem Stapel mit eine überlaufprüfung ohne Vorzeichen.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `value1` multipliziert wird `value2`, mit der eine überlaufprüfung.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `mul.ovf.un` -Anweisung multipliziert die ganze Zahl ohne Vorzeichen `value1` von Ganzzahl ohne Vorzeichen `value2` und legt das Ergebnis im Stapel. Eine Ausnahme wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp passen.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `mul.ovf.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Negiert einen Wert und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|65|Neg|Negiert den Wert derzeit an oberster Position im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Wert wird auf dem Stapel abgelegt.  
  
2.  Ein Wert vom Stapel geholt und negiert.  
  
3.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `neg` Anweisung negiert den Wert und legt das Ergebnis auf dem Stapel. Der Rückgabetyp ist identisch mit dem Operandentyp.  
  
 Negation von ganzzahligen Werten ist die standardmäßige Zweierkomplement Negation. Insbesondere führt die kleinste negative Zahl (der keine positive Entsprechung), wird die kleinste negative Zahl ergibt. Diese Verwendung Überlauf erkennen die <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> Anweisung stattdessen (d. h. 0 subtrahiert).  
  
 Negiert eine Gleitkommazahl kann kein Überlauf und negieren NaN wird NaN zurückgegeben.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `neg` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen Objektverweis auf ein neues nullbasiertes, eindimensionales Array auf dem Auswertungsstapel ab, dessen Elemente einen bestimmten Typ aufweisen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|Erstellt ein neues Array mit Elementen des Typs `etype`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Die Anzahl der Elemente im Array ist auf dem Stapel abgelegt.  
  
2.  Die Anzahl der Elemente aus dem Stapel per pop ausgelesen wird, und das Array wird erstellt.  
  
3.  Ein Objektverweis auf das neue Array ist auf dem Stapel abgelegt.  
  
 Die `newarr` -Anweisung legt einen Objektverweis (Typ `O`) in ein neues nullbasiertes, eindimensionales Array, dessen Elemente vom Typ sind `etype` (ein Metadatentoken, das den Typ beschreibt). Die Anzahl der Elemente im neuen Array sollte angegeben werden, als eine `native int`. Gültiges Array Indizes im Bereich von 0 (null), auf die maximale Anzahl von Elementen, die minus eins.  
  
 Die Elemente eines Arrays können beliebigen Typs, einschließlich Werttypen sein.  
  
 Nullbasierten, eindimensionalen Arrays von Zahlen werden erstellt, die mit einem Verweis auf den entsprechenden Werttyp Metadatentoken (<xref:System.Int32>und so weiter). Elemente des Arrays werden mit 0 des entsprechenden Typs initialisiert.  
  
 Eindimensionale Arrays, nicht nullbasiert sind und mehrdimensionale Arrays werden mit erstellt <xref:System.Reflection.Emit.OpCodes.Newobj> statt `newarr`. Sie werden in der Regel erstellt, mit den Methoden der der <xref:System.Array> Klasse in .NET Framework.  
  
 <xref:System.OutOfMemoryException> wird ausgelöst, wenn nicht genügend zum Erfüllen der Anforderung Arbeitsspeicher.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn `numElems` ist kleiner als 0.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `newarr` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Erstellt ein neues Objekt oder eine neue Instanz eines Werttyps, wobei ein Objektverweis (Typ <see langword="O" />) auf dem Auswertungsstapel abgelegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Reserviert ein nicht initialisiertes Objekt oder den Wert ein, und ruft die Konstruktormethode `ctor`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Argumente `arg1` über `argn` auf dem Stapel abgelegt werden, die in der Sequenz.  
  
2.  Argumente `argn` über `arg1` werden vom Stapel geholt und an `ctor` für die objekterstellung.  
  
3.  Ein Verweis auf das neue Objekt wird auf dem Stapel abgelegt.  
  
 Die `newobj` -Anweisung erstellt ein neues Objekt oder eine neue Instanz eines Werttyps. `Ctor` ist ein Metadatentoken (eine `methodref` oder `methoddef` , die als Konstruktor markiert werden muss), die angibt, die Namen, die Klasse und die Signatur des Konstruktors aufgerufen.  
  
 Die `newobj` Anweisung weist eine neue Instanz der Klasse zugeordneten `ctor` und initialisiert alle Felder in der neuen Instanz auf 0 (des richtigen Typs) oder null-Verweise nach Bedarf. Er ruft dann den Konstruktor `ctor` mit den angegebenen Argumenten sowie die neu erstellte Instanz. Nachdem der Konstruktor aufgerufen wurde, wird nun initialisiert Objektverweis (Typ `O`) auf dem Stapel abgelegt wird.  
  
 Aus Sicht des Konstruktors das nicht initialisierte Objekt ist Argument 0, und führen Sie die anderen Newobj übergebenen Argumente in der Reihenfolge.  
  
 Alle nullbasierten, eindimensionalen Arrays werden mit erstellt <xref:System.Reflection.Emit.OpCodes.Newarr>, nicht `newobj`. Auf der anderen Seite werden alle anderen Arrays (mehr als eine Dimension oder eindimensionale, nicht nullbasiert) mit erstellt `newobj`.  
  
 Werttypen sind nicht in der Regel mit erstellt `newobj`. Sie werden in der Regel zugeordnet, entweder als Argumente oder lokale Variablen mit `newarr` (für nullbasierten, eindimensionalen Arrays), oder als Felder von Objekten. Nach der Zuweisung werden sie mithilfe initialisiert <xref:System.Reflection.Emit.OpCodes.Initobj>. Allerdings die `newobj` Anweisung kann verwendet werden, um eine neue Instanz eines Werttyps auf dem Stapel zu erstellen, die dann als Argument, gespeichert in einer lokalen usw. übergeben werden kann.  
  
 <xref:System.OutOfMemoryException> wird ausgelöst, wenn nicht genügend zum Erfüllen der Anforderung Arbeitsspeicher.  
  
 <xref:System.MissingMethodException> wird ausgelöst, wenn eine Konstruktormethode `ctor` mit dem angegebenen Namen, Klasse und die Signatur wurde nicht gefunden. Dies wird in der Regel erkannt, wenn Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code anstelle einer zur Laufzeit konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `newobj` Opcode:  
  
-   ILGenerator.Emit(OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Füllt Speicherplatz auf, wenn Opcodes gepatcht werden. Es wird keine sinnvolle Operation ausgeführt, obwohl ein Verarbeitungszyklus ausgeführt werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|00|NOP|Führt einen Vorgang ohne Verhalten.|  
  
 Es gibt keine Stapel-laufen, die für diese Anweisung definiert.  
  
 Die `nop` nichts. Es soll im Raum zu füllen, wenn Opcodes gepatcht werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `nop` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Berechnet das bitweise Komplement des Ganzzahlwerts an oberster Position des Stapels und legt das Ergebnis als denselben Typ auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|66|not|Berechnet das bitweise Komplement eines Werts an.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird, aus dem Stapel und das bitweise Komplement berechnet.  
  
3.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `not` Anweisung berechnet das bitweise Komplement des ein ganzzahliger Wert und legt das Ergebnis im Stapel. Der Rückgabetyp ist identisch mit dem Operandentyp.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `not` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Berechnet das bitweise Komplement der beiden Ganzzahlwerte an oberster Position des Stapels und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|60|oder|Berechnet das bitweise OR von zwei ganzzahligen Werten gibt eine Ganzzahl zurück.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden per pop ausgelesen, aus dem Stapel und das bitweise OR berechnet.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `or` -Anweisung berechnet das bitweise OR von zwei Werten auf den Stapel legt das Ergebnis im Stapel.  
  
 `Or` ist ein Vorgang für die ganze Zahlen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `or` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Entfernt den Wert, der sich derzeit an oberster Position des Auswertungsstapels befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|26|pop|Holt den obersten Wert aus dem Stapel an.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Höchstwert wird vom Stapel geholt.  
  
 Die `pop` Anweisung entfernt das oberste Element vom Stapel.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `pop` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass beim nachfolgenden Vorgang zur Arrayadresse zur Laufzeit keine Typüberprüfung durchgeführt wird und dass ein verwalteter Zeiger zurückgegeben wird, der nur bedingt geändert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und Microsoft intermediate Language (MSIL) Assembly-Format, sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 1E|ReadOnly.|Geben Sie, dass die nachfolgenden Vorgang keine typüberprüfung zur Laufzeit ausgeführt und gibt einen verwalteten Zeiger mit eingeschränkten Veränderlichkeit.|  
  
 Dieses Präfix kann nur unmittelbar vorangehenden werden die `ldelema` Anweisung und Aufrufe an die speziellen `Address` Methode für Arrays. Die Auswirkungen auf den nachfolgenden Vorgang hat zwei Aspekte:  
  
1.  Zur Laufzeit wird kein Typ-Check-Vorgang ausgeführt. Beachten Sie, dass die Regel wird ein impliziter Typ überprüft die `ldelema` und `stelem` Anweisungen auf Verweis geben Arrays. Wird niemals eine Laufzeit-Typinformationen überprüft Wertklassen, also `readonly` in diesem Fall führt keine Aktion aus.  
  
2.  Die Überprüfung behandelt das Ergebnis des Vorgangs die Adresse des als einen verwalteten Zeiger mit eingeschränkten Veränderlichkeit.  
  
 Der Zeiger wird als Veränderlichkeit eingeschränkt, da der definierende Typ steuert, ob der Wert geändert werden kann. Für die Wertklassen, die verfügbar zu machen, nicht öffentliche Felder oder Methoden, die den Wert direkt zu aktualisieren, der Zeiger ist schreibgeschützt (daher der Name des Präfixes). Insbesondere die Klassen, die primitive Typen (z. B. System. Int32) Mutatoren nicht verfügbar machen und somit auch schreibgeschützt.  
  
 Ein verwalteter Zeiger auf diese Weise eingeschränkt werden, kann nur auf folgende Weise verwendet werden:  
  
-   Als die `object` -Parameter für die `ldfld`, `ldflda`, `stfld`, `call`, oder`constrained callvirt` Anweisungen.  
  
-   Als die `pointer` Parameter, um die `ldobj` Anweisung oder eines der `ldind` Anweisungen.  
  
-   Als die `source` Parameter, um die `cpobj` Anweisung.  
  
 Alle anderen Vorgänge nicht zulässig, einschließlich der `stobj`, `initobj`, oder `mkrefany` Vorgänge oder eines der `stind` Anweisungen.  
  
 Der Zweck der `readonly` Präfix ist, um eine typüberprüfung zu vermeiden, wenn Sie ein Element aus einem Array in generischem Code abrufen. Beispiel: der Ausdruck `arr[i].m()`, bei dem der Elementtyp des Arrays `arr` ist ein generischer Typ, der auf eine Schnittstelle mit der Methode eingeschränkt `m`, möglicherweise in der folgenden MSIL kompiliert.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Ohne die `readonly` Präfix, das `ldelema` Anweisung würde eine typüberprüfung ausführen, in dem Fall, in denen! 0 wurde ein Verweistyp. Nicht nur diese typüberprüfung ineffizient ist, aber es ist semantisch inkorrekt. Die typüberprüfung für `ldelema` ist eine genaue Übereinstimmung, die zu stark ist. Wenn das Array Unterklassen des Typs gehalten! 0, der obige Code würde die typüberprüfung fehlschlagen.  
  
 Die Adresse des Arrayelements abgerufen, statt dem Element selbst, um ein Handle für `arr[i]` funktioniert für sowohl Werttypen und Verweistypen und können daher übergeben werden, um die `constrained callvirt` Anweisung.  
  
 Im Allgemeinen ist es wäre unsicher, die die Laufzeit-Überprüfung übersprungen wird, wenn das Array die Elemente eines Referenztyps aufrechterhalten. Merken Sie sich, ist es erforderlich, um sicherzustellen, dass keine Änderungen in das Array über diesen Zeiger vorgenommen werden. Die Prüfregeln Vergewissern Sie sich der. Der eingeschränkte verwaltete Zeiger kann als Objekt der Instanz-Methodenaufrufen, übergeben werden, es ist nicht genau genommen nur Lesezugriff für Werttypen, aber es ist kein Typ Safety-Problem für Werttypen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `readonly` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Typtoken ab, das in einen typisierten Verweis eingebettet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Legt das Typtoken in einen typisierten Verweis gespeichert.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Werttyp-Verweis ist auf dem Stapel abgelegt.  
  
2.  Die typisierte Verweis aus dem Stapel per pop ausgelesen wird, und das entsprechende Typtoken abgerufen.  
  
3.  Das Typtoken wird auf dem Stapel abgelegt.  
  
 Ein typisierter Verweis enthält ein Typtoken und eine Adresse auf eine Objektinstanz.  
  
 Die `refanytype` Anweisung ruft das Typtoken ab in die typisierten Verweis eingebettet. Finden Sie unter den <xref:System.Reflection.Emit.OpCodes.Mkrefany> Anleitungen für die Informationen zum Erstellen von typisierten verweisen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `refanytype` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Adresse (Typ <see langword="&amp;" />) ab, die in einen typisierten Verweis eingebettet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|Legt die Adresse in einen typisierten Verweis gespeichert.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Werttyp-Verweis ist auf dem Stapel abgelegt.  
  
2.  Die typisierte Verweis aus dem Stapel per pop ausgelesen wird, und die entsprechende Adresse abgerufen.  
  
3.  Die Adresse wird auf dem Stapel abgelegt.  
  
 Ein typisierter Verweis enthält ein Typtoken und eine Adresse auf eine Objektinstanz.  
  
 Die `refanyval` -Anweisung ruft die Adresse, die in eingebetteten ab, der einen typisierten Verweis. Der Typ, die in der angegeben wird, auf dem Stapel typisierten Verweis eingebettet muss den vom angegebenen Typ übereinstimmen `type` (ein Metadatentoken, entweder eine `typedef` oder `typeref`). Finden Sie unter den <xref:System.Reflection.Emit.OpCodes.Mkrefany> -Anweisung.  
  
 <xref:System.InvalidCastException> wird ausgelöst, wenn `type` ist nicht identisch mit dem in der Typverweis gespeicherten Typ (in diesem Fall `type` wird die Klasse bereitgestellt die <xref:System.Reflection.Emit.OpCodes.Mkrefany> Anweisung, die erstellt, allerdings typisierten Verweis).  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn `type` wurde nicht gefunden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `refanyval` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dividiert zwei Werte und legt den Rest auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|5D|REM|Legt den Rest der Division `value1` von `value2` im Stapel.|  
  
> [!NOTE]
>  ### ReplaceThisText  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden vom Stapel und die restlichen geholt `value1` `div` `value2` berechnet.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 `result` = `value1` `rem` `value2` die folgenden Bedingungen erfüllt:  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`), und:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, Anmeldung (`result`) = Vorzeichen (`value1`), wobei `div` ist die Division-Anweisung, die in Richtung Null abgeschnitten.  
  
 Wenn `value2` ist 0 (null) oder `value1` unendlich, die das Ergebnis NaN ist ist. Wenn `value2` unendlich, ist das Ergebnis ist `value1` (negiert für `-infinity`).  
  
 Ganzzahloperationen lösen <xref:System.DivideByZeroException> Wenn `value2` ist 0 (null).  
  
 Beachten Sie, dass auf den Intel-basierten Plattformen eine <xref:System.OverflowException> wird ausgelöst, bei der Berechnung (Minint `rem` -1).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `rem` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dividiert zwei Werte ohne Vorzeichen und legt den Rest auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|5E|rem.un|Legt den Rest der Division ohne Vorzeichen `value1` von nicht signierten `value2` im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden vom Stapel und die restlichen geholt `value1` `div` `value2` berechnet.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 `result` = `value1` `rem.un` `value2` die folgenden Bedingungen erfüllt:  
  
 `result` = `value1` - `value2` X (`value1` `div.un` `value2`), und:  
  
 0 = `result`  <  `value2`, wobei `div.un` die Anweisung ist ohne Vorzeichen dividieren.  
  
 Die `rem.un` Anweisung berechnet `result` und per Pushvorgang auf den Stapel. `Rem.un` behandelt die Argumente als Ganzzahlen ohne Vorzeichen, während <xref:System.Reflection.Emit.OpCodes.Rem> behandelt werden als Ganzzahlen mit Vorzeichen.  
  
 `Rem.un` ist für Gleitkommazahlen nicht angegeben.  
  
 Ganzzahloperationen lösen <xref:System.DivideByZeroException> Wenn `value2` ist 0 (null).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `rem.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von der aktuellen Methode zurückgegeben und legt einen Rückgabewert (sofern vorhanden) vom Auswertungsstapel des Aufgerufenen auf dem Auswertungsstapel des Aufrufenden ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|2A|ret|Wird von Methode, die möglicherweise einen Wert zurückgibt.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der zurückgegebene Wert vom Auswertungsstapel aufgerufenen per pop ausgelesen wird.  
  
2.  Der zurückgegebene Wert, der in Schritt 1 erhaltenen ist in den Auswertungsstapel des Aufrufers mithilfe von Push übertragen.  
  
 Wenn der Rückgabewert nicht auf dem Auswertungsstapel des aufgerufenen vorhanden ist, wird kein Wert (keine Zustandswechsel für den aufgerufenen oder Aufrufer-Methode) zurückgegeben.  
  
 Der Typ des Rückgabewerts, bestimmt, ob ggf. die aktuelle Methode den Typ des Werts abgerufen werden, aus der oben im Stapel und kopiert wird auf den Stapel der Methode, die die aktuelle Methode aufgerufen. Dem Auswertungsstapel ab, für die aktuelle Methode muss bis auf den zurückzugebenden Wert leer sein.  
  
 Die `ret` Anweisung kann nicht verwendet werden, um das Steuerelement von übertragen einer`try`, `filter`, `catch`, oder `finally` Block. Innerhalb einer `try` oder `catch`, verwenden die <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung mit dem Ziel eine `ret` Anweisung, die außerhalb aller einschließenden Ausnahmeblöcke befindet. Da die `filter` und `finally` Blöcke sind logisch Teil der Behandlung von Ausnahmen und nicht die Methode, die in der ihr Code eingebettet wird, ordnungsgemäß generierten Microsoft Intermediate Language (MSIL)-Anweisungen führen keine Rückgabe aus innerhalb eine Methode ein `filter` oder `finally`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `ret` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst erneut die aktuelle Ausnahme aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FRONT-END-1A|Lösen Sie erneut aus|Löst erneut die aktuelle Ausnahme aus.|  
  
 Für diese Anweisung ist keine Zustandswechsel definiert.  
  
 Die `rethrow` Anweisung ist nur zulässig, innerhalb des Texts einer `catch` Handler. Löst die gleiche Ausnahme, die von diesem Handler abgefangen wurde.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `rethrow` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Verschiebt einen ganzzahligen Wert um eine angegebene Anzahl von Bits nach links, wobei die frei werdenden Stellen mit 0-Bits aufgefüllt werden, und legt das Ergebnis auf den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|62|shl|Verschiebt eine ganze Zahl auf der linken Seite (listeninfrastruktur Nullen).|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Wert wird auf dem Stapel abgelegt.  
  
2.  Die Menge der zu verschiebenden Bits wird auf dem Stapel abgelegt.  
  
3.  Die Anzahl der zu verschiebenden Bits und der Wert werden vom Stapel geholt. der Wert wird durch die angegebene Anzahl von Bits nach links verschoben werden.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `shl` Anweisung verschiebt den Wert (Typ `int32`, `int64` oder `native int`) um die angegebene Anzahl von Bits nach links. Die Anzahl der Bits ist ein Wert vom Typ `int32` oder `native int`. Der Rückgabewert ist nicht angegeben, wenn die Anzahl der zu verschiebenden Bits größer als oder gleich der Breite (in Bit) des angegebenen Wert ist.  
  
 `Shl` Fügt ein Bit 0 (null) in die niedrigste Position auf jede Schicht ein.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `shl` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Verschiebt einen ganzzahligen Wert um eine angegebene Anzahl von Bits nach rechts, wobei das Vorzeichen mitgeführt wird, und legt das Ergebnis auf den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|63|shr|Verschiebt eine ganze Zahl auf der rechten Seite (listeninfrastruktur anmelden).|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Wert wird auf dem Stapel abgelegt.  
  
2.  Die Menge der zu verschiebenden Bits wird auf dem Stapel abgelegt.  
  
3.  Die Anzahl der zu verschiebenden Bits und der Wert werden vom Stapel geholt. der Wert wird direkt durch die angegebene Anzahl von Bits verschoben.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `shr.un` Anweisung verschiebt den Wert (Typ `int32`, `int64` oder `native int`) um die angegebene Anzahl von Bits nach rechts. Die Anzahl der Bits ist ein Wert vom Typ `int32` oder `native int`. Der Rückgabewert ist nicht angegeben, wenn die Anzahl der zu verschiebenden Bits größer als oder gleich der Breite (in Bit) des angegebenen Wert ist.  
  
 `Shr` repliziert die höherer Ordnung bit für jede Schicht, die das Vorzeichen des der ursprüngliche Wert in der `result`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `shr` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Verschiebt einen ganzzahligen Wert ohne Vorzeichen um eine angegebene Anzahl von Bits nach rechts, wobei die frei werdenden Stellen mit 0-Bits aufgefüllt werden, und legt das Ergebnis auf den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|64|shr.un|Verschiebt eine ganze Zahl auf der rechten Seite (listeninfrastruktur Nullen).|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Wert wird auf dem Stapel abgelegt.  
  
2.  Die Menge der zu verschiebenden Bits wird auf dem Stapel abgelegt.  
  
3.  Die Anzahl der zu verschiebenden Bits und der Wert werden vom Stapel geholt. der Wert wird direkt durch die angegebene Anzahl von Bits verschoben.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `shr.un` Anweisung verschiebt den Wert (Typ `int32`, `int64` oder `native int`) um die angegebene Anzahl von Bits nach rechts. Die Anzahl der Bits ist ein Wert vom Typ `int32`, `int64` oder `native int`. Der Rückgabewert ist nicht angegeben, wenn die Anzahl der zu verschiebenden Bits größer als oder gleich der Breite (in Bit) des angegebenen Wert ist.  
  
 `Shr.un` Fügt eine Bit 0 (null) in die höchste Position in jeder Schicht an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `shr.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Größe eines bereitgestellten Werttyps in Bytes auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|"sizeof" `valType`|Legt die Größe in Bytes, der einen Werttyp als ein `unsigned int32`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Die Größe (in Bytes) des angegebenen Datentyps (`valType`) auf dem Stapel abgelegt wird.  
  
 `valType` muss ein Metadatentoken (eine `typeref` oder `typedef`), der einen Werttyp, einem Referenztyp oder einem generischen Typparameter angibt.  
  
 Für einen Verweistyp handelt ist die zurückgegebene Größe an, die Größe des einen Verweiswert des entsprechenden (4 Bytes auf 32-Bit-Systemen), geben Sie nicht die Größe der die Daten in Objekten, die von der Verweiswert bezeichnet. Ein generischer Typparameter kann nur im Text des Typs oder der definierenden Methode verwendet werden. Wenn dieser Typ oder eine Methode instanziiert wird, wird der generische Typparameter von einem Werttyp oder Verweistyp ersetzt.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `sizeof` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert den an der obersten Position des Auswertungsstapels befindlichen Wert im Argumentslot an einem angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg `num`|Holt den obersten Wert aus dem Stapel und speichert es im Argumentslot `num`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert derzeit an oberster Position im Stapel geholt und in Argumentslot platziert `num`.  
  
 Die `starg` Anweisung, holt einen Wert aus dem Stapel, und platziert sie im Argumentslot `num`. Der Typ des Werts muss den Typ des Arguments, gemäß der aktuellen Methodensignatur übereinstimmen.  
  
 Für Prozeduren, die eine Variable Argumentliste, kann die `starg` Anweisung kann nur auf die festen Argumente, nicht auf die in der Variable Teil der Signatur verwendet werden.  
  
 Der Wert beim Speichern in-Argumente, die einen ganzzahligen Wert, der kürzer als 4 Byte lange verkürzt werden, wie sie mit dem Argument aus dem Stapel verschoben. Gleitkommawerte sind von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die mit dem Argument verknüpft ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `starg` Opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert den an der obersten Position des Auswertungsstapels befindlichen Wert im Argumentslot an einem angegebenen Index, Kurzform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|Holt den obersten Wert aus dem Stapel und speichert es im Argumentslot `num`, Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Der Wert derzeit an oberster Position im Stapel geholt und in Argumentslot platziert `num`.  
  
 Die `starg.s` Anweisung, holt einen Wert aus dem Stapel, und platziert sie im Argumentslot `num`. Der Typ des Werts muss den Typ des Arguments, gemäß der aktuellen Methodensignatur übereinstimmen.  
  
 Die `starg.s` Anweisung bietet eine effiziente Codierung für die Verwendung mit den ersten 256 Argumenten.  
  
 Für Prozeduren, die eine Variable Argumentliste, kann die `starg.s` Anweisung kann nur auf die festen Argumente, nicht auf die in der Variable Teil der Signatur verwendet werden.  
  
 Der Wert beim Speichern in-Argumente, die einen ganzzahligen Wert, der kürzer als 4 Byte lange verkürzt werden, wie sie mit dem Argument aus dem Stapel verschoben. Gleitkommawerte sind von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die mit dem Argument verknüpft ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `starg.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den Wert im Auswertungsstapel, dessen Typ in der Anweisung angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und Microsoft intermediate Language (MSIL) Assembly-Format, sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem `typeTok`|Ersetzt das Arrayelement am angegebenen Index durch ein Wert vom Typ `typeTok` auf dem Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis auf ein Array, `array`, auf dem Stapel abgelegt wird.  
  
2.  Der Indexwert `index`, auf ein Element in `array` wird auf dem Stapel abgelegt.  
  
3.  Der Typ, der in der Anweisung angegebene Wert ist auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem` -Anweisung ersetzt den Wert des Elements am angegebenen nullbasierten Index in das eindimensionale Array `array` mit dem Wert. Der Wert weist den Typ, der das Token gemäß `typeTok` in der Anweisung.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stelem` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="native int" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|9|stelem.i|Ersetzt das Arrayelement am angegebenen Index durch den `native int` Werts im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis auf ein Array, `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf dem Stapel abgelegt.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.i` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `native int` Wert, der auf dem Stapel abgelegt.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stelem.i` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int8" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|9C|stelem. i1|Ersetzt das Arrayelement am angegebenen Index durch den `int8` Werts im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis auf ein Array, `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf dem Stapel abgelegt.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.i1` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `int8` Wert, der auf dem Stapel abgelegt.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stelem.i1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int16" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|9D|stelem. i2|Ersetzt das Arrayelement am angegebenen Index durch den `int16` Werts im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis auf ein Array, `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf dem Stapel abgelegt.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.i2` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `int16` Wert, der auf dem Stapel abgelegt.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stelem.i2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int32" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|9E|stelem. i4|Ersetzt das Arrayelement am angegebenen Index durch den `int32` Werts im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis auf ein Array, `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf dem Stapel abgelegt.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.i4` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `int32` Wert, der auf dem Stapel abgelegt.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stelem.i4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int64" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|9F|i8|Ersetzt das Arrayelement am angegebenen Index durch den `int64` Werts im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis auf ein Array, `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf dem Stapel abgelegt.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.i8` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `int64` Wert, der auf dem Stapel abgelegt.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stelem.i8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="float32" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|A0|stelem. r4|Ersetzt das Arrayelement am angegebenen Index durch den `float32` Werts im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis auf ein Array, `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf dem Stapel abgelegt.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.r4` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `float32` Wert, der auf dem Stapel abgelegt.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stelem.r4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="float64" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|A1|stelem. r8|Ersetzt das Arrayelement am angegebenen Index durch den `float64` Werts im Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis auf ein Array, `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf dem Stapel abgelegt.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.r8` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `float64` Wert, der auf dem Stapel abgelegt.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stelem.r8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den Wert des Objektverweises (Typ <see langword="O" />) im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|A2|stelem.ref|Ersetzt das Arrayelement am angegebenen Index durch den `ref` Wert (Typ `O`) auf dem Stapel.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis auf ein Array, `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf dem Stapel abgelegt.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.ref` -Anweisung ersetzt den Wert des Elements am angegebenen Index in das eindimensionale Array `array` mit der `ref` (Typ `O`) Wert, der auf dem Stapel abgelegt.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 Beachten Sie, dass `stelem.ref` wandelt implizit in der angegebenen Wert, der den Elementtyp des `array` bevor Sie den Wert des Array-Elements zuweisen. Diese Umwandlung kann fehlschlagen, sogar für überprüfte Code. Daher die `stelem.ref` Anweisung auslösen kann <xref:System.InvalidCastException>. Für eindimensionale Arrays, die nicht nullbasiert sind, und für mehrdimensionale Arrays, die <xref:System.Array> -Klasse stellt eine <xref:System.Array.SetValue%2A> Methode.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stelem.ref` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt den im Feld eines Objektsverweises oder Zeigers gespeicherten Wert durch einen neuen Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|Ersetzt den Wert des `field` des Objekts durch einen neuen Wert.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektsverweises oder Zeigers ist auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und Verweis/Objektzeiger werden vom Stapel geholt. der Wert des `field` im Objekt mit dem angegebenen Wert ersetzt wird.  
  
 Die `stfld` -Anweisung ersetzt den Wert eines Felds eines Objekts (Typ `O`) oder über einen Zeiger (Typ `native int`, `&`, oder `*`) mit einem angegebenen Wert. `Field` ist ein Metadatentoken, das auf den Verweis auf ein Element verweist. Die `stfld` -Anweisung kann eine oder beide der Präfix aufweisen <xref:System.Reflection.Emit.OpCodes.Unaligned> und <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn die Objektsverweises oder Zeigers ein null-Verweis ist, und das Feld nicht statisch.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn `field` wurde nicht in den Metadaten gefunden. Dies ist in der Regel aktiviert, wenn die Microsoft Intermediate Language (MSIL)-Anweisung in systemeigenen Code, nicht zur Laufzeit konvertiert wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stfld` Opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="native int" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|DF|stind.i|Speichert eine `native int` Wert einer angegebenen Adresse.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse, werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.i` -Anweisung speichert eine `native int` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.i` Anweisung verwendet werden, in Übereinstimmung mit dem Typ des Zeigers. Den Betrieb der `stind.i` Anweisung kann geändert werden, einen unmittelbar vorangehenden <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumenttyp durch das Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stind.i` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="int8" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|52|i1|Speichert ein `int8` Wert einer angegebenen Adresse.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse, werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.i1` -Anweisung speichert eine `int8` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.i1` Anweisung verwendet werden, in Übereinstimmung mit dem Typ des Zeigers. Den Betrieb der `stind.i1` Anweisung kann geändert werden, einen unmittelbar vorangehenden <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumenttyp durch das Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stind.i1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="int16" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|53|i2|Speichert ein `int16` Wert einer angegebenen Adresse.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse, werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.i2` -Anweisung speichert eine `int16` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.2i` Anweisung verwendet werden, in Übereinstimmung mit dem Typ des Zeigers. Den Betrieb der `stind.i2` Anweisung kann geändert werden, einen unmittelbar vorangehenden <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumenttyp durch das Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stind.i2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="int32" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|54|i4|Speichert ein `int32` Wert einer angegebenen Adresse.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse, werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.i4` -Anweisung speichert eine `int32` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.i4` Anweisung verwendet werden, in Übereinstimmung mit dem Typ des Zeigers. Den Betrieb der `stind.i4` Anweisung kann geändert werden, einen unmittelbar vorangehenden <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumenttyp durch das Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stind.i4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="int64" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|55|i8|Speichert ein `int64` Wert einer angegebenen Adresse.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse, werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.i8` -Anweisung speichert eine `int64` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.i8` Anweisung verwendet werden, in Übereinstimmung mit dem Typ des Zeigers. Den Betrieb der `stind.i` Anweisung kann geändert werden, einen unmittelbar vorangehenden <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumenttyp durch das Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stind.i8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="float32" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|56|R4|Speichert eine `float32` Wert einer angegebenen Adresse.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse, werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.r4` -Anweisung speichert eine `float32` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.r4` Anweisung verwendet werden, in Übereinstimmung mit dem Typ des Zeigers. Den Betrieb der `stind.r4` Anweisung kann geändert werden, einen unmittelbar vorangehenden <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumenttyp durch das Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stind.r4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="float64" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|57|r8|Speichert eine `float64` Wert einer angegebenen Adresse.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse, werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.r8` -Anweisung speichert eine `float64` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.r8` Anweisung verwendet werden, in Übereinstimmung mit dem Typ des Zeigers. Den Betrieb der `stind.r8` Anweisung kann geändert werden, einen unmittelbar vorangehenden <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumenttyp durch das Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stind.r8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Objektverweiswert an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|51|stind.ref|Speichert einen Objektverweis (Typ `O`) Wert einer angegebenen Adresse.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse, werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.ref` -Anweisung speichert einen Objektverweiswert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.ref` Anweisung verwendet werden, in Übereinstimmung mit dem Typ des Zeigers. Den Betrieb der `stind.ref` Anweisung kann geändert werden, einen unmittelbar vorangehenden <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumenttyp durch das Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stind.ref` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc `index`|Holt einen Wert aus dem Stapel, und speichert sie in der lokalen Variable `index`.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Wert vom Stapel geholt und in lokalen Variablen platziert `index`.  
  
 Die `stloc` Anweisung holt den obersten Wert vom Auswertungsstapel und verschiebt ihn in die lokale Variable Anzahl `index`, wobei der lokale Variablen oder höher 0 nummeriert sind. Der Typ des Werts muss den Typ der lokalen Variablen gemäß der aktuellen Methode lokale Signatur übereinstimmen.  
  
 Speichern in "lokal", die einen ganzzahliger Wert kleiner als 4 Bytes enthalten schneidet den Wert ab, wie vom Stapel auf die lokale Variable verschoben wird. Gleitkommawerte sind von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die mit dem Argument verknüpft ist.  
  
 Richtige Microsoft Intermediate Language (MSIL)-Anweisungen wird vorausgesetzt, die `index` ein gültiger lokaler Index sein. Für die `stloc` -Anweisung, `index` müssen liegen im Bereich von 0 bis 65534 inklusive (65535 ist kein gültiger Wert). Der Grund für das Ausschließen von 65535 ist pragmatische: wahrscheinliche Implementierungen werden eine 2-Byte-Ganzzahl verwenden, um sowohl eine lokale des Index als auch die Gesamtanzahl der lokal für eine angegebene Methode zu verfolgen. Wenn ein Index der 65535 gültig vorgenommen wurden hatte, müssten eine größere ganze Zahl, um die Anzahl der lokalen Variablen in einer solchen Methode nachzuverfolgen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `stloc` Opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|0A|stloc.0|Holt einen Wert aus dem Stapel in der lokalen Variablen 0.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Wert vom Stapel geholt und in der lokalen Variablen mit dem Index 0 platziert.  
  
 Die `stloc.0` Anweisung holt den obersten Wert vom Auswertungsstapel und verschiebt ihn in die lokale Variable mit dem Index 0. Der Typ des Werts muss den Typ der lokalen Variablen gemäß der aktuellen Methode lokale Signatur übereinstimmen.  
  
 `stloc.0` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variablen 0.  
  
 Speichern in "lokal", die einen ganzzahliger Wert kleiner als 4 Bytes enthalten schneidet den Wert ab, wie vom Stapel auf die lokale Variable verschoben wird. Gleitkommawerte sind von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die mit dem Argument verknüpft ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stloc.0` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|0 B|stloc. 1|Holt einen Wert aus dem Stapel in der lokalen Variablen 1 an.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Wert vom Stapel geholt und in der lokalen Variablen mit dem Index 1 platziert.  
  
 Die `stloc.1` Anweisung holt den obersten Wert vom Auswertungsstapel und verschiebt ihn in die lokale Variable mit dem Index 1. Der Typ des Werts muss den Typ der lokalen Variablen gemäß der aktuellen Methode lokale Signatur übereinstimmen.  
  
 `stloc.1` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variable 1.  
  
 Speichern in "lokal", die einen ganzzahliger Wert kleiner als 4 Bytes enthalten schneidet den Wert ab, wie vom Stapel auf die lokale Variable verschoben wird. Gleitkommawerte sind von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die mit dem Argument verknüpft ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stloc.1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|0C|stloc. 2|Holt einen Wert aus dem Stapel in der lokalen Variablen 2|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Wert vom Stapel geholt und in der lokalen Variablen mit dem Index 2 platziert.  
  
 Die `stloc.2` Anweisung holt den obersten Wert vom Auswertungsstapel und verschiebt ihn in die lokale Variable mit dem Index 2. Der Typ des Werts muss den Typ der lokalen Variablen gemäß der aktuellen Methode lokale Signatur übereinstimmen.  
  
 `stloc.2` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variable 2.  
  
 Speichern in "lokal", die einen ganzzahliger Wert kleiner als 4 Bytes enthalten schneidet den Wert ab, wie vom Stapel auf die lokale Variable verschoben wird. Gleitkommawerte sind von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die mit dem Argument verknüpft ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stloc.2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|0D|stloc. 3|Holt einen Wert aus dem Stapel in der lokalen Variablen 3|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Wert vom Stapel geholt und in der lokalen Variablen mit dem Index 3 platziert.  
  
 Die `stloc.3` Anweisung holt den obersten Wert vom Auswertungsstapel und verschiebt ihn in die lokale Variable mit dem Index 3. Der Typ des Werts muss den Typ der lokalen Variablen gemäß der aktuellen Methode lokale Signatur übereinstimmen.  
  
 `stloc.3` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variable 3.  
  
 Speichern in "lokal", die einen ganzzahliger Wert kleiner als 4 Bytes enthalten schneidet den Wert ab, wie vom Stapel auf die lokale Variable verschoben wird. Gleitkommawerte sind von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die mit dem Argument verknüpft ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stloc.3` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am <paramref name="index" /> (Kurzform).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|Holt einen Wert aus dem Stapel, und speichert sie in der lokalen Variable `index`, Kurzform.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Wert vom Stapel geholt und in lokalen Variablen platziert `index`.  
  
 Die `stloc.s` Anweisung holt den obersten Wert vom Auswertungsstapel und verschiebt ihn in die lokale Variable Anzahl `index`, wobei der lokale Variablen oder höher 0 nummeriert sind. Der Typ des Werts muss den Typ der lokalen Variablen gemäß der aktuellen Methode lokale Signatur übereinstimmen.  
  
 Die `stloc.s` Anweisung bietet eine effiziente Codierung für die lokalen Variablen von 0 bis 255.  
  
 Speichern in "lokal", die einen ganzzahliger Wert kleiner als 4 Bytes enthalten schneidet den Wert ab, wie vom Stapel auf die lokale Variable verschoben wird. Gleitkommawerte sind von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die mit dem Argument verknüpft ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `stloc.s` Opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert einen Wert mit dem angegebenen Typ vom Auswertungsstapel in die angegebene Speicheradresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Speichert einen Wert vom Typ `class` aus dem Stapel in den Arbeitsspeicher.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert Typ-Objekt des Typs `class` wird auf dem Stapel abgelegt.  
  
3.  Das Objekt und die Adresse, werden vom Stapel geholt. Das Typobjekt für den Wert wird an der Adresse gespeichert.  
  
 Die `stobj` -Anweisung kopiert das Werttypobjekt in die von der Adresse angegebene Adresse (einen Zeiger vom Typ `native int`, `*`, oder `&`). Die Anzahl der kopierten Bytes hängt von der Größe der durch dargestellten Klasse `class`, ein Metadatentoken, das einen Werttyp darstellt.  
  
 Den Betrieb der `stobj` Anweisung kann geändert werden, einen unmittelbar vorangehenden <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code nicht zur Laufzeit konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stobj` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt den Wert eines statischen Felds durch einen Wert vom Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Ersetzt den Wert in `field` mit einem angegebenen Wert.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Wert wird auf dem Stapel abgelegt.  
  
2.  Ein Wert vom Stapel geholt und in gespeicherten `field`.  
  
 Die `stsfld` Anweisung ersetzt den Wert eines statischen Felds durch einen Wert aus dem Stapel. `field` ist ein Metadatentoken, das auf einen Member von statischen Feld verweisen muss.  
  
 Die `stsfld` Anweisung kann das Präfix <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn Feld in den Metadaten nicht gefunden wird. Dies ist in der Regel aktiviert, wenn Microsoft Intermediate Language (MSIL)-Anweisungen nicht zur Laufzeit in nativen Code konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `stsfld` Opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrahiert einen Wert von einem anderen Wert und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|59|sub|Subtrahiert einen Wert aus einer anderen einen neuen numerischen Wert zurückgeben.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `value2` subtrahiert wird `value1`.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Überlauf ist nicht für Ganzzahloperationen (richtige Überlaufdaten, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Subtraktion der ganze Zahl, und nicht das Sättigungsverfahren. Z. B.: 8-Bit-Ganzzahlen, vorausgesetzt, in denen `value1` auf 0 festgelegt ist und `value2` festgelegt ist, 1, wird das Ergebnis "umschlossene" 255.  
  
 Gleitkommaüberlauf gibt `+inf` (`PositiveInfinity`) oder `-inf` (`NegativeInfinity`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `sub` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrahiert einen Ganzzahlwert von einem anderen Ganzzahlwert, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|DA|Sub.ovf|Subtrahiert einen Ganzzahlwert von einem anderen mit eine überlaufprüfung an.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `value2` subtrahiert wird `value1` durch eine Suche nach einem Überlauf.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Dieser Vorgang erfolgt an Ganzzahlen mit Vorzeichen; Verwenden Sie für Gleitkommawerte, <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `sub.ovf` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrahiert einen Ganzzahlwert ohne Vorzeichen von einem anderen Ganzzahlwert, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|DB|Sub.ovf.un|Subtrahiert einen Ganzzahlwert ohne Vorzeichen in einen anderen eine überlaufprüfung an.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus den Stapel geholt `value2` subtrahiert wird `value1` durch eine Suche nach einem Überlauf.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Dieser Vorgang erfolgt an Ganzzahlen mit Vorzeichen; Verwenden Sie für Gleitkommawerte, <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `sub.ovf.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implementiert eine Sprungtabelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` >< `int32` >... < `int32` >|Wechseln Sie (`N`, `t1`, `t2`... `tN`)|Wechselt zu einem der `N` Werte.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Wert wird auf dem Stapel abgelegt.  
  
2.  Der Wert wird vom Stapel geholt und für die Anweisung mit dem Offset ab, das durch den Wert Ausführung übertragen wird, ist, in denen der Wert kleiner als `N`.  
  
 Die `switch` Anweisung implementiert eine Sprungtabelle. Das Format der Anweisung ist ein `unsigned int32` , der die Anzahl von Zielen `N`, gefolgt von `N` Sprungziele für int32-Werten angeben. Diese Ziele werden als (positive oder negative) Offsets vom Anfang der folgenden Anweisung dies dargestellt `switch` Anweisung.  
  
 Die `switch` Anweisung, holt einen Wert aus dem Stapel, und vergleicht Sie ihn als ganze Zahl ohne Vorzeichen zu `N`. Wenn der Wert ist kleiner als `N`, Ausführung an das Ziel, die indiziert anhand des Werts übertragen wird, in denen Ziele von 0 nummeriert (z. B. der Wert 0 wird das erste Ziel, der Wert 1 wird das zweite Ziel und So weiter). Wenn der Wert größer als oder gleich `N`, die Ausführung wird fortgeführt, bei der nächsten Anweisung (fortfahren).  
  
 Wenn bei der zielinstruktion Codes für eine oder mehrere Präfix verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe.  
  
 Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden. (Solche Übertragungen sind stark eingeschränkt und müssen stattdessen die Anweisung Leave).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `switch` Opcode. Die `Label[]` Argument ist ein Array von Bezeichnungen, die 32-Bit-Offsets darstellen.  
  
-   ILGenerator.Emit (OpCode, Label[])  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der `Switch` Opcode zum Generieren einer Sprungtabelle ein Array von <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Führt eine Postfix-Methodenaufrufanweisung in der Weise aus, dass der Stapelrahmen der aktuellen Methode vor der Ausführung der eigentlichen Aufrufanweisung entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 14|"Tail".|Der nachfolgende Aufruf beendet den aktuelle Methoden|  
  
 Es gibt keine Zustandswechsel, die für diese Anweisung definiert.  
  
 Die `tail` präfixanweisung muss unmittelbar voranstehen eine <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, oder <xref:System.Reflection.Emit.OpCodes.Callvirt> Anweisung. Er gibt an, dass der Stapelrahmen der aktuellen Methode vor der Ausführung der aufrufanweisung entfernt werden soll. Es bedeutet auch, dass der von den folgenden Aufruf zurückgegebene Wert auch der Wert, der von der aktuellen Methode zurückgegeben ist, und der Aufruf aus diesem Grund in einen Sprung Cross-Methode konvertiert werden kann.  
  
 Der Stapel muss mit Ausnahme der Argumente, die durch den folgenden Aufruf übertragenen leer sein. Die aufrufanweisung folgenden muss es sich um einen Ret sein. Daher die Reihenfolge der einzige gültige Codes ist `tail. call` (oder `calli` oder `callvirt`). Richtige Microsoft Intermediate Language (MSIL)-Anweisungen nicht zur Verzweigen müssen die `call` Verzweigung zur die nachfolgenden Anweisungen, aber sie <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 Der aktuelle Frame kann nicht verworfen werden, wenn die Steuerung ist aus nicht vertrauenswürdigem Code an vertrauenswürdigem Code, da dies Code Identität und Sicherheit gefährden würde. Die .NET Framework-Sicherheit überprüft aus diesem Grund kann die `tail` ignoriert werden soll, eine verlassen <xref:System.Reflection.Emit.OpCodes.Call> Anweisung. Auf ähnliche Weise, in Reihenfolge zum Beenden einer auftritt, nachdem der Aufruf gibt einen synchronisierten Codebereich zulassen, wird die `tail` Präfix wird ignoriert, wenn verwendet, um eine Methode beendet wird, der als synchronisiert gekennzeichnet ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `tail` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Eine Instanz eines eines Opcodeobjekts.</param>
        <summary>Gibt TRUE oder FALSE zurück, wenn der bereitgestellte Opcode ein Einzelbyte-Argument akzeptiert.</summary>
        <returns>
          <see langword="True" /> oder <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um zu ermitteln, welche MSIL-Opcodes "Kurzform", für die Verwendung in optimiertem Code.  
  
 `TakesSingleByteArgument` Gibt `true` Wenn die <xref:System.Reflection.Emit.OpCode> Instanz akzeptiert ein einzelnes Byte-Argument in den folgenden Fällen:  
  
-   Der Opcode führt eine branchanweisung an eine Adresse Byte-Format (z. B. <xref:System.Reflection.Emit.OpCodes.Br_S> und <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   Der Opcode legt einen Byte-Wert im Stapel (z. B. <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   Der Opcode verweist auf eine Variable oder ein Argument über die "Kurzform" (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloc_S> und <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 Andernfalls wird `false` zurückgegeben.  
  
 Das folgende Beispiel zeigt die Verwendung von `TakesSingleByteArgument` durch das spiegeln sich beim der `OpCodes` -Klasse, und testen, ob jede `OpCode` Feld akzeptiert ein Einzelbyte-Argument.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst das Ausnahmeobjekt aus, das sich momentan auf dem Auswertungsstapel befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|7A|throw|Löst eine Ausnahme aus.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Objektverweis (auf einer Ausnahme) wird auf dem Stapel abgelegt.  
  
2.  Der Objektverweis aus dem Stapel und die ausgelöste Ausnahme per pop ausgelesen wird.  
  
 Die `throw` Anweisung wird ein Ausnahmeobjekt (Typ `O`) derzeit auf dem Stapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn der Objektverweis null-Verweis ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `throw` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass eine Adresse, die sich momentan oben auf dem Stapel befindet, möglicherweise nicht an der eigentlichen Größe der unmittelbar darauf folgenden <see langword="ldind" />-Anweisung, <see langword="stind" />-Anweisung, <see langword="ldfld" />-Anweisung, <see langword="stfld" />-Anweisung, <see langword="ldobj" />-Anweisung, <see langword="stobj" />-Anweisung, <see langword="initblk" />-Anweisung oder <see langword="cpblk" />-Anweisung ausgerichtet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 12 < `unsigned int8` >|nicht ausgerichtete. `alignment`|Gibt an, dass die nachfolgende-Anweisung nicht ausgerichtete werden kann.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
 `Unaligned` Gibt an, dass die Adresse (einen nicht verwalteten Zeiger, `native int`) auf dem Stapel möglicherweise nicht ausgerichtet an der eigentlichen Größe der unmittelbar darauf folgenden `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, oder `cpblk` Anweisung. D. h. für eine <xref:System.Reflection.Emit.OpCodes.Ldind_I4> Anweisung, die die Ausrichtung der Adresse möglicherweise nicht mit einer 4-Byte-Grenze. Für `initblk` und `cpblk` die standardausrichtung ist abhängige-Architektur (4-Byte für 32-Bit-CPUs, 8 Bytes auf 64-Bit-CPUs). Code-Generatoren, die nicht die Ausgabe auf einer 32-Bit-Wort-Größe beschränken müssen verwenden `unaligned` , wenn die Ausrichtung zum Zeitpunkt der Kompilierung nicht bekannt ist, um 8 Bytes beträgt.  
  
 Der Wert der Ausrichtung muss 1, 2 oder 4 und bedeutet, die der generierte Code, dass die Adresse Byte, Doppelbyte-Quad-Byte-ausgerichtet, bzw. davon ausgehen soll. Beachten Sie, dass flüchtige Zeiger (Typ `*`) werden immer ausgerichtet.  
  
 Während die Ausrichtung für ein `cpblk` Anweisung müssten logisch zwei Zahlen (eine für die Quelle) und eine für das Ziel, ist es keine wahrnehmbaren Auswirkungen auf die Leistung, wenn nur die niedrigere Zahl angegeben wird.  
  
 Die `unaligned` und `volatile` Präfixe können in beliebiger Reihenfolge kombiniert werden. Sie müssen unmittelbar voranstehen eine `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, oder `cpblk` Anweisung. Nur die <xref:System.Reflection.Emit.OpCodes.Volatile> Präfix ist zulässig, für die <xref:System.Reflection.Emit.OpCodes.Ldsfld> und <xref:System.Reflection.Emit.OpCodes.Stsfld> Anweisungen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `unaligned` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
-   ILGenerator.Emit(Opcode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert die Darstellung eines mittels Boxing gepackten Werttyps in seine mittels Unboxing entpackte Entsprechung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|79 < `T` >|mittels Unboxing zu konvertieren `valType`|Extrahiert die Daten für die Wert von `obj`, die geschachtelte Darstellung.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Es ist ein Objektverweis auf dem Stapel abgelegt.  
  
2.  Der Objektverweis ist vom Stapel geholt und mittels Unboxing zurückkonvertiert, um einen Werttypzeiger.  
  
3.  Der Zeigertyp Wert wird auf dem Stapel abgelegt.  
  
 Ein Werttyp verfügt über zwei separate Darstellungen in der Common Language Infrastructure (CLI):  
  
-   Eine "raw" Form verwendet, wenn ein Werttyp in ein anderes Objekt eingebettet ist.  
  
-   Ein "geschachtelte" Formular, in denen die Daten in den Werttyp in ein Objekt umschlossen (geschachtelt) ist, sodass es als unabhängige Einheit vorhanden ist.  
  
 Die `unbox` -Anweisung konvertiert den Objektverweis (Typ `O`), wird die geschachtelte Darstellung eines Werttyps, um einen Werttypzeiger (einen verwalteten Zeiger, Typ `&`), die nicht geschachtelte Form. Der angegebene Werttyp (`valType`) ist ein Metadatentoken, das den Typ eines Werttyps innerhalb des geschachtelten Objekts angibt.  
  
 Im Gegensatz zu <xref:System.Reflection.Emit.OpCodes.Box>, die erforderlich ist, um eine Kopie eines Werttyps, für die Verwendung im-Objekt erstellen `unbox` ist nicht erforderlich, um den Werttyp aus dem Objekt zu kopieren. In der Regel berechnet einfach die Adresse des Werttyps, der bereits in das geschachtelte Objekt vorhanden ist.  
  
 <xref:System.InvalidCastException> wird ausgelöst, wenn das Objekt nicht als geschachtelt ist `valType`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn der Objektverweis null-Verweis ist.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn der Werttyp `valType` wurde nicht gefunden. Dies wird in der Regel erkannt, wenn Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code anstelle einer zur Laufzeit konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `unbox` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert die geschachtelte Darstellung eines n der Anweisung angegebenen Typs in seine nicht geschachtelte Form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und Microsoft intermediate Language (MSIL) Assembly-Format, sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|A5 < `T` >|unbox.Any `typeTok`|Extrahieren Sie die Daten aus `obj`, die geschachtelte Darstellung.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Ein Verweis auf eine `obj` wird auf dem Stapel abgelegt.  
  
2.  Der Objektverweis ist vom Stapel geholt und mittels Unboxing zurückkonvertiert, in den Typ in der Anweisung angegeben.  
  
3.  Der resultierende Typ von Objekt Verweis- oder Werttyp wird auf dem Stapel abgelegt.  
  
 Bei Anwendung auf die geschachtelte Form von ein Werttyp, der `unbox.any` Anweisung extrahiert den Wert, der in enthaltenen `obj` (des Typs `O`), und ist daher gleichbedeutend mit `unbox` gefolgt von `ldobj`.  
  
 Bei Anwendung auf einen Verweistyp handelt, die `unbox.any` Anweisung hat dieselbe Wirkung wie das `castclass` `typeTok`.  
  
 Wenn der Operand `typeTok` ein generischen Typparameter angegeben wird, ist, und klicken Sie dann das Laufzeitverhalten durch den Typ bestimmt wird, die für den generischen Typparameter angegeben wird.  
  
 <xref:System.InvalidCastException> wird ausgelöst, wenn `obj` ist kein geschachtelter Typ.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `obj` ist ein null-Verweis.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `unbox.any` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass es sich bei einer Adresse, die sich momentan oben auf dem Auswertungsstapel befindet, möglicherweise um eine flüchtige Adresse handelt und daher die aus diesem Speicherort gelesenen Ergebnisse nicht zwischengespeichert werden können oder mehrere für diesen Speicherort ausgeführte Speichervorgänge nicht unterdrückt werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 13|flüchtige.|Gibt an, dass die nachfolgenden Zeigerverweis "volatile" ist.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
 `volatile` Gibt an, dass die Adresse eine flüchtige Adresse handelt (d. h. es kann von außen für den aktuellen Thread der Ausführung verwiesen werden) und die Ergebnisse zu lesen, dass nicht zwischengespeichert werden können oder mehrere Speicher für diesen Speicherort nicht unterdrückt werden können. Markieren eines Zugriffs als `volatile` wirkt sich auf, die Zugriff aus; andere Zugriffe auf den gleichen Speicherort müssen separat markiert werden. Zugriff auf flüchtige Speicherorte muss nicht atomar ausgeführt werden.  
  
 Die <xref:System.Reflection.Emit.OpCodes.Unaligned> und `volatile` Präfixe können in beliebiger Reihenfolge kombiniert werden. Sie müssen unmittelbar voranstehen eine `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, oder `cpblk` Anweisung. Nur die `volatile` Präfix ist zulässig, für die <xref:System.Reflection.Emit.OpCodes.Ldsfld> und <xref:System.Reflection.Emit.OpCodes.Stsfld> Anweisungen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `volatile` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Berechnet das bitweise XOR der beidem auf dem Stapel an oberster Position befindlichen Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die hexadezimale und das Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz-Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|61|xor|Berechnet das bitweise XOR mit zwei ganzzahligen Werten und gibt eine ganze Zahl zurück.|  
  
 Im Stapel-laufen, wird in der angegebenen Reihenfolge:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden per pop ausgelesen, aus dem Stapel und die bitweise XOR berechnet.  
  
4.  Das bitweise XOR der `value2` und `value1` wird auf dem Stapel abgelegt.  
  
 Die `xor` -Anweisung berechnet das bitweise XOR für die beiden obersten Werte im Stapel und das Ergebnis auf dem Stapel verbleibt.  
  
 `Xor` ist ein Vorgang für die ganze Zahlen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Überladung der Methode verwendet die `xor` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>