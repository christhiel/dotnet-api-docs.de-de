<Type Name="ActionBlock&lt;TInput&gt;" FullName="System.Threading.Tasks.Dataflow.ActionBlock&lt;TInput&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d89b1377e3f2a4d02c59674bfa7852f50c254e81" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52604777" /></Metadata><TypeSignature Language="C#" Value="public sealed class ActionBlock&lt;TInput&gt; : System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ActionBlock`1&lt;TInput&gt; extends System.Object implements class System.Threading.Tasks.Dataflow.IDataflowBlock, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!TInput&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.ActionBlock`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ActionBlock(Of TInput)&#xA;Implements ITargetBlock(Of TInput)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TInput&gt;&#xA;public ref class ActionBlock sealed : System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt;" />
  <TypeSignature Language="F#" Value="type ActionBlock&lt;'Input&gt; = class&#xA;    interface IDataflowBlock&#xA;    interface ITargetBlock&lt;'Input&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TInput" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IDataflowBlock</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebuggerDisplayContent,nq}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.Dataflow.ActionBlock`1/DebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TInput">Der Datentyp, auf dem dieser <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> betrieben wird.</typeparam>
    <summary>Stellt einen Datenflussblock bereit, der einen bereitgestellten <see cref="T:System.Action`1" />-Delegaten für jede empfangene Datenelement aufruft.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Klasse, um mehrere Datenflussblöcke mit Berechnungen auszuführen, und gibt die verstrichene Zeit, die zum Ausführen von Berechnungen erforderlich sind. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die [Vorgehensweise: Angeben des Grads der Parallelität in einem Dataflow Block](~/docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md) Thema.  
  
 [!code-csharp[TPLDataflow_DegreeOfParallelism#2](~/samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_degreeofparallelism/cs/dataflowdegreeofparallelism.cs#2)]
 [!code-vb[TPLDataflow_DegreeOfParallelism#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_degreeofparallelism/vb/dataflowdegreeofparallelism.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ActionBlock (Action&lt;TInput&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;!TInput&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.ActionBlock`1.#ctor(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of TInput))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ActionBlock(Action&lt;TInput&gt; ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt; : Action&lt;'Input&gt; -&gt; System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt;" Usage="new System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt; action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;TInput&gt;" />
      </Parameters>
      <Docs>
        <param name="action">Die Aktion, die für jedes empfangene Datenelement aufzurufen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" />-Klasse mit der angegebenen Aktion.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ActionBlock (Func&lt;TInput,System.Threading.Tasks.Task&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;!TInput, class System.Threading.Tasks.Task&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.ActionBlock`1.#ctor(System.Func{`0,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Func(Of TInput, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ActionBlock(Func&lt;TInput, System::Threading::Tasks::Task ^&gt; ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt; : Func&lt;'Input, System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt;" Usage="new System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt; action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Func&lt;TInput,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="action">Die Aktion, die für jedes empfangene Datenelement aufzurufen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" />-Klasse mit der angegebenen Aktion.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ActionBlock (Action&lt;TInput&gt; action, System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;!TInput&gt; action, class System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.ActionBlock`1.#ctor(System.Action{`0},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of TInput), dataflowBlockOptions As ExecutionDataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ActionBlock(Action&lt;TInput&gt; ^ action, System::Threading::Tasks::Dataflow::ExecutionDataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt; : Action&lt;'Input&gt; * System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions -&gt; System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt;" Usage="new System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt; (action, dataflowBlockOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;TInput&gt;" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" />
      </Parameters>
      <Docs>
        <param name="action">Die Aktion, die für jedes empfangene Datenelement aufzurufen.</param>
        <param name="dataflowBlockOptions">Die Optionen, mit denen dieser <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> zu konfigurieren ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" />-Klasse mit der angegebenen Aktion und den Konfigurationsoptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.Tasks.Dataflow.ActionBlock%601.%23ctor%28System.Action%7B%600%7D%2CSystem.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions%29> Konstruktor zum Erstellen eines neuen <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> Objekt. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die [Vorgehensweise: Angeben des Grads der Parallelität in einem Dataflow Block](~/docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md) Thema.  
  
 [!code-csharp[TPLDataflow_DegreeOfParallelism#2](~/samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_degreeofparallelism/cs/dataflowdegreeofparallelism.cs#2)]
 [!code-vb[TPLDataflow_DegreeOfParallelism#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_degreeofparallelism/vb/dataflowdegreeofparallelism.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="dataflowBlockOptions" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ActionBlock (Func&lt;TInput,System.Threading.Tasks.Task&gt; action, System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;!TInput, class System.Threading.Tasks.Task&gt; action, class System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.ActionBlock`1.#ctor(System.Func{`0,System.Threading.Tasks.Task},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Func(Of TInput, Task), dataflowBlockOptions As ExecutionDataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ActionBlock(Func&lt;TInput, System::Threading::Tasks::Task ^&gt; ^ action, System::Threading::Tasks::Dataflow::ExecutionDataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt; : Func&lt;'Input, System.Threading.Tasks.Task&gt; * System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions -&gt; System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt;" Usage="new System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt; (action, dataflowBlockOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Func&lt;TInput,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" />
      </Parameters>
      <Docs>
        <param name="action">Die Aktion, die für jedes empfangene Datenelement aufzurufen.</param>
        <param name="dataflowBlockOptions">Die Optionen, mit denen dieser <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" /> zu konfigurieren ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Tasks.Dataflow.ActionBlock`1" />-Klasse mit der angegebenen Aktion und den Konfigurationsoptionen.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="dataflowBlockOptions" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Complete">
      <MemberSignature Language="C#" Value="public void Complete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Complete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.ActionBlock`1.Complete" />
      <MemberSignature Language="VB.NET" Value="Public Sub Complete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Complete();" />
      <MemberSignature Language="F#" Value="abstract member Complete : unit -&gt; unit&#xA;override this.Complete : unit -&gt; unit" Usage="actionBlock.Complete " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signalisiert dem Datenflussblock, dass er keine weiteren Nachrichten mehr akzeptieren oder erstellen und keine weiteren hinausgeschobenen Nachrichten mehr verarbeiten soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem <xref:System.Threading.Tasks.Dataflow.ActionBlock%601.Complete%2A> wurde für einen Datenflussblock aufgerufen wird, wird dieser Block abgeschlossen (so, dass die <xref:System.Threading.Tasks.Dataflow.ActionBlock%601.Completion%2A> Aufgabe wird einen abschließenden Zustand versetzt) Nachdem sie alle zuvor verfügbare Daten verarbeitet hat. Diese Methode blockiert warten auf Abschluss vorgenommen wird, nicht aber die Anforderung initiiert. Um auf den Abschluss auftreten zu warten, verwenden die <xref:System.Threading.Tasks.Dataflow.ActionBlock%601.Completion%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.Threading.Tasks.Dataflow.ActionBlock%601.Complete%2A> Methode, um der Datenflussblock zu signalisieren, dass sie akzeptieren oder erstellen keine weiteren Nachrichten noch weiteren hinausgeschobenen Nachrichten sollte nicht. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die [Vorgehensweise: Angeben des Grads der Parallelität in einem Dataflow Block](~/docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md) Thema.  
  
 [!code-csharp[TPLDataflow_DegreeOfParallelism#2](~/samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_degreeofparallelism/cs/dataflowdegreeofparallelism.cs#2)]
 [!code-vb[TPLDataflow_DegreeOfParallelism#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_degreeofparallelism/vb/dataflowdegreeofparallelism.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completion">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task Completion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Task Completion" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.ActionBlock`1.Completion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Completion As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Task ^ Completion { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Completion : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt;.Completion" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.Tasks.Task" />-Objekt ab, das den asynchronen Vorgang und die Beendigung des Datenflussblocks darstellt.</summary>
        <value>Die abgeschlossene Aufgabe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Datenflussblock gilt als abgeschlossen, wenn er nicht gerade verarbeitet, eine Nachricht, und wenn diese garantiert, dass es keine weiteren Nachrichten nicht verarbeitet werden. Das zurückgegebene <xref:System.Threading.Tasks.Task> Übergang in Status "abgeschlossen" wird, wenn der zugeordnete Block abgeschlossen ist. Es erfolgt ein Wechsel in den <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status, wenn der Block die Verarbeitung gemäß des datenflussblocks erfolgreich abgeschlossen ist, definierte Semantik. Es erfolgt ein Wechsel in den <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, wenn der Datenflussblock Verarbeitung vorzeitig aufgrund einer nicht behandelten Ausnahme abgeschlossen ist, und es ein in Wechsel erfolgt die <xref:System.Threading.Tasks.TaskStatus.Canceled> Status, wenn der Datenflussblock vorzeitig nach Verarbeitung abgeschlossen ist empfängt eine abbruchanforderung. Wenn die Aufgabe abgeschlossen, in ist der <xref:System.Threading.Tasks.TaskStatus.Faulted> Zustand, der `Exception` -Eigenschaft gibt ein <xref:System.AggregateException> Ausnahme, die eine oder mehrere Ausnahmen, die der Block enthält, um die Fehler verursacht hat.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.Tasks.Dataflow.ActionBlock%601.Completion%2A> Eigenschaft warten, bis alle Nachrichten im gesamten Netzwerk weitergegeben. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die [Vorgehensweise: Angeben des Grads der Parallelität in einem Dataflow Block](~/docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md) Thema.  
  
 [!code-csharp[TPLDataflow_DegreeOfParallelism#2](~/samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_degreeofparallelism/cs/dataflowdegreeofparallelism.cs#2)]
 [!code-vb[TPLDataflow_DegreeOfParallelism#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_degreeofparallelism/vb/dataflowdegreeofparallelism.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputCount">
      <MemberSignature Language="C#" Value="public int InputCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InputCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.ActionBlock`1.InputCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InputCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.InputCount : int" Usage="System.Threading.Tasks.Dataflow.ActionBlock&lt;'Input&gt;.InputCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Eingabeelemente ab, die darauf warten, von diesem Block verarbeitet zu werden.</summary>
        <value>Die Anzahl der Eingabeelemente, die darauf warten, von diesem Block verarbeitet zu werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Dataflow.ActionBlock%601.InputCount%2A> enthält keine Elemente, die derzeit vom Block verarbeitet werden und alle Elemente, die bereits vom Block verarbeitet wurden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Post">
      <MemberSignature Language="C#" Value="public bool Post (TInput item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Post(!TInput item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.ActionBlock`1.Post(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Post (item As TInput) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Post(TInput item);" />
      <MemberSignature Language="F#" Value="member this.Post : 'Input -&gt; bool" Usage="actionBlock.Post item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TInput" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das dem Ziel bereitgestellt wird.</param>
        <summary>Stellt ein Element in den Zieldatenflussblock.</summary>
        <returns><see langword="true" />, wenn das Element dem Datenflussblock bereitgestellt wird; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Threading.Tasks.Dataflow.ActionBlock%601.Post%2A> Methode, um ein Element, das den zieldatenflussblock zu veröffentlichen. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die [Vorgehensweise: Angeben des Grads der Parallelität in einem Dataflow Block](~/docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md) Thema.  
  
 [!code-csharp[TPLDataflow_DegreeOfParallelism#2](~/samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_degreeofparallelism/cs/dataflowdegreeofparallelism.cs#2)]
 [!code-vb[TPLDataflow_DegreeOfParallelism#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_degreeofparallelism/vb/dataflowdegreeofparallelism.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.IDataflowBlock.Fault">
      <MemberSignature Language="C#" Value="void IDataflowBlock.Fault (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.ActionBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception ^ exception) = System::Threading::Tasks::Dataflow::IDataflowBlock::Fault;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(System.Exception)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Die Ausnahme, die den Fehler verursacht hat.</param>
        <summary>Veranlasst den Datenflussblock, in einem fehlgeschlagenen Zustand abzuschließen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A> wurde für einen Datenflussblock aufgerufen wird, wird dieser Block abgeschlossen und die zugehörige <xref:System.Threading.Tasks.Dataflow.ActionBlock%601.Completion%2A> Aufgabe wird einen abschließenden Zustand versetzt. Fehler von einem Block, wird als mit Abbrechen eines Blocks gepufferte Nachrichten (nicht verarbeitet eingehende Nachrichten sowie unoffered ausgabemeldungen) verloren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="exception" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;.OfferMessage">
      <MemberSignature Language="C#" Value="System.Threading.Tasks.Dataflow.DataflowMessageStatus ITargetBlock&lt;TInput&gt;.OfferMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, TInput messageValue, System.Threading.Tasks.Dataflow.ISourceBlock&lt;TInput&gt; source, bool consumeToAccept);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Threading.Tasks.Dataflow.DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;.OfferMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, !TInput messageValue, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!TInput&gt; source, bool consumeToAccept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.ActionBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock&lt;TInput&gt;#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function OfferMessage (messageHeader As DataflowMessageHeader, messageValue As TInput, source As ISourceBlock(Of TInput), consumeToAccept As Boolean) As DataflowMessageStatus Implements ITargetBlock(Of TInput).OfferMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Threading::Tasks::Dataflow::DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;.OfferMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, TInput messageValue, System::Threading::Tasks::Dataflow::ISourceBlock&lt;TInput&gt; ^ source, bool consumeToAccept) = System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt;::OfferMessage;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.DataflowMessageStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="messageValue" Type="TInput" />
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TInput&gt;" />
        <Parameter Name="consumeToAccept" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="messageHeader">Der Header der Nachricht, die bereitgestellt wird.</param>
        <param name="messageValue">Der Wert der Nachricht, die bereitgestellt wird.</param>
        <param name="source">Der Datenflussblock, der die Meldung angezeigt. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="consumeToAccept"><see langword="true" />, um das Ziel anzuweisen, <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> während des Aufrufs von <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" /> vor der Rückgabe von <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> zur Verarbeitung der Meldung synchron aufzurufen; andernfalls <see langword="false" />.</param>
        <summary>Gibt dem Datenflussblock eine Meldung und gibt ihm die Möglichkeit, die Meldung zu verarbeiten oder hinauszuschieben.</summary>
        <returns>Der Status der angebotenen Meldung.  Wenn die Meldung vom Ziel akzeptiert wurde, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> zurückgegeben, und die Quelle sollte die angebotene Meldung nicht mehr verwenden, da sie jetzt dem Ziel gehört. Wenn die Nachricht vom Ziel zurückgestellt wurde, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> als Benachrichtigung zurückgegeben, dass das Ziel später möglicherweise versucht, die Nachricht zu verarbeiten oder zu reservieren. Zwischenzeitlich besitzt die Quelle die Nachricht weiterhin und bietet sie möglicherweise anderen Blöcke an.  
  
Wenn das Ziel andernfalls die Meldung zurückgestellt hätte, aber die Quelle <see langword="null" /> war, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> zurückgegeben.  
  
Wenn das Ziel versucht hat, die Nachricht zu akzeptieren, diese aber verpasst hat, weil die Quelle die die Meldung an ein anderes Ziel übermittelt oder einfach verworfen hat, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" /> zurückgegeben.  
  
Wenn das Ziel beschlossen hat, die Nachricht nicht zu akzeptieren, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> zurückgegeben. Wenn das Ziel beschlossen hat, die Meldung nicht zu akzeptieren und niemals eine weitere Meldung von dieser Quelle akzeptieren wird, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" /> zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="messageHeader" /> ist nicht gültig.  
  
oder <paramref name="consumeToAccept" /> kann nur <see langword="true" /> sein, wenn eine <paramref name="source" /> bereitgestellt wird, die nicht NULL ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.ActionBlock`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="actionBlock.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den formatierten Namen dieser <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />-Instanz darstellt.</summary>
        <returns>Eine Zeichenfolge, die den formatierten Namen dieser <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />-Instanz darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird von <xref:System.Object> geerbt. Verwendet die <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat%2A> Option.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>