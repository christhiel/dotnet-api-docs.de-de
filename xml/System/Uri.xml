<Type Name="Uri" FullName="System.Uri">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e57abd24f10515ff720515a9211a07818123afd9" /><Meta Name="ms.sourcegitcommit" Value="19b66619a469ee45c85c618f8a605859882eb638" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/10/2019" /><Meta Name="ms.locfileid" Value="54183888" /></Metadata><TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Uri = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Objektdarstellung eines URIs (Uniform Resource Identifier) und einfachen Zugriff auf die Teile des URIs bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein URI ist eine kompakte Darstellung einer Ressource für Ihre Anwendung sich im Intranet oder Internet verfügbar. Die <xref:System.Uri> -Klasse definiert die Eigenschaften und Methoden für die Behandlung von Analyse, vergleichen und Kombinieren von URIs. Die <xref:System.Uri> Eigenschaften der Klasse schreibgeschützt sind; verwenden Sie zum Erstellen eines änderbaren-Objekts, das <xref:System.UriBuilder> Klasse.  
  
 Relative URIs (z. B. "/ /New/Index.htm") muss in Bezug auf die Basis-URI erweitert werden, damit sie absolut sind. Die <xref:System.Uri.MakeRelative%2A> Methode wird bereitgestellt, um absolute URIs zu relativen URIs, die bei Bedarf zu konvertieren.  
  
 Die <xref:System.Uri> Konstruktoren nicht mit einem Escapezeichen URI-Zeichenfolgen, die Zeichenfolge ist kein ordnungsgemäß formatierter URI einschließlich Schemabezeichner.  
  
 Die <xref:System.Uri> Eigenschaften geben eine kanonische datendarstellung zurück, mit Escapezeichen der Codierung mit allen Zeichen mit Unicode-Werten, die größer als 127, die durch die entsprechenden Hexadezimalwerte ersetzt. Den URI in kanonische Form Einfügen der <xref:System.Uri> Konstruktor führt die folgenden Schritte aus:  
  
-   Das URI-Schema konvertiert in Kleinbuchstaben.  
  
-   Konvertiert den Namen des Hosts in Kleinbuchstaben.  
  
-   Wenn der Hostname eine IPv6-Adresse ist, wird die kanonische IPv6-Adresse verwendet. ' ScopeId ' und andere optionalen IPv6-Daten werden entfernt.  
  
-   Entfernt Standard und leere Portnummern.
  
-   Implizite Dateipfade ohne file:// Scheme (z. B. "C:\my\file") konvertiert in explizite Dateipfade mit file:// Scheme.
  
-   Escapezeichen (auch bekannt als Prozentwert codiert Oktette), die einen reservierten Zweck haben werden decodiert (auch bekannt als wird entfernt). Diese nicht reservierten Zeichen sind Großbuchstaben und Kleinbuchstaben (% 41 % 5A "und" 61 % 7A), Dezimalstellen (30-% 39), Bindestrich (% 2D), Punkt (% 2E), Unterstrich (% 5F) und die Tilde (% 7E).

-   Kanonisiert den Pfad für hierarchische URIs indem Sequenzen wie z. B. /. / /... /- und / / (unabhängig davon, ob die Sequenz wird mit Escapezeichen versehen). Beachten Sie, dass einige Schemas, die für die diese Sequenzen nicht komprimiert werden.
  
-   Für hierarchische URIs Wenn der Host nicht beendet wird, mit einem Schrägstrich (/), wird eines hinzugefügt.  
  
-   Standardmäßig werden im URI reservierten Zeichen in Übereinstimmung mit RFC 2396 mit Escapezeichen versehen. Dieses Verhalten ändert sich, wenn International Resource Identifiers "oder" internationale Domänenname Analyse die Groß-/Kleinschreibung reservierten Zeichen im URI aktiviert ist werden in Übereinstimmung mit RFC 3986 und RFC 3987 mit Escapezeichen versehen.

 Als Teil der Kanonisierung im Konstruktor für einige Schemas, Punkt-zu-Segmente und leere Segmente (/. / /... /- und / /), werden komprimiert (das heißt, sie werden entfernt). Die Schemas für die URI diese Sequenzen komprimiert, sind http, Https, Tcp, net.pipe und net.tcp. Bei einigen anderen Schemas werden diese Sequenzen nicht komprimiert. Hier ist, wie diese durch das Komprimieren in der Praxis aussieht.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 Wenn dieser Code ausgeführt wird, wird die folgende Ausgabe, mit dem Escapezeichen Sequenzen ohne Escapezeichen, falls erforderlich, und klicken Sie dann komprimiert zurückgegeben.

```  
http://myUrl/  
/  
```  
  
 Sie können den Inhalt der Transformieren der <xref:System.Uri> Klasse durch einen Escapezeichen codierten URI-Verweis auf einen lesbaren URI mithilfe der <xref:System.Uri.ToString%2A> Methode. Beachten Sie, die einige reservierten Zeichen möglicherweise noch in der Ausgabe mit Escapezeichen versehen werden die <xref:System.Uri.ToString%2A> Methode. Dieser dient zur Unterstützung von eindeutig Rekonstruktion eines URIS aus den Rückgabewert von <xref:System.Uri.ToString%2A>.  
  
 Einige URIs enthalten einen Fragmentbezeichner, eine Abfrage oder beides. Ein Fragmentbezeichner ist jeder Text, der folgt ein Nummernzeichen (#), einschließlich der nicht die Nummernzeichen; der Fragmenttext befindet sich in der <xref:System.Uri.Fragment%2A> Eigenschaft. Abfrageinformationen ist jeder Text, der ein Fragezeichen (?) im URI folgt. Text der Abfrage befindet sich in der <xref:System.Uri.Query%2A> Eigenschaft.  
  
 In .NET Framework, Version 1.1, wenn die Zeichenfolge, die für einen Konstruktor angegebene ein unbekanntes Schema enthält und "c:\\", der Uri-Klasse fügt "/ /" nach dem Doppelpunkt. Z. B. der URI `xyz:c:\abc` in konvertiert `xyz://c:/abc`. In .NET Framework, Version 2.0, dieses Verhalten wurde entfernt, und die Beispielzeichenfolge wird in konvertiert `xyz:c:/abc`.  
  
> [!NOTE]
>  Die URI-Klasse unterstützt die Verwendung von IP-Adressen in beiden Quad-Notation für IPv4-Protokoll und Doppelpunkt getrennten Hexadezimalformat für IPv6-Protokoll. Denken Sie daran, schließen Sie die IPv6-Adresse in eckige Klammern, wie http://[::1].  
  
## <a name="international-resource-identifier-support"></a>International Resource Identifier-Unterstützung  
 Webadressen werden in der Regel mithilfe von uniform Resource Identifier, die aus einem sehr eingeschränkten Satz von Zeichen bestehen ausgedrückt:  
  
-   ASCII-Großbuchstaben und -Kleinbuchstaben des englischen Alphabets  
  
-   Ziffern von 0 bis 9  
  
-   einer kleinen Anzahl weiterer ASCII-Symbole  
  
 URI-Spezifikationen werden in RFC 2396, RFC 2732, RFC 3986 und RFC 3987, die von der Internet Engineering Task Force (IETF) veröffentlicht dokumentiert.  
  
 Durch das ständige Wachstum des Internets wird es immer notwendiger, Ressourcen in anderen Sprachen als in Englisch zu bezeichnen. Bezeichner, die dies ermöglichen und die Nicht-ASCII-Zeichen (Zeichen des Unicode-/ISO-Zeichensatzes 10646) zulassen, werden als International Resource Identifiers (IRIs) bezeichnet. Die IRI-Spezifikationen werden in RFC 3987 dokumentiert, die von der IETF veröffentlicht wird. Wenn IRIs verwendet werden, kann eine URL Unicode-Zeichen enthalten.  
  
 Die vorhandene <xref:System.Uri> -Klasse wurde erweitert, in .NET Framework 3.5, 3.0 SP1 und 2.0 SP1 bereitstellen, Unterstützung von IRI basierend auf RFC 3987. Benutzer von .NET Framework-Versionen vor Version 4.5 werden keine Änderung gegenüber dem .NET Framework 2.0-Verhalten feststellen, es sei denn, sie IRI wird explizit aktiviert. Dadurch wird die Anwendungskompatibilität mit früheren Versionen von .NET Framework garantiert.  
  
 Um die IRI-Unterstützung aktivieren, muss die folgende Änderung:  
  
-   Geben Sie, ob Sie möchten, dass Internationalized Domain Name (IDN) zu analysieren, die für den Domänennamen angewendet und gibt an, ob die IRI-Analyseregeln angewendet werden soll. Dies kann erfolgen der *"Machine.config"* oder in der *"App.config"* Datei. Fügen Sie beispielsweise Folgendes hinzu:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Benutzer von .NET Framework 4.5 und höher haben immer die IRI aktiviert. IRI-Analyse kann nicht geändert werden mithilfe einer *config* Datei.  
  
 Beim Aktivieren von IDN werden alle Unicode-Bezeichnungen in einem Domänennamen in ihre Punycode-Entsprechungen konvertiert. Punycode-Namen enthalten nur ASCII-Zeichen und beginnen immer mit dem Präfix „xn--“. So werden vorhandene DNS-Server im Internet unterstützt, da die meisten DNS-Server nur ASCII-Zeichen unterstützen (siehe RFC 3940).  
  
 Das Aktivieren von IRI und IDN wirkt sich auf den Wert der Eigenschaft <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType> aus. Das Aktivieren von IRI und IDN kann auch das Verhalten der Methoden <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A> und <xref:System.Uri.IsWellFormedOriginalString%2A> verändern.  
  
 Es gibt drei mögliche Werte für IDN, die abhängig von den DNS-Servern, die verwendet werden:  
  
-   IDN aktiviert = All  
  
     Durch diesen Wert werden alle Unicode-Domänennamen in ihre Punycode-Entsprechungen (IDN-Namen) konvertiert.  
  
-   IDN aktiviert = AllExceptIntranet  
  
     Diesen Wert werden alle Unicode-Domänennamen nicht auf dem lokalen Intranet verwenden Sie die Punycode-Entsprechungen (IDN-Namen) konvertiert. In diesem Fall sollte Wenn internationale Namen im lokalen Intranet verarbeitet, unterstützen die DNS-Server, die für das Intranet verwendet werden Unicode-namensauflösung.  
  
-   IDN aktiviert = keine  
  
     Durch diesen Wert werden keine Unicode-Domänennamen in ihre Punycode-Entsprechungen konvertiert. Dies ist der Standardwert, der das .NET Framework 2.0-Verhalten entspricht.  
  
 Wenn die IRI-Analyse aktiviert ist (IriParsing aktiviert = `true`) Normalisierung und zeichenüberprüfung gemäß den neuesten IRI-Regeln in RFC 3986 und RFC 3987 ausgeführt werden. Wenn die IRI-Analyse deaktiviert ist, werden Normalisierung und zeichenüberprüfung gemäß RFC 2396 und RFC 2732 (für IPv6-Literale) ausgeführt.  In Versionen von .NET Framework vor Version 4.5, der Standardwert ist `false`. In .NET Framework Version 4.5 und höher, der Standardwert ist `true`, und der aktivierte Zustand der IRI-Analyse kann nicht geändert werden, durch Einstellungen in einem *config* Datei.  
  
 IRI und IDN-Verarbeitung in die <xref:System.Uri> Klasse kann auch mithilfe von gesteuert werden die <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>, <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, und <xref:System.Configuration.UriSection?displayProperty=nameWithType> Konfigurationseinstellungsklassen. Die Einstellung <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> aktiviert oder deaktiviert die IRI-Verarbeitung in der Klasse <xref:System.Uri>. Die Einstellung <xref:System.Configuration.IdnElement?displayProperty=nameWithType> aktiviert oder deaktiviert die IDN-Verarbeitung in der Klasse <xref:System.Uri>. Die Einstellung <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> steuert indirekt auch IDN. Die IRI-Verarbeitung muss aktiviert werden, damit die IDN-Verarbeitung überhaupt möglich ist. Ist die IRI-Verarbeitung deaktiviert, wird die IDN-Verarbeitung auf die Standardeinstellung festgelegt. Darin wird aus Kompatibilitätsgründen das .NET Framework 2.0-Verhalten verwendet, und IDN-Namen werden nicht verwendet.  
  
 Die Konfigurationseinstellung für die <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> und <xref:System.Configuration.IdnElement?displayProperty=nameWithType> gelesen wird einmal beim ersten <xref:System.Uri?displayProperty=nameWithType> Klasse erstellt wird. Später vorgenommene Änderungen an den Konfigurationseinstellungen werden anschließend ignoriert.  
  
 Die Klasse <xref:System.GenericUriParser?displayProperty=nameWithType> wurde ebenfalls erweitert, um das Erstellen eines anpassbaren Parsers zu ermöglichen, der IRI und IDN unterstützt. Das Verhalten eines <xref:System.GenericUriParser?displayProperty=nameWithType>-Objekts wird durch Übergabe einer bitweisen Kombination von Werten angegeben, die in der <xref:System.GenericUriParserOptions?displayProperty=nameWithType>-Enumeration des <xref:System.GenericUriParser?displayProperty=nameWithType>-Konstruktors verfügbar sind. Der <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType>-Typ gibt an, dass der Parser die in RFC 3987 angegebenen Analyseregeln für International Resource Identifiers (IRI) unterstützt. Ob IRI verwendet wird, wird durch die zuvor beschriebenen vorgegeben.  
  
 Der <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType>-Typ gibt an, dass der Parser die IDN-Analyse von Hostnamen unterstützt. Ob IDN verwendet wird, wird durch die zuvor beschriebenen vorgegeben.  
  
## <a name="implicit-file-path-support"></a>Unterstützung für implizite Datei Pfade
 <xref:System.Uri> kann auch zur Darstellung von lokalen Pfaden verwendet werden. Diese Pfade dargestellt werden *explizit* in den URIs, die mit file:// Scheme, beginnen und *implizit* in den URIs, denen keine file:// Scheme. Als konkretes Beispiel die beiden folgenden URIs sind beide gültig, und den gleichen Dateipfad darstellen:
```csharp
Uri uri1 = new Uri("C:/test/path/file.txt") // Implicit file path.
Uri uri2 = new Uri("file:///C:/test/path/file.txt") // Explicit file path.
```
 Diese implizite Dateipfade sind nicht mit der URI-Spezifikation kompatibel und sollte vermieden werden wenn möglich. Bei Verwendung von .NET Core auf Unix-basierten Systemen implizite Dateipfade können besonders problematisch sein, da ein absoluter Dateipfad für implizite ist *nicht differenzierbar* von einem relativen Pfad. Wenn solche Mehrdeutigkeiten vorhanden ist, wird <xref:System.Uri> standardmäßig auf den Pfad als einen absoluten URI zu interpretieren.
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Bei Verwendung einer *Web.config *-Datei mit URIs zum Initialisieren der Anwendungen, die zusätzlichen Zeit ist erforderlich, um die URIs zu verarbeiten, wenn ihre Schemabezeichnern nicht dem Standard entsprechende sind. Initialisieren Sie in diesem Fall die betroffenen Teile der Anwendung ein, wenn die URIs benötigt werden, nicht zur Startzeit ausgeführt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz von der <xref:System.Uri> Klasse und verwendet es zum Erstellen einer <xref:System.Net.WebRequest> Instanz.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>Aus Sicherheitsgründen wird empfohlen, Ihre Anwendung sollte vorsichtig, wenn akzeptieren <see cref="T:System.Uri" /> Instanzen von nicht vertrauenswürdigen Quellen und mit <paramref name="dontEscape" /> festgelegt <see langword="true" />. Sehen Sie eine URI-Zeichenfolge auf Gültigkeit durch Aufrufen der <see cref="M:System.Uri.IsWellFormedOriginalString" /> Methode.</para></block>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
    <related type="Article" href="https://msdn.microsoft.com/library/35883fe9-2d09-4d8b-80ca-cf23a941e459">Änderungen am System.Uri-Namespace in Version 2.0</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b5e994c3-3535-4aff-8e1b-b69be22e9a22">International Resource Identifier-Unterstützung in System.UriSystem.Uri</related>
    <related type="Article" href="~/docs/framework/network-programming/index.md">Netzwerkprogrammierung in .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberSignature Language="F#" Value="new Uri : string -&gt; Uri" Usage="new System.Uri uriString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">Eine Zeichenfolge, die die Ressource identifiziert, die durch die <see cref="T:System.Uri" />-Instanz dargestellt werden soll. Beachten Sie, dass eine IPv6-Adresse in Zeichenfolgenform in Klammern eingeschlossen werden muss. Beispiel: „http://[2607:f8b0:400d:c06::69]“</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse mit dem angegebenen URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.Uri> -Instanz anhand einer URI-Zeichenfolge. Analysiert den URI, bringt es in kanonische Form und macht alle erforderlichen Escapecodierungen.  
  
 Dieser Konstruktor ist nicht sicher, dass die <xref:System.Uri> bezieht sich auf eine Ressource zugegriffen werden kann.  
  
 Dieser Konstruktor wird vorausgesetzt, dass die `string` Parameter verweist auf einen absoluten URI und entspricht dem Aufrufen der <xref:System.Uri.%23ctor%2A> Konstruktor mit <xref:System.UriKind> festgelegt <xref:System.UriKind.Absolute>. Wenn die `string` an den Konstruktor übergebene Parameter ist ein relativer URI, löst dieser Konstruktor eine <xref:System.UriFormatException>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz mit dem URI "http://www.contoso.com/".  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.FormatException" /> ab.</para>
          </block>
          <paramref name="uriString" /> ist leer.  
  
- oder - 
Das in <paramref name="uriString" /> angegebene Schema ist nicht richtig formatiert. Siehe <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
- oder - 
 <paramref name="uriString" /> enthält zu viele Schrägstriche.  
  
- oder - 
Das in <paramref name="uriString" /> angegebene Kennwort ist ungültig.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene Hostname ist ungültig.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene Dateiname ist ungültig.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene Benutzername ist ungültig.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene Host- oder Zertifizierungsstellenname darf nicht mit umgekehrten Schrägstrichen enden.  
  
- oder - 
Die in <paramref name="uriString" /> angegebene Portnummer ist ungültig oder kann nicht analysiert werden.  
  
- oder - 
Die Länge von <paramref name="uriString" /> überschreitet 65519 Zeichen.  
  
- oder - 
Das in <paramref name="uriString" /> angegebene Schema ist länger als 1023 Zeichen.  
  
- oder - 
<paramref name="uriString" /> enthält eine ungültige Zeichenfolge.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene MS-DOS-Pfad muss mit „c:\\\\“ beginnen.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new Uri : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Uri" Usage="new System.Uri (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Eine Instanz der <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Klasse mit den für die Serialisierung der neuen <see cref="T:System.Uri" />-Instanz erforderlichen Informationen.</param>
        <param name="streamingContext">Eine Instanz der <see cref="T:System.Runtime.Serialization.StreamingContext" />-Klasse, die die Quelle des serialisierten Streams enthält, der der neuen <see cref="T:System.Uri" />-Instanz zugeordnet ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse aus den angegebenen Instanzen der <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Klasse und der <see cref="T:System.Runtime.Serialization.StreamingContext" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor implementiert die <xref:System.Runtime.Serialization.ISerializable> eine Schnittstelle für die <xref:System.Uri> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="serializationInfo" />-Parameter enthält einen <see langword="null" />-URI.</exception>
        <exception cref="T:System.UriFormatException">Der <paramref name="serializationInfo" />-Parameter enthält einen leeren URI.  
  
- oder - 
Das angegebene Schema ist nicht richtig formatiert. Siehe <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
- oder - 
Der URI enthält zu viele Schrägstriche.  
  
- oder - 
Das im URI angegebene Kennwort ist ungültig.  
  
- oder - 
Der im URI angegebene Hostname ist ungültig.  
  
- oder - 
Das im URI angegebene Dateiname ist ungültig.  
  
- oder - 
Der im URI angegebene Benutzername ist ungültig.  
  
- oder - 
Der im URI angegebene Host- oder Zertifizierungsstellenname darf nicht mit umgekehrten Schrägstrichen enden.  
  
- oder - 
Die im URI angegebene Portnummer ist ungültig oder kann nicht analysiert werden.  
  
- oder - 
Der URI ist länger als 65.519 Zeichen.  
  
- oder - 
Das im URI angegebene Schema ist länger als 1.023 Zeichen.  
  
- oder - 
Der URI enthält eine ungültige Zeichenfolge.  
  
- oder - 
Der im URI angegebene MS-DOS-Pfad muss mit „c:\\\\“ beginnen.</exception>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML- und SOAP-Serialisierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : string * bool -&gt; Uri" Usage="new System.Uri (uriString, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="uriString">Eine Zeichenfolge, die die Ressource identifiziert, die durch die <see cref="T:System.Uri" />-Instanz dargestellt werden soll. Beachten Sie, dass eine IPv6-Adresse in Zeichenfolgenform in Klammern eingeschlossen werden muss. Beispiel: „http://[2607:f8b0:400d:c06::69]“</param>
        <param name="dontEscape"><see langword="true" />, wenn <paramref name="uriString" /> vollständig mit Escapezeichen versehen wurde, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse mit dem angegebenen URI, wobei die Verwendung der Escapezeichen explizit gesteuert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.Uri> -Instanz anhand einer URI-Zeichenfolge. Es analysiert den URI und im kanonischen Format eingefügt.  
  
 Die `dontEscape` Parameter steuert, ob die reservierten Zeichen übersetzt werden in Escapesequenzen. Dieser Parameter sollte festgelegt werden, um `true` nur, wenn Sie sicher sind, haben alle reservierte Zeichen im URI geschützt wurde. Festlegen des Werts auf `true` für ein URI, der nicht vollständig mit Escapezeichen versehen wurde zu unerwartetem Verhalten führen kann. Es wird dringend empfohlen, dass Sie diesen Parameter immer, um festlegen `false`.  
  
 Wenn `dontEscape` nastaven NA hodnotu `false`, der Konstruktor mit dem Escapezeichen versieht reservierten Zeichen durch Prüfung, ob die gültige Escape-Sequenz folgen alle Vorkommen von Prozentzeichen (%). Wenn der Prozentsatz folgende Zeichenfolge nicht gültig ist, wird der Prozentsatz % 25 ersetzt.  
  
 Dieser Konstruktor ist nicht sicher, dass die <xref:System.Uri> bezieht sich auf eine Ressource zugegriffen werden kann.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz für den URI http://www.contoso.com/Hello%20World.htm. Da der enthaltene URI vollständig mit Escapezeichen versehen ist und im kanonischen Format liegt der `dontEscape` Parameter kann festgelegt werden, um `true`.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="uriString" /> ist leer oder enthält nur Leerzeichen.  
  
- oder - 
Das in <paramref name="uriString" /> angegebene Kennwort ist ungültig.  
  
- oder - 
 <paramref name="uriString" /> enthält zu viele Schrägstriche.  
  
- oder - 
Das in <paramref name="uriString" /> angegebene Kennwort ist ungültig.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene Hostname ist ungültig.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene Dateiname ist ungültig.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene Benutzername ist ungültig.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene Host- oder Zertifizierungsstellenname darf nicht mit umgekehrten Schrägstrichen enden.  
  
- oder - 
Die in <paramref name="uriString" /> angegebene Portnummer ist ungültig oder kann nicht analysiert werden.  
  
- oder - 
Die Länge von <paramref name="uriString" /> überschreitet 65519 Zeichen.  
  
- oder - 
Das in <paramref name="uriString" /> angegebene Schema ist länger als 1023 Zeichen.  
  
- oder - 
<paramref name="uriString" /> enthält eine ungültige Zeichenfolge.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene MS-DOS-Pfad muss mit „c:\\\\“ beginnen.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="new Uri : string * UriKind -&gt; Uri" Usage="new System.Uri (uriString, uriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Eine Zeichenfolge, die die Ressource identifiziert, die durch die <see cref="T:System.Uri" />-Instanz dargestellt werden soll. Beachten Sie, dass eine IPv6-Adresse in Zeichenfolgenform in Klammern eingeschlossen werden muss. Beispiel: „http://[2607:f8b0:400d:c06::69]“</param>
        <param name="uriKind">Gibt an, ob die URI-Zeichenfolge ein relativer URI, ein absoluter URI oder unbestimmt ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse mit dem angegebenen URI. Mit diesem Konstruktor können Sie angeben, ob die URI-Zeichenfolge ein relativer URI, ein absoluter URI oder unbestimmt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Relative und absolute URIs gelten verschiedene Einschränkungen für ihr Format. Ein relativer URI ist z. B. ein Schema oder einer Autorität nicht erforderlich. Der Wert, der Ihnen auf `uriKind` muss mit dem Typ des übergebenen URI `uriString`. Aber wenn <xref:System.UriKind.RelativeOrAbsolute> angegeben ist, wird die URI-Zeichenfolge kann relativ oder absolut sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="uriKind" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.FormatException" /> ab.</para>
          </block>
          <paramref name="uriString" /> enthält einen relativen URI, und <paramref name="uriKind" /> ist <see cref="F:System.UriKind.Absolute" />.  
  
oder 
 <paramref name="uriString" /> enthält einen absoluten URI, und <paramref name="uriKind" /> ist <see cref="F:System.UriKind.Relative" />.  
  
oder 
 <paramref name="uriString" /> ist leer.  
  
- oder - 
Das in <paramref name="uriString" /> angegebene Schema ist nicht richtig formatiert. Siehe <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
- oder - 
 <paramref name="uriString" /> enthält zu viele Schrägstriche.  
  
- oder - 
Das in <paramref name="uriString" /> angegebene Kennwort ist ungültig.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene Hostname ist ungültig.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene Dateiname ist ungültig.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene Benutzername ist ungültig.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene Host- oder Zertifizierungsstellenname darf nicht mit umgekehrten Schrägstrichen enden.  
  
- oder - 
Die in <paramref name="uriString" /> angegebene Portnummer ist ungültig oder kann nicht analysiert werden.  
  
- oder - 
Die Länge von <paramref name="uriString" /> überschreitet 65519 Zeichen.  
  
- oder - 
Das in <paramref name="uriString" /> angegebene Schema ist länger als 1023 Zeichen.  
  
- oder - 
<paramref name="uriString" /> enthält eine ungültige Zeichenfolge.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene MS-DOS-Pfad muss mit „c:\\\\“ beginnen.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">Der Basis-URI.</param>
        <param name="relativeUri">Der relative URI, der dem Basis-URI hinzugefügt werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse auf Grundlage des angegebenen Basis-URIs und der relativen URI-Zeichenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.Uri> Instanz aus der `baseUri` und `relativeUri`. Wenn `relativeUri` ist ein absoluter URI (mit einem Schema, Hostnamen und optional eine Portnummer), die <xref:System.Uri> Instanz wird nur mit erstellt `relativeUri`.  
 
 Wenn die `baseUri` relative Teilen (wie `/api`), und klicken Sie dann der relative Teil ein Schrägstrich enden muss (wie `/api/`), wenn der relative Anteil `baseUri` werden in das erstellte beibehalten <xref:System.Uri>. 

 Darüber hinaus, wenn die `relativeUri` beginnt mit einem Schrägstrich, und klicken Sie dann einen beliebigen relative Teil ersetzt werden soll die `baseUri`

 Dieser Konstruktor ist nicht sicher, dass die <xref:System.Uri> bezieht sich auf eine Ressource zugegriffen werden kann.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine neue Instanz der dem <xref:System.Uri> Klasse durch die Kombination der relativen URIs http://www.contoso.com und /catalog/shownew.htm, um den absoluten URI zu bilden http://www.contoso.com/catalog/shownew.htm.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> ist keine absolute <see cref="T:System.Uri" />-Instanz.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.FormatException" /> ab.</para>
          </block>
Der URI, der aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombiniert wurde, ist leer oder enthält nur Leerzeichen.  
  
- oder - 
Das Schema, das in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der URI, der aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombiniert wurde, enthält zu viele Schrägstriche.  
  
- oder - 
Das Kennwort, das in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der Hostname, der in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der Dateiname, der in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der Benutzername, der in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der Host- oder Zertifizierungsstellenname, der in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, darf nicht mit umgekehrten Schrägstrichen enden.  
  
- oder - 
Die Portnummer, die in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig oder kann nicht analysiert werden.  
  
- oder - 
Der aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierte URI ist länger als 65.519 Zeichen.  
  
- oder - 
Das Schema, das in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist länger als 1.023 Zeichen.  
  
- oder - 
Der aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierte URI enthält eine ungültige Zeichenfolge.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene MS-DOS-Pfad muss mit „c:\\\\“ beginnen.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * Uri -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">Ein absoluter <see cref="T:System.Uri" />, der die Basis für die neue <see cref="T:System.Uri" />-Instanz ist.</param>
        <param name="relativeUri">Eine relative <see cref="T:System.Uri" />-Instanz, die mit <paramref name="baseUri" /> kombiniert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse auf Grundlage der Kombination einer angegebenen <see cref="T:System.Uri" />-Instanz als Basis und einer relativen <see cref="T:System.Uri" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Uri> Instanz durch Kombination einer absoluten <xref:System.Uri> Instanz `baseUri`, mit einer relativen <xref:System.Uri> Instanz `relativeUri`. Wenn `relativeUri` ist ein absoluter <xref:System.Uri> Instanz (mit einem Schema, Hostnamen und optional eine Portnummer), die <xref:System.Uri> Instanz wird nur mit erstellt `relativeUri`.  
 
 Wenn die `baseUri` relative Teilen (wie `/api`), und klicken Sie dann der relative Teil ein Schrägstrich enden muss (wie `/api/`), wenn der relative Anteil `baseUri` werden in das erstellte beibehalten <xref:System.Uri>. 

 Darüber hinaus, wenn die `relativeUri` beginnt mit einem Schrägstrich, und klicken Sie dann einen beliebigen relative Teil ersetzt werden soll die `baseUri`
 
 Dieser Konstruktor ist nicht sicher, dass die <xref:System.Uri> bezieht sich auf eine Ressource zugegriffen werden kann.  
  
   
  
## Examples  
 In diesem Beispiel wird ein absolutes <xref:System.Uri> Instanz `absoluteUri`, und einem relativen <xref:System.Uri> Instanz `relativeUri`. Ein neues <xref:System.Uri> Instanz `combinedUri`, klicken Sie dann aus diesen beiden Instanzen erstellt wird.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="baseUri" /> ist keine absolute <see cref="T:System.Uri" />-Instanz.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> ist keine absolute <see cref="T:System.Uri" />-Instanz.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.FormatException" /> ab.</para>
          </block>
Der URI, der aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombiniert wurde, ist leer oder enthält nur Leerzeichen.  
  
- oder - 
Das Schema, das in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der URI, der aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombiniert wurde, enthält zu viele Schrägstriche.  
  
- oder - 
Das Kennwort, das in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der Hostname, der in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der Dateiname, der in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der Benutzername, der in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der Host- oder Zertifizierungsstellenname, der in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, darf nicht mit umgekehrten Schrägstrichen enden.  
  
- oder - 
Die Portnummer, die in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig oder kann nicht analysiert werden.  
  
- oder - 
Der aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierte URI ist länger als 65.519 Zeichen.  
  
- oder - 
Das Schema, das in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist länger als 1.023 Zeichen.  
  
- oder - 
Der aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierte URI enthält eine ungültige Zeichenfolge.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene MS-DOS-Pfad muss mit „c:\\\\“ beginnen.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string * bool -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseUri">Der Basis-URI.</param>
        <param name="relativeUri">Der relative URI, der dem Basis-URI hinzugefügt werden soll.</param>
        <param name="dontEscape"><see langword="true" />, wenn <paramref name="uriString" /> vollständig mit Escapezeichen versehen wurde, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Uri" />-Klasse auf Grundlage des angegebenen Basis-URIs und des angegebenen relativen URIs mit expliziter Steuerung der Escapesequenzen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.Uri> Instanz durch Kombinieren von `baseUri` und `relativeUri`. Wenn der URI übergeben `relativeUri` ist ein absoluter URI (mit einem Schema, Hostnamen und optional eine Portnummer), die <xref:System.Uri> Instanz wird nur mit erstellt `relativeUri`.  
  
 Die `dontEscape` Parameter steuert, ob die reservierten Zeichen übersetzt werden in Escapesequenzen. Dieser Parameter sollte festgelegt werden, um `true` nur, wenn Sie sicher sind, haben alle reservierte Zeichen im URI geschützt wurde. Festlegen des Werts auf `true` für ein URI, der nicht vollständig mit Escapezeichen versehen wurde zu unerwartetem Verhalten führen kann. Es wird dringend empfohlen, dass Sie diesen Parameter immer, um festlegen `false`. Wenn `dontEscape` nastaven NA hodnotu `false`, der Konstruktor mit dem Escapezeichen versieht reservierten Zeichen durch Prüfung, ob die gültige Escape-Sequenz folgen alle Vorkommen von Prozentzeichen (%). Wenn der Prozentsatz folgende Zeichenfolge nicht gültig ist, wird der Prozentsatz % 25 ersetzt.  
  
 Dieser Konstruktor ist nicht sicher, dass die <xref:System.Uri> bezieht sich auf eine Ressource zugegriffen werden kann.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine neue Instanz der dem <xref:System.Uri> Klasse durch die Kombination der relativen URIs http://www.contoso.com und Hello%20World.htm, um einen absoluten URI zu bilden.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> ist keine absolute <see cref="T:System.Uri" />-Instanz.</exception>
        <exception cref="T:System.UriFormatException">Der URI, der aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombiniert wurde, ist leer oder enthält nur Leerzeichen.  
  
- oder - 
Das Schema, das in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der URI, der aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombiniert wurde, enthält zu viele Schrägstriche.  
  
- oder - 
Das Kennwort, das in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der Hostname, der in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der Dateiname, der in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der Benutzername, der in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig.  
  
- oder - 
Der Host- oder Zertifizierungsstellenname, der in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, darf nicht mit umgekehrten Schrägstrichen enden.  
  
- oder - 
Die Portnummer, die in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist ungültig oder kann nicht analysiert werden.  
  
- oder - 
Der aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierte URI ist länger als 65.519 Zeichen.  
  
- oder - 
Das Schema, das in dem aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierten URI angegeben wurde, ist länger als 1.023 Zeichen.  
  
- oder - 
Der aus <paramref name="baseUri" /> und <paramref name="relativeUri" /> kombinierte URI enthält eine ungültige Zeichenfolge.  
  
- oder - 
Der in <paramref name="uriString" /> angegebene MS-DOS-Pfad muss mit „c:\\\\“ beginnen.</exception>
        <block subset="none" type="usage"><para>Aus Sicherheitsgründen soll Ihre Anwendung nicht aufrufen dieses Konstruktors mit URI-Zeichenfolgen aus nicht vertrauenswürdigen Quellen und mit <paramref name="dontEscape" /> festgelegt <see langword="true" />. Alternativ können Sie eine URI-Zeichenfolge auf Gültigkeit überprüfen, durch den Aufruf der <see cref="M:System.Uri.IsWellFormedOriginalString" /> Methode vor dem Aufrufen dieses Konstruktors.</para></block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsolutePath : string" Usage="System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den absoluten Pfad des URIs ab.</summary>
        <value>Ein <see cref="T:System.String" /> mit dem absoluten Pfad der Ressource.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.AbsolutePath%2A> Eigenschaft enthält die Informationen über Pfade, die der Server verwendet, um Anforderungen für Informationen zu beheben. In der Regel ist dies der Pfad zu der gewünschten Informationen im Dateisystem des Servers, obwohl es auch angeben kann der Anwendung oder ein Skript, das der Server ausgeführt werden muss, um die Informationen bereitzustellen.  
  
 Die Pfadinformationen umfasst nicht das Schema, Hostname oder Abfrageteil des URI.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die /catalog/shownew.htm Pfad in die Konsole geschrieben.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsoluteUri : string" Usage="System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den absoluten URI ab.</summary>
        <value>Ein <see cref="T:System.String" /> mit dem vollständigen URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.AbsoluteUri%2A> Eigenschaft enthält den gesamten URI gespeichert, der <xref:System.Uri> -Instanz, einschließlich aller Fragmente und Abfragezeichenfolgen.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt den vollständigen Inhalt des der <xref:System.Uri> Instanz in der Konsole. Im Beispiel wird gezeigt http://www.contoso.com/catalog/shownew.htm?date=today wird an die Konsole geschrieben.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den DNS-Hostnamen (Domain Name System) oder die IP-Adresse und die Anschlussnummer für einen Server ab.</summary>
        <value>Ein <see cref="T:System.String" />, der die Zertifizierungsstellenkomponente des von dieser Instanz dargestellten URIs enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.Authority%2A> Eigenschaft ist in der Regel eine Server-DNS-Hostname oder IP-Adresse. Diese Eigenschaft sind die Dienstportnummer an, wenn sie als den Standardport für den URI unterscheiden. Wenn die <xref:System.Uri.Authority%2A> Komponente reservierte Zeichen enthält, werden diese mit Escapezeichen in der Zeichenfolgenwert, der von dieser Eigenschaft zurückgegebene versehen.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt die Hostnamen (www.contoso.com) und die Portnummer (8080) des Servers in der Konsole.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberSignature Language="F#" Value="abstract member Canonicalize : unit -&gt; unit&#xA;override this.Canonicalize : unit -&gt; unit" Usage="uri.Canonicalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den intern gespeicherten URI in kanonische Form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die kanonische Version des URI intern gespeichert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Methode ist jedoch nur für absolute URIs gültig.</exception>
        <exception cref="T:System.UriFormatException">Der URI entspricht nicht der korrekten Form.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member CheckHostName : string -&gt; UriHostNameType" Usage="System.Uri.CheckHostName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Hostname, der überprüft werden soll. Dies kann eine IPv4- oder IPv6-Adresse oder ein Internethostname sein.</param>
        <summary>Bestimmt, ob der angegebene Hostname ein gültiger DNS-Name ist.</summary>
        <returns>Ein <see cref="T:System.UriHostNameType" />, der den Typ des Hostnamens angibt. Wenn der Typ des Hostnamens nicht bestimmt werden kann oder der Hostname <see langword="null" /> oder eine Zeichenfolge der Länge 0 (null) ist, gibt diese Methode <see cref="F:System.UriHostNameType.Unknown" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.CheckHostName%2A> Methode überprüft, ob der angegebene Hostname die Anforderungen für einen gültigen Hostnamen für den Internet entspricht. Es führt keine, jedoch eine Hostname-Suche, um zu überprüfen, ob der Host vorhanden ist.  
  
   
  
## Examples  
 Das folgende Beispiel überprüft, ob der Host-Name gültig ist.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberSignature Language="F#" Value="static member CheckSchemeName : string -&gt; bool" Usage="System.Uri.CheckSchemeName schemeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">Der Schemaname, der validiert werden soll.</param>
        <summary>Bestimmt, ob der angegebene Schemaname gültig ist.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der Schemaname gültig ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft den Schemanamen für Gültigkeit gemäß RFC 2396 standardmäßig. Wenn International Resource Identifiers (IRIs) oder Parsen von Internationalized Domain Name (IDN) aktiviert ist, überprüft diese Methode den Schemanamen für Gültigkeit gemäß RFC 3986. Der Name des Schemas muss mit einem Buchstaben beginnen und darf nur Buchstaben, Ziffern und die Zeichen ".", "+" oder "-".  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" für die <xref:System.Uri> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und überprüft, ob der Name des Schemas gültig ist.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberSignature Language="F#" Value="abstract member CheckSecurity : unit -&gt; unit&#xA;override this.CheckSecurity : unit -&gt; unit" Usage="uri.CheckSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Das Aufrufen dieser Methode hat keine Auswirkung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : Uri * Uri * UriComponents * UriFormat * StringComparison -&gt; int" Usage="System.Uri.Compare (uri1, uri2, partsToCompare, compareFormat, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" />
        <Parameter Name="compareFormat" Type="System.UriFormat" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="uri1">Die erste <see cref="T:System.Uri" />.</param>
        <param name="uri2">Das zweite <see cref="T:System.Uri" />.</param>
        <param name="partsToCompare">Eine bitweise Kombination der <see cref="T:System.UriComponents" />-Werte, die die Teile von <paramref name="uri1" /> und <paramref name="uri2" /> angeben, die verglichen werden sollen.</param>
        <param name="compareFormat">Einer der <see cref="T:System.UriFormat" />-Werte, der das Escapezeichen angibt, das beim Vergleichen der URI-Komponenten verwendet wird.</param>
        <param name="comparisonType">Einer der <see cref="T:System.StringComparison" />-Werte.</param>
        <summary>Vergleicht die angegebenen Teile von zwei URIs gemäß den angegebenen Vergleichsregeln.</summary>
        <returns>Ein <see cref="T:System.Int32" />-Wert, der die lexikalische Beziehung zwischen den verglichenen <see cref="T:System.Uri" />-Komponenten angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedeutung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="uri1" /> ist kleiner als <paramref name="uri2" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="uri1" /> ist gleich <paramref name="uri2" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="uri1" /> ist größer als <paramref name="uri2" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn beide `uri1` und `uri2` sind `null`, diese Methode gibt 0 zurück. Beim Vergleichen von URI-Werte ist ein relativer URI ist immer kleiner als ein absoluter URI und einem nicht-Null-URI ist immer größer als ein null-URI. Für Fälle, in denen beide `uri1` und `uri2` nicht `null` und sind sowohl relative URIs oder beides absolute URIs, die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> Methode führt den Vergleich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DnsSafeHost : string" Usage="System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Hostnamen, der sicher für die DNS-Auflösung verwendet werden kann, da er keine Escapezeichen enthält.</summary>
        <value>Ein <see cref="T:System.String" /> , enthält der Hostteil des URIS in einem Format, die für DNS-Auflösung oder die ursprüngliche Zeichenfolge Host geeignet, wenn es bereits für die Lösung geeignet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für IPv6-Adressen, die Klammern ([]) entfernt und die <xref:System.Net.IPAddress.ScopeId%2A> Eigenschaft festgelegt wird, wenn beim Erstellen dieser Instanz angegeben wurde.

Wenn Sie eine Zeichenfolge mit Escapezeichen, zum Erstellen dieser Instanz verwendet (z. B. "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), klicken Sie dann DnsSafeHost mit Escapezeichen gibt eine Zeichenfolge zurück. Unescape-eine beliebige Zeichenfolge mit Escapezeichen Merry `DnsSafeHost` vor der Verwendung dieser Zeichenfolge für die DNS-Auflösung (siehe Beispiel). Wenn Sie eine ungültige Zeichenfolge für die ohne Escapezeichen, zum Erstellen dieser Instanz verwendet (z. B. "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), klicken Sie dann DnsSafeHost ohne Escapezeichen gibt eine Zeichenfolge zurück.
  
 Die <xref:System.Uri.DnsSafeHost%2A> Eigenschaft ist abhängig von den Konfigurationseinstellungen, wie weiter unten in diesem Thema erläutert. Konfigurationseinstellungen können nicht geändert werden, von Windows Store-Anwendungen, die zu inkonsistenten Ergebnissen führen können, wenn mit <xref:System.Uri.DnsSafeHost%2A>. Die <xref:System.Uri.IdnHost%2A> Eigenschaft wird bereitgestellt, als die bevorzugte Alternative zur Verwendung <xref:System.Uri.DnsSafeHost%2A>, da <xref:System.Uri.IdnHost%2A> ist garantiert immer sicher, unabhängig davon, welche aktuellen DNS *"App.config"* Einstellungen möglicherweise.  
  
 Die <xref:System.Uri.DnsSafeHost%2A> Eigenschaft wurde erweitert, in .NET Framework 3.5, 3.0 SP1 und 2.0 SP1 zu International Resource Identifier (IRI) unterstützt basierend auf RFC 3987. Derzeitige Benutzer werden keine Änderung gegenüber dem .NET Framework 2.0-Verhalten feststellen, außer IRI wird explizit aktiviert. Dadurch wird die Anwendungskompatibilität mit früheren Versionen von .NET Framework garantiert.  
  
 Um die IRI-Unterstützung aktivieren, müssen die folgenden beiden Änderungen vornehmen:  
  
1.  Die folgende Zeile zum Hinzufügen der *"Machine.config"* Datei im .NET Framework 2.0-Verzeichnis  
  
     \<section name="uri" type="System.Configuration.UriSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  
2.  Geben Sie, ob Sie möchten, dass Internationalized Domain Name (IDN) zu analysieren, die für den Domänennamen angewendet und gibt an, ob die IRI-Analyseregeln angewendet werden soll. Dies kann erfolgen der *"Machine.config"* oder in der *"App.config"* Datei. Fügen Sie beispielsweise Folgendes hinzu:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Beim Aktivieren von IDN werden alle Unicode-Bezeichnungen in einem Domänennamen in ihre Punycode-Entsprechungen konvertiert. Punycode-Namen enthalten nur ASCII-Zeichen und beginnen immer mit dem Präfix „xn--“. So werden vorhandene DNS-Server im Internet unterstützt, da die meisten DNS-Server nur ASCII-Zeichen unterstützen (siehe RFC 3940).  
  
 Aktivieren von IDN nur wirkt sich auf den Wert von der <xref:System.Uri.DnsSafeHost%2A> Eigenschaft.  
  
 Es gibt drei mögliche Werte für IDN, die abhängig von den DNS-Servern, die verwendet werden:  
  
-   IDN aktiviert = All  
  
     Durch diesen Wert werden alle Unicode-Domänennamen in ihre Punycode-Entsprechungen (IDN-Namen) konvertiert.  
  
-   IDN aktiviert = AllExceptIntranet  
  
     Durch diesen Wert werden alle externen Unicode-Domänennamen so konvertiert, dass die Punycode-Entsprechungen (IDN-Namen) verwendet werden. Wenn internationale Namen im lokalen Intranet verarbeitet werden sollen, müssen die DNS-Server im Intranet Unicode-Namen unterstützen.  
  
-   IDN aktiviert = keine  
  
     Durch diesen Wert werden keine Unicode-Domänennamen in ihre Punycode-Entsprechungen konvertiert. Dies ist der Standardwert, der das .NET Framework 2.0-Verhalten entspricht.  
  
 Aktivieren der IRI-Analyse (IriParsing aktiviert = `true`) wird die Normalisierung und zeichenüberprüfung gemäß den neuesten IRI-Regeln in RFC 3987. Der Standardwert ist `false` und wird die Normalisierung und Überprüfung gemäß RFC 2396 und RFC 2732 (für IPv6-Literale) Zeichen.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" für die <xref:System.Uri> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz aus einer Zeichenfolge. Veranschaulicht den Unterschied zwischen den Rückgabewert aus <xref:System.Uri.Host%2A>, den Hostnamen oder die Adresse, die im URI angegebene zurückgegeben und der Rückgabewert von <xref:System.Uri.DnsSafeHost%2A>, womit eine Adresse, die sicher im DNS-Auflösung verwendet werden kann.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 Wie unter "Hinweise" erläutert, unescape-Namen des Hosts vor dem aufgelöst werden kann. Können Sie die <xref:System.Uri.UnescapeDataString%2A> Methode, um die unescape-Namen des Hosts, und Sie können ihn beheben, durch den Aufruf der <xref:System.Net.Dns.GetHostEntry%2A> Methode.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uri.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">Die <see cref="T:System.Uri" />-Instanz oder ein URI-Bezeichner, der mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Überprüft zwei <see cref="T:System.Uri" />-Instanzen auf Gleichheit.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn die zwei Instanzen denselben URI darstellen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.Equals%2A> Methode vergleicht die beiden Instanzen ohne Berücksichtigung von Benutzerinformationen (<xref:System.Uri.UserInfo%2A>) und -Fragment (<xref:System.Uri.Fragment%2A>) teilen, die sie enthalten können. Angenommen, die URIs http://www.contoso.com/index.htm#search und http://user:password@www.contoso.com/index.htm, <xref:System.Uri.Equals%2A> Methode zurückgeben würde `true`.  
  
 Wenn eine <xref:System.Uri> Instanz wird mit einem Unicode-Hostnamen gebildet und `comparand` Parameter enthält einen <xref:System.Uri> Instanz oder Bezeichner, der mit dem Hostnamen gebildet wird, die den entsprechenden Punycode-Hostnamen ein, klicken Sie dann <xref:System.Uri.Equals%2A> gibt `true` nur, wenn Sie Unterstützung von International Resource Identifier (IRI) und Internationalized Domain Name (IDN) werden aktiviert. Punycode-Namen enthalten nur ASCII-Zeichen und beginnen immer mit dem Präfix „xn--“.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" für die <xref:System.Uri> Klasse.  
  
> [!NOTE]
>  In den .NET Framework-Versionen 1.0 und 1.1 die <xref:System.Uri.Query%2A> wird ebenfalls ignoriert.  
  
> [!NOTE]
>  Die <xref:System.Uri.Equals%2A> Methode kann in einer abgeleiteten Klasse überschrieben werden, gehen Sie vorsichtig vor, als einen der Methode geändert werden kann. Sie sollten diese Methode nicht verwenden, um sicherheitsüberprüfungen auszuführen, es sei denn, Sie wissen, dass diese Instanz von einer vertrauenswürdigen Quelle stammt.  
  
   
  
## Examples  
 Dieses Beispiel erstellt zwei <xref:System.Uri> -Instanzen aus Zeichenfolgen und miteinander verglichen, um zu bestimmen, ob sie den gleichen Wert darstellen. `address1` und `address2` sind gleich, da die <xref:System.Uri.Fragment%2A> Teil wird für diesen Vergleich ignoriert. Das Ergebnis wird an die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">um zu verhindern, dass teilweise vertrauenswürdigen Code Ableiten von <see cref="T:System.Uri" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberSignature Language="F#" Value="abstract member Escape : unit -&gt; unit&#xA;override this.Escape : unit -&gt; unit" Usage="uri.Escape " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert alle unsicheren oder reservierten Zeichen in der Pfadkomponente in die entsprechenden Hexadezimaldarstellungen.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">Der vom Konstruktor übergebene URI ist ungültig. Diese Ausnahme kann auftreten, wenn ein URI zu viele Zeichen hat oder der URI relativ ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeDataString : string -&gt; string" Usage="System.Uri.EscapeDataString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Die Zeichenfolge, die mit Escapezeichen versehen werden soll.</param>
        <summary>Konvertiert eine Zeichenfolge in eine Darstellung mit Escapezeichen.</summary>
        <returns>Ein <see cref="T:System.String" />, der die Darstellung von <paramref name="stringToEscape" /> mit Escapezeichen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Standardeinstellung die <xref:System.Uri.EscapeDataString%2A> Methode konvertiert alle Zeichen mit Ausnahme von RFC 2396 nicht reservierten Zeichen in ihrer hexadezimalen Darstellung. Wenn International Resource Identifiers (IRIs) oder Parsen von Internationalized Domain Name (IDN) aktiviert ist, die <xref:System.Uri.EscapeDataString%2A> Methode konvertiert alle Zeichen, mit Ausnahme von RFC 3986 nicht reservierte Zeichen, die in ihrer hexadezimalen Darstellung. Alle Unicode-Zeichen werden in UTF-8-Format konvertiert, bevor Sie mit Escapezeichen versehen wird.  
  
 Diese Methode setzt voraus, dass `stringToEscape` verfügt über keine Escapesequenzen.  
  
 Standardmäßig wird die Zeichenfolge gemäß RFC 2396 mit Escapezeichen versehen. Wenn International Resource Identifiers (IRIs) oder Parsen von Internationalized Domain Name (IDN) aktiviert ist, wird die Zeichenfolge gemäß RFC 3986 und RFC 3987 mit Escapezeichen versehen. Finden Sie unter folgenden RFCs für eine Definition der reservierter und nicht reservierter Zeichen.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" für die <xref:System.Uri> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToEscape" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.FormatException" /> ab.</para>
          </block>  
  
 Die Länge von <paramref name="stringToEscape" /> überschreitet 32766 Zeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member EscapeString : string -&gt; string" Usage="System.Uri.EscapeString str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die in eine Darstellung mit Escapesequenzen zu transformierende Zeichenfolge.</param>
        <summary>Konvertiert eine Zeichenfolge in eine Darstellung mit Escapezeichen.</summary>
        <returns>Die Darstellung der Zeichenfolge mit Escapesequenzen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.EscapeString%2A> Methode konvertiert RFC 2396 reservierte Zeichen und alle Zeichen mit einem größer als 127 Zeichenwert in die hexadezimale Darstellung. Alle Unicode-Zeichen werden in UTF-8-Format konvertiert, bevor Sie mit Escapezeichen versehen wird.  
  
 Standardmäßig wird die Zeichenfolge gemäß RFC 2396 mit Escapezeichen versehen. Wenn International Resource Identifiers (IRIs) oder Parsen von Internationalized Domain Name (IDN) aktiviert ist, wird die Zeichenfolge gemäß RFC 3986 und RFC 3987 mit Escapezeichen versehen.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" für die <xref:System.Uri> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeUriString : string -&gt; string" Usage="System.Uri.EscapeUriString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Die Zeichenfolge, die mit Escapezeichen versehen werden soll.</param>
        <summary>Konvertiert eine URI-Zeichenfolge in eine Darstellung mit Escapezeichen.</summary>
        <returns>Ein <see cref="T:System.String" />, der die Darstellung von <paramref name="stringToEscape" /> mit Escapezeichen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Uri.EscapeUriString%2A> Methode, um eine URI-Zeichenfolge ohne Escapezeichen als Parameter zum Vorbereiten der <xref:System.Uri.%23ctor%2A> Konstruktor.  
  
 In der Standardeinstellung die <xref:System.Uri.EscapeUriString%2A> Methode konvertiert alle Zeichen mit Ausnahme von RFC 2396 nicht reservierten Zeichen in ihrer hexadezimalen Darstellung. Wenn International Resource Identifiers (IRIs) oder Parsen von Internationalized Domain Name (IDN) aktiviert ist, die <xref:System.Uri.EscapeUriString%2A> Methode konvertiert alle Zeichen, mit Ausnahme von RFC 3986 nicht reservierte Zeichen, die in ihrer hexadezimalen Darstellung. Alle Unicode-Zeichen werden in UTF-8-Format konvertiert, bevor Sie mit Escapezeichen versehen wird.  
  
 Diese Methode setzt voraus, dass `stringToEscape` verfügt über keine Escapesequenzen.  
  
 Standardmäßig wird die Zeichenfolge gemäß RFC 2396 mit Escapezeichen versehen. Wenn International Resource Identifiers (IRIs) oder Parsen von Internationalized Domain Name (IDN) aktiviert ist, wird die Zeichenfolge gemäß RFC 3986 und RFC 3987 mit Escapezeichen versehen. Finden Sie unter folgenden RFCs für eine Definition der reservierter und nicht reservierter Zeichen.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" für die <xref:System.Uri> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToEscape" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.FormatException" /> ab.</para>
          </block>  
  
 Die Länge von <paramref name="stringToEscape" /> überschreitet 32766 Zeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Fragment : string" Usage="System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das mit Escapezeichen versehene URI-Fragment ab.</summary>
        <value>Ein <see cref="T:System.String" />, der URI-Fragmentinformationen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.Fragment%2A> Eigenschaft ruft eine fragmentmarkierung (#) in den URI einschließlich der fragmentmarkierung selbst nach Text ab. Den URI angegebenen http://www.contoso.com/index.htm#main, <xref:System.Uri.Fragment%2A> Eigenschaft #main zurück.  
  
 Die <xref:System.Uri.Fragment%2A> Eigenschaft wird nicht berücksichtigt, in einem <xref:System.Uri.Equals%2A> Vergleich.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz und die Fragmentinformationen in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberSignature Language="F#" Value="static member FromHex : char -&gt; int" Usage="System.Uri.FromHex digit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="digit">Die zu konvertierende Hexadezimalziffer (0-9, a-f, A-F).</param>
        <summary>Ruft den Dezimalwert einer Hexadezimalziffer ab.</summary>
        <returns>Ein <see cref="T:System.Int32" />-Wert, der eine Zahl von 0 bis 15 enthält, die der angegebenen Hexadezimalziffer entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.FromHex%2A> -Methode konvertiert ein Zeichen, das eine Hexadezimalziffer darstellt (0-9, a – f, A-F) in einen Dezimalwert (0 bis 15). Wenn `digit` ist es sich nicht um eine gültige hexadezimale steht ein <xref:System.ArgumentException> Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob ein Zeichen ist ein hexadezimales Zeichen, ist es, den entsprechenden decimal-Wert in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="digit" /> ist keine gültige Hexadezimalziffer (0-9, a-f, A-F).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberSignature Language="F#" Value="member this.GetComponents : UriComponents * UriFormat -&gt; string" Usage="uri.GetComponents (components, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="components">Eine bitweise Kombination der <see cref="T:System.UriComponents" />-Werte, die angeben, welche Teile der aktuellen Instanz dem Aufrufer zurückgegeben werden sollen.</param>
        <param name="format">Einer der <see cref="T:System.UriFormat" />-Werte, die steuern, wie Sonderzeichen mit Escapezeichen versehen werden.</param>
        <summary>Ruft die angegebenen Komponenten der aktuellen Instanz mit dem angegebenen Escapeverhalten für Sonderzeichen ab.</summary>
        <returns>Ein <see cref="T:System.String" />, der die Komponenten enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.UriComponents.Query>, <xref:System.UriComponents.Fragment>, <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.UserInfo>, <xref:System.UriComponents.Host>, <xref:System.UriComponents.Port>, und <xref:System.UriComponents.Path> Komponenten beinhalten keine Trennzeichen. Sie kombinieren, können die <xref:System.UriComponents.KeepDelimiter> Flag (mit dem bitweisen OR-Operator) mit einem dieser Werte, die mit dem Trennzeichen zu nutzen. Für alle anderen <xref:System.UriComponents> Werte und Kombinationen von Werten, die Trennzeichen befinden sich in den zurückgegebenen Wert.  
  
 Die Komponenten werden in der Reihenfolge zurückgegeben, die sie im URI angezeigt werden. Z. B. wenn <xref:System.UriComponents.Scheme> angegeben ist, wird zuerst angezeigt.  
  
 Bei der Unterstützung von International Resource Identifier (IRI) und Internationalized Domain Name (IDN) aktiviert ist, wird die Anzahl der Zeichen zurückgegeben, der <xref:System.String> erhöht. Punycode-Namen verwendet, um die Unterstützung von IRI enthalten nur ASCII-Zeichen und beginnen immer mit dem Präfix xn-. Wenn IRI und IDN aktiviert sind, sind ordnungsgemäß von Unicode-Ersatzzeichen behandelt die <xref:System.Uri.GetComponents%2A> Methode.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" für die <xref:System.Uri> Klasse.  
  
> [!NOTE]
>  Wenn die <xref:System.Uri.GetComponents%2A> Methode wird aufgerufen, mit `format` festgelegt <xref:System.UriFormat.Unescaped> , können keine den zurückgegeben Wert als Argument an eine <xref:System.Uri.%23ctor%2A> Konstruktor zur Erstellung von einer entsprechendes <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="components" /> ist keine Kombination von gültigen <see cref="T:System.UriComponents" />-Werten.</exception>
        <exception cref="T:System.InvalidOperationException">Der aktuelle <see cref="T:System.Uri" /> ist kein absoluter URI. Relative URIs können mit dieser Methode nicht verwendet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uri.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Hashcode für den URI ab.</summary>
        <returns>Ein <see cref="T:System.Int32" />, der den für diesen URI generierten Hashwert enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz und gibt den Hashcode auf der Konsole.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberSignature Language="F#" Value="member this.GetLeftPart : UriPartial -&gt; string" Usage="uri.GetLeftPart part" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" />
      </Parameters>
      <Docs>
        <param name="part">Einer der <see cref="T:System.UriPartial" />-Werte, der den Schlussteil des zurückzugebenden URIs angibt.</param>
        <summary>Ruft den angegebenen Teil einer <see cref="T:System.Uri" />-Instanz ab.</summary>
        <returns>Ein <see cref="T:System.String" />, der den angegebenen Teil der <see cref="T:System.Uri" />-Instanz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.GetLeftPart%2A> Methode gibt eine Zeichenfolge, die mit den am weitesten links stehende Teil der URI-Zeichenfolge vom angegebenen Teils `part`.  
  
 <xref:System.Uri.GetLeftPart%2A> enthält die Trennzeichen in den folgenden Fällen:  
  
-   <xref:System.UriPartial.Scheme> Schließt das Schematrennzeichen an.  
  
-   <xref:System.UriPartial.Authority> umfasst nicht das Pfadtrennzeichen.  
  
-   <xref:System.UriPartial.Path> enthält alle Trennzeichen in den ursprünglichen URI bis zu der Abfrage oder Fragment-Trennzeichen.  
  
-   <xref:System.UriPartial.Query> enthält die <xref:System.UriPartial.Path>, sowie die Abfrage und dem Trennzeichen.  
  
 Die folgenden Beispiele zeigen, einen URI und die Ergebnisse des Aufrufs <xref:System.Uri.GetLeftPart%2A> mit <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>, <xref:System.UriPartial.Path>, oder <xref:System.UriPartial.Query>.  
  
|URI|Schema|Zertifizierungsstelle|Pfad|Abfrage|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/index.htm?date=today|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm?date=today|  
|http://www.contoso.com/index.htm#main|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm|  
|mailto:user@contoso.com? Subject = Uri|Mailto:|mailto:user@contoso.com|mailto:user@contoso.com? Subject = Uri|\<Keine >|  
|nntp://news.contoso.com/123456@contoso.com|nntp://|nntp://news.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|Neuigkeiten:|news:123456@contoso.com|news:123456@contoso.com|\<Keine >|  
|file://Server/filename.ext|file://|file://Server|file://Server/filename.ext|file://Server/filename.ext|  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz und den Pfad in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die aktuelle <see cref="T:System.Uri" />-Instanz ist keine absolute Instanz.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene <paramref name="part" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="member this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="uri.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren der <see cref="T:System.Uri" /> erforderlichen Informationen.</param>
        <param name="streamingContext">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt mit der Quelle und dem Ziel des entsprechenden serialisierten Streams für <see cref="T:System.Uri" />.</param>
        <summary>Gibt die Daten zurück, die zum Serialisieren der aktuellen Instanz benötigt werden.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Serialisierungsmethoden verwenden zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberSignature Language="F#" Value="static member HexEscape : char -&gt; string" Usage="System.Uri.HexEscape character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Das in die Hexadezimaldarstellung zu konvertierende Zeichen.</param>
        <summary>Konvertiert ein angegebenes Zeichen in die entsprechende Hexadezimaldarstellung.</summary>
        <returns>Die Hexadezimaldarstellung des angegebenen Zeichens.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel konvertiert ein Zeichen in die hexadezimale Entsprechung und schreibt sie in der Konsole.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="character" /> ist größer als 255.</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberSignature Language="F#" Value="static member HexUnescape : string *  -&gt; char" Usage="System.Uri.HexUnescape (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pattern">Die Hexadezimaldarstellung eines Zeichens.</param>
        <param name="index">Die Stelle in <paramref name="pattern" />, an der die Hexadezimaldarstellung eines Zeichens beginnt.</param>
        <summary>Konvertiert eine angegebene Hexadezimaldarstellung eines Zeichens in das Zeichen selbst.</summary>
        <returns>Das in Hexadezimalcodierung an Position <paramref name="index" /> dargestellte Zeichen. Wenn das Zeichen bei <paramref name="index" /> nicht hexadezimal codiert ist, wird das Zeichen bei <paramref name="index" /> zurückgegeben. Der Wert von <paramref name="index" /> wird erhöht, sodass er auf das nachfolgende Zeichen zeigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im folgenden Codebeispiel wird ermittelt, ob ein Zeichen ist hexadezimal codiert, wenn dies der Fall ist, das entsprechende Zeichen in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 bzw. größer oder gleich der Anzahl von Zeichen in <paramref name="pattern" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : string" Usage="System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Hostkomponente dieser Instanz ab.</summary>
        <value>Ein <see cref="T:System.String" />, der den Hostnamen enthält. Das ist normalerweise der DNS-Hostname oder die IP-Adresse des Servers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den <xref:System.Uri.Authority%2A> Eigenschaft Wert dieser Eigenschaft umfasst nicht die Nummer des Ports.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Hostnamen (www.contoso.com) des Servers in die Konsole geschrieben.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberSignature Language="F#" Value="member this.HostNameType : UriHostNameType" Usage="System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des im URI angegebenen Hostnamens ab.</summary>
        <value>Ein Member aus der <see cref="T:System.UriHostNameType" />-Enumeration.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz und schreibt die <xref:System.Uri.HostNameType%2A> an die Konsole.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IdnHost : string" Usage="System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der zu RFC 3490 kompatible IDN (Internationale Domänenname) des Hosts, wofür ggf. Punycode verwendet wird. Diese Zeichenfolge kann sicher für die DNS-Auflösung verwendet werden, da sie keine Escapezeichen enthält.</summary>
        <value>Der Hostname mit Punycode entsprechend dem IDN-standard formatiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird für die Verwendung von Low-Level-Netzwerkprotokolle bereitgestellt, die den Domänennamen in Ihre Punycode-Entsprechungen Formular erfordern. Wenn Ihr Code keine dieser bestimmte Format erforderlich ist, verwenden Sie <xref:System.Uri.Host%2A> für den Hostnamen.  
  
 Die veraltete <xref:System.Uri.DnsSafeHost%2A> Eigenschaft richtet sich nach *"App.config"* -Einstellungen, die von Windows Store-Anwendungen nicht geändert werden können. IdnHost wird bereitgestellt, als die bevorzugte Alternative zur Verwendung <xref:System.Uri.DnsSafeHost%2A>, da <xref:System.Uri.IdnHost%2A> ist garantiert immer sicher, unabhängig davon, welche aktuellen DNS *"App.config"* Einstellungen möglicherweise.  

 Wenn Sie eine Zeichenfolge mit Escapezeichen, zum Erstellen dieser Instanz verwendet (z. B. "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), klicken Sie dann IdnHost mit Escapezeichen gibt eine Zeichenfolge zurück. Sie sollten unescape-eine beliebige Zeichenfolge mit Escapezeichen von IdnHost zurückgegeben werden, bevor Sie diese Zeichenfolge für DNS-Auflösung verwenden. Beachten Sie, dass bei Verwendung ungültige Zeichenfolge ohne Escapezeichen zum Erstellen dieser Instanz (z. B. "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), und klicken Sie dann auf IdnHost gibt eine Zeichenfolge ohne Escapezeichen.


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbsoluteUri : bool" Usage="System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob die <see cref="T:System.Uri" />-Instanz absolut ist.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn die <see cref="T:System.Uri" />-Instanz absolut ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist `true` Wenn die Zeichenfolge oder <xref:System.Uri> -Instanz, die an den Konstruktor übergeben wurde, kann als absoluter analysiert werden <xref:System.Uri> -Instanz, die ein Schema, eine Zertifizierungsstelle und einen Pfad enthält. Andernfalls die <xref:System.Uri> -Instanz als relativ behandelt und kann das Schema oder andere URI-Komponenten weglassen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsBadFileSystemCharacter : char -&gt; bool&#xA;override this.IsBadFileSystemCharacter : char -&gt; bool" Usage="uri.IsBadFileSystemCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Der zu überprüfende <see cref="T:System.Char" />.</param>
        <summary>Ruft ab, ob ein Zeichen in einem Dateisystemnamen ungültig ist.</summary>
        <returns><see langword="true" />, wenn das angegebene Zeichen ungültig ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Zeichen wird gemäß den Regeln für das NTFS-Dateisystem analysiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.IsBaseOf : Uri -&gt; bool" Usage="uri.IsBaseOf uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Die angegebene <see cref="T:System.Uri" />-Instanz, die getestet werden soll.</param>
        <summary>Bestimmt, ob die aktuelle <see cref="T:System.Uri" />-Instanz eine Basis der angegebenen <see cref="T:System.Uri" />-Instanz ist.</summary>
        <returns><see langword="true" />, wenn die aktuelle <see cref="T:System.Uri" />-Instanz eine Basis von <paramref name="uri" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A> wird verwendet, um die aktuelle vergleichen <xref:System.Uri> Instanz mit einem angegebenen <xref:System.Uri> zu bestimmen, ob dieser URI für die angegebene Basis ist <xref:System.Uri>. Beim Vergleichen von zwei <xref:System.Uri> Objekte, um eine Basisklasse Beziehung, die Benutzerinformationen zu bestimmen (<xref:System.Uri.UserInfo%2A>) wird nicht ausgewertet. Beim Vergleichen von zwei URIs (uri1 und uri2) ist uri1 der Basis von uri2 aus, wenn Sie Wenn Sie alles, was in uri2 nach dem letzten Schrägstrich (/) ignorieren, die zwei URIs identisch sind. Mithilfe von http://host/path/path/file?query als Basis-URI, die folgende Tabelle zeigt, ob es sich um eine Basis für andere URIs ist.  
  
|URI|http://host/path/path/file?query ist der Basis|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|ja|  
|http://host/path/path/#fragment|ja|  
|http://host/path/path/MoreDir/"|ja|  
|http://host/path/path/OtherFile?Query|ja|  
|http://host/path/path/|ja|  
|http://host/path/path/file|ja|  
|http://host/path/path|Nein|  
|http://host/path/path?query|Nein|  
|http://host/path/path#Fragment|Nein|  
|http://host/path/path2/|Nein|  
: //host/path/path2/MoreDir|Nein|  
|http://host/path/File|Nein|  
  
   
  
## Examples  
 In diesem Beispiel wird eine <xref:System.Uri> Instanz, die Basis darstellt <xref:System.Uri> Instanz. Er erstellt dann ein zweites <xref:System.Uri> Instanz aus einer Zeichenfolge. Ruft <xref:System.Uri.IsBaseOf%2A> zu bestimmen, ob die Basis-Instanz auf der Basis der zweiten Instanz ist. Das Ergebnis wird an die Konsole geschrieben.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uri" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefaultPort : bool" Usage="System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob der Portwert im URI der Standardwert für dieses Schema ist.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der Wert in der <see cref="P:System.Uri.Port" />-Eigenschaft der Standardport für dieses Schema ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und überprüft, ob es sich um den Standardport verwendet.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberSignature Language="F#" Value="static member IsExcludedCharacter : char -&gt; bool" Usage="System.Uri.IsExcludedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Der zu überprüfende <see cref="T:System.Char" />.</param>
        <summary>Ruft ab, ob das angegebene Zeichen mit Escapezeichen versehen werden soll.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn das angegebene Zeichen mit Escapezeichen versehen werden muss, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFile : bool" Usage="System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der angegebene <see cref="T:System.Uri" /> ein Datei-URI ist.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der <see cref="T:System.Uri" /> einen Datei-URI darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.IsFile%2A> Eigenschaft `true` bei der <xref:System.Uri.Scheme%2A> -Eigenschaft gleich <xref:System.Uri.UriSchemeFile>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob es sich um ein Datei-URI ist.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberSignature Language="F#" Value="static member IsHexDigit : char -&gt; bool" Usage="System.Uri.IsHexDigit character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Das Zeichen, das validiert werden soll.</param>
        <summary>Bestimmt, ob ein angegebenes Zeichen eine gültige Hexadezimalziffer ist.</summary>
        <returns><see langword="true" />, wenn das Zeichen eine gültige Hexadezimalziffer ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hexadezimale Ziffern sind die Ziffern 0 bis 9 und den Buchstaben A-F bzw. a-f.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob ein Zeichen ist ein hexadezimales Zeichen, ist es, den entsprechenden decimal-Wert in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberSignature Language="F#" Value="static member IsHexEncoding : string * int -&gt; bool" Usage="System.Uri.IsHexEncoding (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pattern">Die zu überprüfende Zeichenfolge.</param>
        <param name="index">Die Stelle in <paramref name="pattern" />, die auf hexadezimale Codierung überprüft werden soll.</param>
        <summary>Bestimmt, ob ein Zeichen in einer Zeichenfolge hexadezimal codiert ist.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn <paramref name="pattern" /> an der angegebenen Position hexadezimal codiert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.IsHexEncoding%2A> Methode prüft auf hexadezimale Codierung das Muster "%hexhex" in eine Zeichenfolge, wobei "hex" eine Ziffer zwischen 0 bis 9 oder ein Buchstabe von A bis F (Groß-/Kleinschreibung).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt, ob ein Zeichen ist hexadezimal codiert, wenn dies der Fall ist, das entsprechende Zeichen in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoopback : bool" Usage="System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob der angegebene <see cref="T:System.Uri" /> auf den lokalen Host verweist.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn dieser <see cref="T:System.Uri" /> auf den lokalen Host verweist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A> Gibt `true` der URI, der beim Erstellen dieser Instanz angegeben war 127.0.0.1, Loopback oder "localhost", oder wenn der URI nicht angegeben haben Hostinformationen (z. B. file:///c:Dir/file.txt). Alle anderen URIs Rückgabe `false`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob es sich um einen lokalen Host verweist.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsReservedCharacter : char -&gt; bool&#xA;override this.IsReservedCharacter : char -&gt; bool" Usage="uri.IsReservedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Der zu überprüfende <see cref="T:System.Char" />.</param>
        <summary>Ruft ab, ob das angegebene Zeichen ein reserviertes Zeichen ist.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn das angegebene Zeichen ein reserviertes Zeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnc : bool" Usage="System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob der angegebene <see cref="T:System.Uri" /> einen UNC-Pfad (Universal Naming Convention) darstellt.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der <see cref="T:System.Uri" /> einen UNC-Pfad darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.IsUnc%2A> Eigenschaft `true` Wenn das angegebene <xref:System.Uri> Instanz ist ein UNC-Pfad (z. B. \\\server\folder oder file://server/folder). Gibt diese Eigenschaft immer `true` , wenn der URI file:// Scheme hat und eine Hostkomponente gibt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob es sich um einen UNC-Pfad ist.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberSignature Language="F#" Value="member this.IsWellFormedOriginalString : unit -&gt; bool" Usage="uri.IsWellFormedOriginalString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob die zum Erstellen dieses <see cref="T:System.Uri" /> verwendete Zeichenfolge wohlgeformt war und keine weiteren Escapezeichen eingefügt werden müssen.</summary>
        <returns><see langword="true" />, wenn die Zeichenfolge wohlgeformt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenfolge wird als wohlgeformt in Übereinstimmung mit RFC 2396 und RFC 2732 in der Standardeinstellung werden. Wenn International Resource Identifiers (IRIs) oder Parsen von Internationalized Domain Name (IDN) aktiviert ist, wird die Zeichenfolge als wohlgeformt in Übereinstimmung mit RFC 3986 und RFC 3987 sein  
  
 Die Zeichenfolge wird als fehlerhaft formuliert, dass die Methode false zurückgibt, wenn eine der folgenden Bedingungen eintritt.  
  
|Fehler|Beispiel|  
|-----------|-------------|  
|Die Zeichenfolge ist nicht ordnungsgemäß mit Escapezeichen versehen.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Name|  
|Die Zeichenfolge ist ein absoluter <xref:System.Uri> , die eine implizite Datei darstellt <xref:System.Uri>.|"c:"\\\directory\filename|  
|Die Zeichenfolge ist ein absoluter URI, der einen Schrägstrich vor dem Pfad nicht vorhanden ist.|file://c:/Directory/FileName|  
|Die Zeichenfolge enthält umgekehrte Schrägstriche ohne Escapezeichen, auch wenn sie als Schrägstriche behandelt werden.|http:\\\host/path/file|  
|Die Zeichenfolge darstellt, einen hierarchischen absoluten <xref:System.Uri> und enthält keine "://".|www.contoso.com/path/file|  
|Der Parser für die <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> gibt an, dass die ursprüngliche Zeichenfolge nicht wohlgeformt war.|Im Beispiel hängt von dem Schema des URI ab.|  
  
 In der Standardeinstellung die Zeichenfolge zum Erstellen dieses <xref:System.Uri> wohlgeformt in Übereinstimmung mit RFC 2396 und RFC 2732 gelten.  
  
 Wenn International Resource Identifier (IRI) und Internationalized Domain Name (IDN)-Unterstützung aktiviert sind, wird die Zeichenfolge, die zum Erstellen dieses <xref:System.Uri> werden als wohlgeformt in Übereinstimmung mit RFC 3986 und RFC 3987 angesehen. Punycode-Namen verwendet, um die Unterstützung von IRI enthalten nur ASCII-Zeichen und beginnen immer mit dem Präfix xn-.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" für die <xref:System.Uri> Klasse.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://www.ietf.org/">Internet Engineering Task Force (IETF)</related>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="static member IsWellFormedUriString : string * UriKind -&gt; bool" Usage="System.Uri.IsWellFormedUriString (uriString, uriKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Die Zeichenfolge, mit der ein <see cref="T:System.Uri" /> erstellt werden soll.</param>
        <param name="uriKind">Der Typ des <see cref="T:System.Uri" /> in <paramref name="uriString" />.</param>
        <summary>Gibt an, ob eine Zeichenfolge wohlgeformt ist, indem versucht wird, einen URI aus der Zeichenfolge zu erstellen. Es wird sichergestellt, dass keine weiteren Escapezeichen in die Zeichenfolge eingefügt werden müssen.</summary>
        <returns><see langword="true" />, wenn die Zeichenfolge wohlgeformt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Versionen von .NET vor Version 4.5 wird standardmäßig die Zeichenfolge wohlgeformt in Übereinstimmung mit RFC 2396 und RFC 2732 betrachtet. Wenn es sich bei International Resource Identifiers (IRIs) oder Analysieren von Internationalized Domain Name (IDN) aktiviert ist, wird die Zeichenfolge wohlgeformt in Übereinstimmung mit RFC 3986 und RFC 3987 angesehen.  
  
 Ab .NET 4.5 ist Zeichenfolgen werden immer als wohlgeformt in Übereinstimmung mit RFC 3986 und RFC 3987, unabhängig davon, ob IRI oder IDN aktiviert sind. Beachten Sie jedoch, dass dies nur für apps, die.NET 4.5 ausgerichtet, sind "true" oder höher. Apps, die auf .NET 4.0 ausgerichtet Kompatibilität Code aufrufen und das alte Verhalten (vor 4.5) auftreten.  
  
 Die Zeichenfolge wird als fehlerhaft formuliert, dass die Methode false zurückgibt, wenn eine der folgenden Bedingungen eintritt  
  
|Fehler|Beispiel|  
|-----------|-------------|  
|Die Zeichenfolge ist nicht ordnungsgemäß mit Escapezeichen versehen.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Name|  
|Die Zeichenfolge ist ein absoluter <xref:System.Uri> , die eine implizite Datei darstellt <xref:System.Uri>.|"c:"\\\directory\filename|  
|Die Zeichenfolge ist ein absoluter URI, der einen Schrägstrich vor dem Pfad nicht vorhanden ist.|file://c:/Directory/FileName|  
|Die Zeichenfolge enthält umgekehrte Schrägstriche ohne Escapezeichen, auch wenn sie als Schrägstriche behandelt werden|http:\\\host/path/file|  
|Die Zeichenfolge darstellt, einen hierarchischen absoluten <xref:System.Uri> und enthält keine "://"|www.contoso.com/path/file|  
|Der Parser für die <xref:System.Uri.Scheme%2A> gibt an, dass die ursprüngliche Zeichenfolge nicht wohlgeformt war.|Im Beispiel hängt von dem Schema des URI ab.|  
|Ab .NET 4.5, relativen URIs mit einem Doppelpunkt (":") im ersten Segment gelten nicht wohlgeformt.|2013.05.29_14:33:41|  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" für die <xref:System.Uri> Klasse.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://www.ietf.org/">Internet Engineering Task Force (IETF)</related>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalPath : string" Usage="System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Darstellung eines Dateinamens im lokalen Betriebssystem ab.</summary>
        <value>Ein <see cref="T:System.String" /> mit der Darstellung eines Dateinamens im lokalen Betriebssystem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert ist ohne Escapezeichen. Wenn der Pfad als Dateipfad Windows erkannt wird, werden alle Schrägstriche (/) durch umgekehrte Schrägstriche ersetzt (\\).  
  
 Für den URI `file://computer/file.ext`, wird der absolute Pfad `/file.ext` und der lokale Pfad ist `\\computer\file.ext`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz und den lokalen Pfad in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelative : Uri -&gt; string" Usage="uri.MakeRelative toUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="toUri">Der mit dem aktuellen URI zu vergleichende URI.</param>
        <summary>Bestimmt den Unterschied zwischen zwei <see cref="T:System.Uri" />-Instanzen.</summary>
        <returns>Wenn der Hostname und das Schema dieser URI-Instanz mit <paramref name="toUri" /> identisch sind, gibt diese Methode einen <see cref="T:System.String" /> zurück, der einen relativen URI darstellt, der beim Anfügen an die aktuelle URI-Instanz den <paramref name="toUri" />-Parameter liefert.  
  
Wenn der Hostname oder das Schema nicht identisch ist, gibt diese Methode einen <see cref="T:System.String" /> zurück, der den <paramref name="toUri" />-Parameter darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt die URI-Instanz `toUri`, und die Ergebnisse des Aufrufs <xref:System.Uri.MakeRelative%2A>.  
  
|Aktuelle URI-Instanz|`toUri`|Rückgabewert|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|Test/Test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|Test1/test1.txt|  
  
 Benutzerinformationen, wird ignoriert, wenn im URI vorhanden ist.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt 2 <xref:System.Uri> Instanzen. Der Unterschied in der die Informationen werden in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Methode ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelativeUri : Uri -&gt; Uri" Usage="uri.MakeRelativeUri uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Der mit dem aktuellen URI zu vergleichende URI.</param>
        <summary>Bestimmt den Unterschied zwischen zwei <see cref="T:System.Uri" />-Instanzen.</summary>
        <returns>Wenn der Hostname und das Schema dieser URI-Instanz mit <paramref name="uri" /> identisch sind, gibt diese Methode einen relativen <see cref="T:System.Uri" /> zurück, der beim Anfügen an die aktuelle URI-Instanz <paramref name="uri" /> liefert.  
  
Wenn der Hostname oder das Schema nicht identisch ist, gibt diese Methode einen <see cref="T:System.Uri" /> zurück, der den <paramref name="uri" />-Parameter darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt die URI-Instanz `toUri`, und die Ergebnisse des Aufrufs <xref:System.Uri.MakeRelativeUri%2A>.  
  
|Aktuelle URI-Instanz|`toUri`|Rückgabewert|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|Test/Test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|Test1/test1.txt|  
  
 Benutzerinformationen, wird ignoriert, wenn im URI vorhanden ist.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt 2 <xref:System.Uri> Instanzen. Der Unterschied in der die Informationen werden in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Uri * Uri -&gt; bool" Usage="uri1 = uri2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Eine <see cref="T:System.Uri" />-Instanz, die mit <paramref name="uri2" /> verglichen werden soll.</param>
        <param name="uri2">Eine <see cref="T:System.Uri" />-Instanz, die mit <paramref name="uri1" /> verglichen werden soll.</param>
        <summary>Bestimmt, ob zwei <see cref="T:System.Uri" />-Instanzen denselben Wert haben.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn die <see cref="T:System.Uri" />-Instanzen äquivalent sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung verwendet die <xref:System.Uri.Equals%2A> Methode, um zu bestimmen, ob die beiden <xref:System.Uri> -Instanzen äquivalent sind. <xref:System.Uri.UserInfo%2A> und <xref:System.Uri.Fragment%2A> Inhalt wird ignoriert, wenn dieser Vergleich durchgeführt.  
  
   
  
## Examples  
 In diesem Beispiel erstellt drei <xref:System.Uri> -Instanzen aus Zeichenfolgen und miteinander verglichen, um zu bestimmen, ob sie den gleichen Wert darstellen. `Address1` und `Address2` sind gleich, da die <xref:System.Uri.Fragment%2A> Teil wird für diesen Vergleich ignoriert. Das Ergebnis wird an die Konsole geschrieben.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Uri * Uri -&gt; bool" Usage="System.Uri.op_Inequality (uri1, uri2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Eine <see cref="T:System.Uri" />-Instanz, die mit <paramref name="uri2" /> verglichen werden soll.</param>
        <param name="uri2">Eine <see cref="T:System.Uri" />-Instanz, die mit <paramref name="uri1" /> verglichen werden soll.</param>
        <summary>Bestimmt, ob zwei <see cref="T:System.Uri" />-Instanzen verschiedene Werte haben.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn die beiden <see cref="T:System.Uri" />-Instanzen ungleich sind, andernfalls <see langword="false" />. Wenn einer der Parameter <see langword="null" /> ist, gibt diese Methode <see langword="true" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung verwendet die <xref:System.Uri.Equals%2A> Methode, um zu bestimmen, ob die beiden <xref:System.Uri> -Instanzen nicht äquivalent sind. <xref:System.Uri.UserInfo%2A> und <xref:System.Uri.Fragment%2A> Inhalt wird ignoriert, wenn dieser Vergleich durchgeführt.  
  
   
  
## Examples  
 In diesem Beispiel erstellt drei <xref:System.Uri> -Instanzen aus Zeichenfolgen und miteinander verglichen, um zu bestimmen, ob sie den gleichen Wert darstellen. `Address2` und `Address3` sind nicht identisch, weil `Address3` enthält eine <xref:System.Uri.Query%2A> , wurde nicht gefunden im `Address2`. Das Ergebnis wird an die Konsole geschrieben.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalString : string" Usage="System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die ursprüngliche URI-Zeichenfolge ab, die an den <see cref="T:System.Uri" />-Konstruktor übergeben wurde.</summary>
        <value>Ein <see cref="T:System.String" />, der exakt den URI enthält, der beim Erstellen dieser Instanz angegeben wurde, andernfalls <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der URI-Konstruktor angegebenen enthalten führende oder nachfolgende Leerzeichen, werden diese Leerzeichen beibehalten.  
  
 Der von dieser Eigenschaft zurückgegebene Wert unterscheidet sich von <xref:System.Uri.ToString%2A> und <xref:System.Uri.AbsoluteUri%2A>. <xref:System.Uri.ToString%2A> die kanonisch ohne Escapezeichen Form des URI zurückgegeben. <xref:System.Uri.AbsoluteUri%2A> Gibt die Form des URIS, die kanonisch mit Escapezeichen zurück.  
  
 Wenn die Unterstützung von International Resource Identifier (IRI) und Internationalized Domain Name (IDN) aktiviert, <xref:System.Uri.OriginalString%2A> gibt die ursprüngliche nicht normalisierte Zeichenfolge mit Punycode-Hostnamen zurück, sofern einer, zum Initialisieren verwendet wurde der <xref:System.Uri> Instanz. Punycode-Namen enthalten nur ASCII-Zeichen und beginnen immer mit dem Präfix „xn--“.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" für die <xref:System.Uri> Klasse.  
  
 Wenn eine <xref:System.Uri> Objekt serialisiert wird, die <xref:System.Uri.OriginalString%2A> wird nicht beibehalten. Der Serialisierungsprozess verwendet, die vollständig mit Escapezeichen und kanonisierte <xref:System.Uri.AbsoluteUri%2A> Eigenschaft bei der Serialisierung. Für eine <xref:System.Uri> , die eine IPv6-Adresse enthält, die IPv6-Adresse und die Bereichs-ID sind enthalten in der serialisierten <xref:System.Uri> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Uri> Instanz aus einer Zeichenfolge. Veranschaulicht den Unterschied zwischen den Rückgabewert aus <xref:System.Uri.OriginalString%2A>, womit die Zeichenfolge, die übergeben wurde, an den Konstruktor, und von einem Aufruf von <xref:System.Uri.ToString%2A>, die die kanonische Form der Zeichenfolge zurückgibt.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; unit&#xA;override this.Parse : unit -&gt; unit" Usage="uri.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analysiert den URI der aktuellen Instanz, um sicherzustellen, dass alle für einen gültigen URI erforderlichen Teile enthalten sind.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">Der vom Konstruktor übergebene URI ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathAndQuery : string" Usage="System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die durch ein Fragezeichen (?) getrennten Werte der <see cref="P:System.Uri.AbsolutePath" />-Eigenschaft und der <see cref="P:System.Uri.Query" />-Eigenschaft ab.</summary>
        <value>Ein <see cref="T:System.String" />, der die durch ein Fragezeichen (?) getrennten Werte der <see cref="P:System.Uri.AbsolutePath" />-Eigenschaft und der <see cref="P:System.Uri.Query" />-Eigenschaft enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.PathAndQuery%2A> Eigenschaft enthält den absoluten Pfad auf dem Server und die Abfrageinformationen, die mit der Anforderung gesendet. Es ist identisch mit der Verkettung der <xref:System.Uri.AbsolutePath%2A> und <xref:System.Uri.Query%2A> Eigenschaften.  
  
 Die <xref:System.Uri.PathAndQuery%2A> Eigenschaft gemäß RFC 2396 standardmäßig geschützt ist. Wenn International Resource Identifiers (IRIs) oder Parsen von Internationalized Domain Name (IDN) aktiviert ist, die <xref:System.Uri.PathAndQuery%2A> Eigenschaft wird gemäß RFC 3986 und RFC 3987 mit Escapezeichen versehen.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" für die <xref:System.Uri> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt die URI-Pfad (/ /catalog/shownew.htm) und Abfrage (Date = today) auf der Konsole.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Port : int" Usage="System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anschlussnummer dieses URIs ab.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der die Portnummer für diesen URI enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Nummer des Ports definiert, den Port des Protokolls für die Kontaktaufnahme mit dem Server, auf die im URI verwiesen wird, verwendet wird. Wenn ein Port nicht, als Teil des URI angegeben ist, der <xref:System.Uri.Port%2A> Eigenschaft der Standardwert für das Protokoll zurückgegeben. Wenn es keine Standard-Portnummer ist, gibt diese Eigenschaft-1 zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die URI-Portnummer an die Konsole geschrieben. In diesem Fall ist der Wert die Standardportnummer für HTTP Port 80.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Query : string" Usage="System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft im angegebenen URI enthaltene Abfrageinformationen ab.</summary>
        <value>Ein <see cref="T:System.String" /> mit den im angegebenen URI enthaltenen Abfrageinformationen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.Query%2A> Eigenschaft enthält den URI enthaltenen Abfrageinformationen. Abfrageinformationen, die von der die Informationen durch ein Fragezeichen (?) getrennt ist und bis zum Ende des URIS. Die Abfrageinformationen zurückgegeben, enthält das vorangestellte Fragezeichen.  
  
 Die Abfrageinformationen wird gemäß RFC 2396 werden standardmäßig mit Escapezeichen versehen. Wenn International Resource Identifiers (IRIs) oder Parsen von Internationalized Domain Name (IDN) aktiviert ist, wird die Abfrageinformationen gemäß RFC 3986 und RFC 3987 mit Escapezeichen versehen.  
  
 Weitere Informationen zur IRI-Unterstützung finden Sie im Abschnitt "Hinweise" für die <xref:System.Uri> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel schreibt die Abfrage? Date = today an die Konsole.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Schemas für diesen URI ab.</summary>
        <value>Ein <see cref="T:System.String" />, der das in Kleinbuchstaben umgewandelte Schema für diesen URI enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.Scheme%2A> Eigenschaft gibt das Schema, das zum Initialisieren der <xref:System.Uri> Instanz. Diese Eigenschaft nicht, dass das Schema zum Initialisieren verwendet die <xref:System.Uri> Instanz wurde erkannt.  
  
 Die folgende Tabelle zeigt einige Beispiele für mögliche Werte zurückgegeben werden, indem die <xref:System.Uri.Scheme%2A> Eigenschaft.  
  
|Schema|Beschreibung |  
|------------|-----------------|  
|Datei|Die Ressource ist eine Datei auf dem lokalen Computer.|  
|ftp|Die Ressource wird über FTP zugegriffen.|  
|Gopher|Die Ressource erfolgt über das Gopher-Protokoll.|  
|http|Die Ressource wird über HTTP zugegriffen werden.|  
|https|Die Ressource wird über SSL verschlüsselte HTTP zugegriffen.|  
|LDAP|Die Ressource erfolgt über das LDAP-Protokoll.|  
|mailto|Die Ressource wird eine e-Mail-Adresse und über den SMTP-Protokoll zugegriffen.|  
|net.pipe|Die Ressource erfolgt über eine named Pipe.|  
|net.tcp|Die Ressource erfolgt über TCP-Endpunkt.|  
|news|Die Ressource erfolgt über das NNTP-Protokoll.|  
|NNTP|Die Ressource erfolgt über das NNTP-Protokoll.|  
|telnet|Die Ressource wird durch das TELNET-Protokoll zugegriffen.|  
|uuid|Die Ressource wird durch einen eindeutigen Namen der UUID-Endpunkt für die Kommunikation mit einem Dienst zugegriffen werden.|  
  
   
  
## Examples  
 Das folgende Beispiel gibt den Namen des Schemas (http) auf der Konsole für die http://www.contoso.com/ URI.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable SchemeDelimiter : string" Usage="System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Zeichen an, die das Schema des Kommunikationsprotokolls vom Adressteil des URIs trennen. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine Zeichenfolge mit <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>, und eine Adresse. Ein <xref:System.Uri> Instanz wird dann aus der Zeichenfolge erstellt.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Segments : string[]" Usage="System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Array mit den Pfadsegmenten ab, aus denen sich der angegebene URI zusammensetzt.</summary>
        <value>Ein <see cref="T:System.String" />-Array mit den Pfadsegmenten, aus denen sich der angegebene URI zusammensetzt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.Segments%2A> Eigenschaft gibt ein Array von Zeichenfolgen, die die "Segmente" (Teilzeichenfolgen), die den URIs absolute Pfad zu bilden. Das erste Segment wird durch die Analyse des absoluten Pfads vom ersten Zeichen, bis zu einem Schrägstrich (/) oder das Ende des Pfads abgerufen. Jedes zusätzliche Segment am ersten Zeichen nach dem vorherigen Segment beginnt und endet mit dem nächsten Schrägstrich oder das Ende des Pfads. (Ein URI, den absolute Pfad enthält alles, was nach den Host und Port und vor der Abfrage und Fragment).  
  
 Das folgende Beispiel zeigt den absoluten Pfad und Segmenten für zwei URIs an. Das zweite Beispiel zeigt, dass das Fragment und die Abfrage nicht Teil der absolute Pfad sind, und daher keine Segmente sind.  
  
 Absoluter URI sein:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 Absoluter Pfad:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmente:  
 - /
 - Kapitel /
 - Chapter1 /
 - Abschnitte /
 - Section1.htm  
  
 Absoluter URI sein:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO  
  
 Absoluter Pfad:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmente:  
 - /
 - Kapitel /
 - Chapter1 /
 - Abschnitte /
 - Section1.htm  
  
 Beachten Sie, da der absolute Pfad beginnt mit "/", das erste Segment es und nichts enthält.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz mit 3 Segmente, und klicken Sie auf dem Bildschirm angezeigt.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren der <see cref="T:System.Uri" /> erforderlichen Informationen.</param>
        <param name="streamingContext">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt mit der Quelle und dem Ziel des entsprechenden serialisierten Streams für <see cref="T:System.Uri" />.</param>
        <summary>Gibt die Daten zurück, die zum Serialisieren der aktuellen Instanz benötigt werden.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Serialisierungsmethoden verwenden zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uri.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine kanonische Zeichenfolgenentsprechung der angegebenen <see cref="T:System.Uri" />-Instanz ab.</summary>
        <returns>Eine <see cref="T:System.String" />-Instanz, die eine kanonische Darstellung der <see cref="T:System.Uri" />-Instanz enthält, die nicht mit Escapezeichen versehen wurde. #, ? und % sind die einzigen Zeichen, die mit Escapezeichen versehen sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die von dieser Methode zurückgegebene Zeichenfolge enthält keine Portinformationen, wenn der Port der Standardport für das Schema ist.  
  
> [!NOTE]
>  Die zurückgegebene Zeichenfolge den <xref:System.Uri.ToString%2A> Methode darf die Steuerzeichen, die den Zustand einer Konsolenanwendung beschädigt werden können. Können Sie die <xref:System.Uri.GetComponents%2A> -Methode mit dem <xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType> Format Steuerzeichen aus der zurückgegebenen Zeichenfolge zu entfernen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Uri> Instanz aus einer Zeichenfolge. Veranschaulicht den Unterschied zwischen den Rückgabewert aus <xref:System.Uri.OriginalString%2A>, womit die Zeichenfolge, die übergeben wurde, an den Konstruktor, und von einem Aufruf von <xref:System.Uri.ToString%2A>, die die kanonische Form der Zeichenfolge zurückgibt.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">um zu verhindern, dass teilweise vertrauenswürdigen Code Ableiten von <see cref="T:System.Uri" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Uri" />. Löst keine Ausnahme aus, wenn <see cref="T:System.Uri" /> nicht erstellt werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : string * UriKind *  -&gt; bool" Usage="System.Uri.TryCreate (uriString, uriKind, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uriString">Der <see cref="T:System.String" />, der den <see cref="T:System.Uri" /> darstellt.</param>
        <param name="uriKind">Der Typ des Uris.</param>
        <param name="result">Diese Methode gibt den erstellten <see cref="T:System.Uri" /> zurück.</param>
        <summary>Erstellt mit der angegebenen <see cref="T:System.Uri" />-Instanz und einer <see cref="T:System.String" /> einen neuen <see cref="T:System.UriKind" />.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der <see cref="T:System.Uri" /> erfolgreich erstellt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode zurückgibt `true`, die neue <xref:System.Uri> befindet sich im `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * string *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">Der Basis-<see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Der relative <see cref="T:System.Uri" />, dargestellt als ein <see cref="T:System.String" />, der dem Basis-<see cref="T:System.Uri" /> hinzugefügt werden soll.</param>
        <param name="result">Enthält nach dem Beenden der Methode einen aus <see cref="T:System.Uri" /> und <paramref name="baseUri" /> erstellten <paramref name="relativeUri" />. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Erstellt mit der angegebenen Basis und den relativen <see cref="T:System.Uri" />-Instanzen einen neuen <see cref="T:System.String" />.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der <see cref="T:System.Uri" /> erfolgreich erstellt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode zurückgibt `true`, die neue <xref:System.Uri> befindet sich im `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * Uri *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">Der Basis-<see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Der relative <see cref="T:System.Uri" />, der dem Basis-<see cref="T:System.Uri" /> hinzugefügt werden soll.</param>
        <param name="result">Enthält nach dem Beenden der Methode einen aus <see cref="T:System.Uri" /> und <paramref name="baseUri" /> erstellten <paramref name="relativeUri" />. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Erstellt mit der angegebenen Basis und den relativen <see cref="T:System.Uri" />-Instanzen einen neuen <see cref="T:System.Uri" />.</summary>
        <returns>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der <see cref="T:System.Uri" /> erfolgreich erstellt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode zurückgibt `true`, die neue <xref:System.Uri> befindet sich im `result`.  
  
 Diese Methode erstellt den URI, in kanonischer Form eingefügt und überprüft sie. Wenn eine nicht behandelte Ausnahme auftritt, werden Sie von dieser Methode abgefangen. Wenn Sie erstellen möchten eine <xref:System.Uri> und verwenden Sie eine der Ausnahmen erhalten die <xref:System.Uri.%23ctor%2A> Konstruktoren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member Unescape : string -&gt; string&#xA;override this.Unescape : string -&gt; string" Usage="uri.Unescape path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die zu konvertierende <see cref="T:System.String" />.</param>
        <summary>Konvertiert die angegebene Zeichenfolge, indem alle Escapesequenzen durch die entsprechende Darstellung ohne Escapezeichen ersetzt werden.</summary>
        <returns>Ein <see cref="T:System.String" />, der den Wert des <paramref name="path" />-Parameters ohne Escapezeichen enthält.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberSignature Language="F#" Value="static member UnescapeDataString : string -&gt; string" Usage="System.Uri.UnescapeDataString stringToUnescape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">Die Zeichenfolge, deren Escapezeichen entfernt werden sollen.</param>
        <summary>Konvertiert eine Zeichenfolge in eine Darstellung ohne Escapezeichen.</summary>
        <returns>Ein <see cref="T:System.String" />, der die Darstellung von <paramref name="stringToUnescape" /> ohne Escapezeichen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten diese Methode mit Vorsicht verwenden. Entfernen von Escapezeichen eine Zeichenfolge, die zuvor Escapezeichen entfernt wurden, kann dies zu Mehrdeutigkeiten und Fehlern führen.  
  
 Viele Webbrowser als Leerzeichen innerhalb von URIs in Plus Escapezeichen ("+") Zeichen. Allerdings ist die UnescapeDataString-Methode nicht und Zeichen in Leerzeichen konvertieren, da dieses Verhalten nicht über alle URI-Schemas standard ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird einen URI entfernt und eine plus-Zeichen ("+") in Leerzeichen konvertiert.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToUnescape" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFile : string" Usage="System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass der URI ein Zeiger auf eine Datei ist. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework, Version 1.1 ein "`file:///path`"URI wurde in übersetzt"`file:/path`". Dies wurde für Version 2.0 behoben.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeFile>.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFtp : string" Usage="System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass auf den URI über FTP (File Transfer Protocol) zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeFtp>.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeGopher : string" Usage="System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass auf den URI über das Gopher-Protokoll zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeGopher>.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttp : string" Usage="System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass auf den URI über HTTP (Hypertext Transfer Protocol) zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeHttp>.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttps : string" Usage="System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass auf den URI über HTTPS (Secure Hypertext Transfer Protocol) zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeHttps>.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeMailto : string" Usage="System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass der URI eine E-Mail-Adresse ist und der Zugriff über SMTP (Simple Mail Transport Protocol) erfolgt. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeMailto>.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetPipe : string" Usage="System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass auf den URI über das von Windows Communication Foundation (WCF) verwendete NetPipe-Schema zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetTcp : string" Usage="System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass auf den URI über das von Windows Communication Foundation (WCF) verwendete NetTcp-Schema zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNews : string" Usage="System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass der URI eine Internetnewsgroup ist, auf die über NNTP (Network News Transport Protocol) zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeNews>.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNntp : string" Usage="System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass der URI eine Internetnewsgroup ist, auf die über NNTP (Network News Transport Protocol) zugegriffen wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dem Übertragungsprotokoll NNTP <xref:System.Uri> Analysefehler in .NET Framework Version 1.1 wurden behoben.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob das Schema ist <xref:System.Uri.UriSchemeNntp>.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserEscaped : bool" Usage="System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass die URI-Zeichenfolge vor dem Erstellen der <see cref="T:System.Uri" />-Instanz vollständig mit Escapezeichen versehen war.</summary>
        <value>Ein <see cref="T:System.Boolean" />-Wert, der <see langword="true" /> ist, wenn der <paramref name="dontEscape" />-Parameter auf <see langword="true" /> festgelegt wurde, als die <see cref="T:System.Uri" />-Instanz erstellt wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri.UserEscaped%2A> -Eigenschaftensatz auf `true` um anzugeben, dass die Zeichenfolge, die zum Erstellen verwendet die <xref:System.Uri> Instanz wurde vollständig mit Escapezeichen, bevor sie an den Konstruktor übergeben wurde, d. h. die `dontEscape` Parameter, der den Konstruktoraufruf auf festgelegtwurde`true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> Instanz, und bestimmt, ob sie vollständig mit Escapezeichen versehen wurde bei der Erstellung.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInfo : string" Usage="System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Benutzernamen, Kennwort oder weitere benutzerspezifische Informationen ab, die dem angegebenen URI zugeordnet sind.</summary>
        <value>Ein <see cref="T:System.String" />, der die dem URI zugeordneten Benutzerinformationen enthält. Der zurückgegebene Wert schließt nicht das '@'-Zeichen ein, das zum Begrenzen des Benutzerinformationsteils des URIs reserviert ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert ist in der Regel im Format "Benutzername".  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Uri> -Instanz und die Benutzerinformationen in die Konsole geschrieben.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Instanz stellt einen relativen URI dar, diese Eigenschaft ist jedoch nur für absolute URIs gültig.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
