<Type Name="MathF" FullName="System.MathF">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6b72284d390ede7fa9e0265550f568899dce9d8d" /><Meta Name="ms.sourcegitcommit" Value="a9b8eb12d69b131f7c0de74d471798e44e863282" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="06/04/2019" /><Meta Name="ms.locfileid" Value="66501877" /></Metadata><TypeSignature Language="C#" Value="public static class MathF" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MathF extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MathF" />
  <TypeSignature Language="VB.NET" Value="Public Class MathF" />
  <TypeSignature Language="C++ CLI" Value="public ref class MathF abstract sealed" />
  <TypeSignature Language="F#" Value="type MathF = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Konstanten und statische Methoden für trigonometrische, logarithmische und andere gebräuchliche mathematische Funktionen bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

Die statische Felder und Methoden des der `MathF` Klasse entsprechen denen des der <xref:System.Math> Klasse, mit dem Unterschied, dass ihre Parameter vom Typ sind <xref:System.Single> statt <xref:System.Double>, und geben sie zurück <xref:System.Single> statt <xref:System.Double> Werte.

         ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Abs(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Abs(float x);" />
      <MemberSignature Language="F#" Value="static member Abs : single -&gt; single" Usage="System.MathF.Abs x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Eine Zahl, die größer oder gleich <see cref="F:System.Single.MinValue" />, aber kleiner oder gleich <see cref="F:System.Single.MaxValue" /> ist.</param>
        <summary>Gibt den absoluten Wert einer Gleitkommazahl mit einfacher Genauigkeit zurück.</summary>
        <returns>Eine Gleitkommazahl x mit einfacher Genauigkeit im Bereich 0 ≤ x ≤ <see cref="F:System.Single.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Absolute Wert des einem <xref:System.Single> ist der numerische Wert ohne Vorzeichen. Beispielsweise wird der Absolute Wert von 1.2e-03 und-1.2e03 ist-1.2e03.  
  
 Wenn `x` gleich <xref:System.Single.NegativeInfinity> oder <xref:System.Single.PositiveInfinity>, der Rückgabewert ist <xref:System.Single.PositiveInfinity>. Wenn `x` gleich <xref:System.Single.NaN>, der Rückgabewert ist <xref:System.Single.NaN>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static float Acos (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Acos(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Acos(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Acos(float x);" />
      <MemberSignature Language="F#" Value="static member Acos : single -&gt; single" Usage="System.MathF.Acos x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Eine Zahl, die einen Kosinus darstellt, wobei <paramref name="x" /> größer oder gleich -1, aber kleiner oder gleich 1 sein muss.</param>
        <summary>Gibt einen Winkel zurück, dessen Kosinus die angegebene Zahl ist.</summary>
        <returns>Ein Winkel (θ) im Bogenmaß im Bereich 0 ≤ θ ≤ π.
  
- oder - 
 <see cref="F:System.Single.NaN" />, wenn <paramref name="x" /> &lt; –1 oder <paramref name="x" /> &gt; 1 oder <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiplizieren Sie den Rückgabewert mit 180 /<xref:System.MathF.PI?displayProperty=nameWithType> zur Konvertierung von Bogenmaß in Grad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh">
      <MemberSignature Language="C#" Value="public static float Acosh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Acosh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Acosh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acosh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Acosh(float x);" />
      <MemberSignature Language="F#" Value="static member Acosh : single -&gt; single" Usage="System.MathF.Acosh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x">Eine Zahl, die einen hyperbolischen Kosinus darstellt, wobei <paramref name="x" /> größer oder gleich 1, aber kleiner oder gleich <see cref="F:System.Single.PositiveInfinity" /> sein muss.</param>
        <summary>Gibt den Winkel zurück, dessen hyperbolischer Kosinus die angegebene Zahl ist.</summary>
        <returns>Ein Winkel (θ) im Bogenmaß im Bereich 0 ≤ θ ≤ ∞.
  
- oder - 
 <see cref="F:System.Single.NaN" /> wenn <paramref name="x" /> &lt; 1 oder <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiplizieren Sie den Rückgabewert mit 180 /<xref:System.MathF.PI?displayProperty=nameWithType> zur Konvertierung von Bogenmaß in Grad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static float Asin (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Asin(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Asin(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Asin(float x);" />
      <MemberSignature Language="F#" Value="static member Asin : single -&gt; single" Usage="System.MathF.Asin x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Eine Zahl, die einen Sinus darstellt, wobei <paramref name="x" /> größer oder gleich -1, aber kleiner oder gleich 1 sein muss.</param>
        <summary>Gibt einen Winkel zurück, dessen Sinus die angegebene Zahl ist.</summary>
        <returns>Ein Winkel (θ) im Bogenmaß im Bereich -π/2 ≤ θ ≤ π/2.
  
- oder - 
 <see cref="F:System.Single.NaN" />, wenn <paramref name="x" /> &lt; –1 oder <paramref name="x" /> &gt; 1 oder <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein positiver Rückgabewert darstellt einen Winkel gegen den Uhrzeigersinn von der x-Achse ein negativer Rückgabewert darstellt, einen Winkel im Uhrzeigersinn.  
  
 Multiplizieren Sie den Rückgabewert mit 180 /<xref:System.MathF.PI?displayProperty=nameWithType> zur Konvertierung von Bogenmaß in Grad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh">
      <MemberSignature Language="C#" Value="public static float Asinh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Asinh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Asinh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asinh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Asinh(float x);" />
      <MemberSignature Language="F#" Value="static member Asinh : single -&gt; single" Usage="System.MathF.Asinh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x">Eine Zahl, die einen hyperbolischen Sinus darstellt, wobei <paramref name="x" /> größer oder gleich <see cref="F:System.Single.NegativeInfinity" />, aber kleiner oder gleich <see cref="F:System.Single.PositiveInfinity" /> sein muss.</param>
        <summary>Gibt den Winkel zurück, dessen hyperbolischer Sinus die angegebene Zahl ist.</summary>
        <returns>Ein Winkel (θ) im Bogenmaß sodass -∞ &lt; θ ≤ -1, oder 1 ≤ θ &lt; ∞. 
  
- oder - 
 <see cref="F:System.Single.NaN" /> wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiplizieren Sie den Rückgabewert mit 180 /<xref:System.MathF.PI?displayProperty=nameWithType> zur Konvertierung von Bogenmaß in Grad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static float Atan (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atan(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atan(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atan(float x);" />
      <MemberSignature Language="F#" Value="static member Atan : single -&gt; single" Usage="System.MathF.Atan x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Eine Zahl, die einen Tangens darstellt.</param>
        <summary>Gibt einen Winkel zurück, dessen Tangens die angegebene Zahl ist.</summary>
        <returns>Ein Winkel (θ) im Bogenmaß im Bereich -π/2 ≤ θ ≤ π/2.  
  
- oder - 
 <see cref="F:System.Single.NaN" />, wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> ist, –π/2 auf doppelte Genauigkeit gerundet (–1,5707963267949), wenn <paramref name="x" /> gleich <see cref="F:System.Single.NegativeInfinity" /> ist oder π/2 auf doppelte Genauigkeit gerundet (1,5707963267949), wenn <paramref name="x" /> gleich <see cref="F:System.Single.PositiveInfinity" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein positiver Rückgabewert darstellt einen Winkel gegen den Uhrzeigersinn von der x-Achse ein negativer Rückgabewert darstellt, einen Winkel im Uhrzeigersinn.  
  
 Multiplizieren Sie den Rückgabewert mit 180 /<xref:System.MathF.PI?displayProperty=nameWithType> zur Konvertierung von Bogenmaß in Grad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static float Atan2 (float y, float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atan2(float32 y, float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atan2(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Single, x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atan2(float y, float x);" />
      <MemberSignature Language="F#" Value="static member Atan2 : single * single -&gt; single" Usage="System.MathF.Atan2 (y, x)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="y">Die y-Koordinate eines Punkts.</param>
        <param name="x">Die x-Koordinate eines Punkts.</param>
        <summary>Gibt einen Winkel zurück, dessen Tangens der Quotient zweier angegebener Zahlen ist.</summary>
        <returns>Ein Winkel (θ) im Bogenmaß im Bereich –π ≤ θ ≤ π, und tan(θ) = <paramref name="y" /> / <paramref name="x" />, wobei (<paramref name="x" />, <paramref name="y" />) einen Punkt in der kartesischen Ebene darstellt. Beachten Sie dabei: 
–   Wenn (<paramref name="x" />, <paramref name="y" />) im 1. Quadranten liegt, gilt 0 &lt; θ &lt; π/2.  
  
–   Wenn (<paramref name="x" />, <paramref name="y" />) im 2. Quadranten liegt, gilt π/2 &lt; θ ≤ π.  
  
–   Wenn (<paramref name="x" />, <paramref name="y" />) im 3. Quadranten liegt, gilt –π &lt; θ &lt; –π/2.  
  
–   Wenn (<paramref name="x" />, <paramref name="y" />) im 4. Quadranten liegt, gilt –π/2 &lt; θ &lt; 0.  
  
Für Punkte an den Begrenzungen der Quadranten wird der folgende Rückgabewert zurückgegeben: 
–   Wenn y gleich 0 und x nicht negativ ist, gilt θ = 0.  
  
–   Wenn y gleich 0 und x negativ ist, gilt θ = π.  
  
–   Wenn y positiv und x gleich 0 ist, gilt θ = π/2.  
  
–   Wenn y negativ ist und x gleich 0 ist, gilt θ = -π/2.  
  
–   Wenn y gleich 0 ist und x gleich 0 ist, gilt θ = 0.  
  
Wenn <paramref name="x" /> oder <paramref name="y" /> gleich <see cref="F:System.Single.NaN" /> ist oder wenn <paramref name="x" /> und <paramref name="y" /> entweder gleich <see cref="F:System.Single.PositiveInfinity" /> oder gleich <see cref="F:System.Single.NegativeInfinity" /> sind, gibt die Methode <see cref="F:System.Single.NaN" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist der Winkel in der kartesischen Ebene zwischen der x-Achse und ein Vektor vom Ursprung (0,0), an dem Punkt, (X, y).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh">
      <MemberSignature Language="C#" Value="public static float Atanh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atanh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atanh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atanh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atanh(float x);" />
      <MemberSignature Language="F#" Value="static member Atanh : single -&gt; single" Usage="System.MathF.Atanh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x">Eine Zahl, die einen hyperbolischen Tangens darstellt, wobei <paramref name="x" /> größer oder gleich -1, aber kleiner oder gleich 1 sein muss.</param>
        <summary>Gibt den Winkel zurück, dessen hyperbolischer Tangens die angegebene Zahl ist.</summary>
        <returns>Ein Winkel (θ) im Bogenmaß im Bereich -∞ &lt; θ &lt;-1, oder 1 &lt; θ &lt; ∞.  
  
- oder - 
 <see cref="F:System.Single.NaN" />, wenn <paramref name="x" /> &lt; –1 oder <paramref name="x" /> &gt; 1 oder <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiplizieren Sie den Rückgabewert mit 180 /<xref:System.MathF.PI?displayProperty=nameWithType> zur Konvertierung von Bogenmaß in Grad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitDecrement">
      <MemberSignature Language="C#" Value="public static float BitDecrement (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 BitDecrement(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.BitDecrement(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitDecrement (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float BitDecrement(float x);" />
      <MemberSignature Language="F#" Value="static member BitDecrement : single -&gt; single" Usage="System.MathF.BitDecrement x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Der zu dekrementierende Wert.</param>
        <summary>Gibt den nächsten kleinsten Wert zurück, der weniger als <paramref name="x" /> vergleicht.</summary>
        <returns>Der nächste kleinste Wert, der weniger als <paramref name="x" /> vergleicht.
  
- oder - 
 <see cref="F:System.Single.NegativeInfinity" /> wenn <paramref name="x" /> ist gleich <see cref="F:System.Single.NegativeInfinity" />.
  
- oder - 
 <see cref="F:System.Single.NaN" /> wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="BitIncrement">
      <MemberSignature Language="C#" Value="public static float BitIncrement (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 BitIncrement(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.BitIncrement(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitIncrement (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float BitIncrement(float x);" />
      <MemberSignature Language="F#" Value="static member BitIncrement : single -&gt; single" Usage="System.MathF.BitIncrement x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Der zu inkrementierende Wert.</param>
        <summary>Gibt den nächsten größten Wert zurück, der größer als <paramref name="x" /> ist.</summary>
        <returns>Der nächste größte Wert, der größer als <paramref name="x" /> ist.
  
- oder - 
 <see cref="F:System.Single.PositiveInfinity" /> wenn <paramref name="x" /> gleich <see cref="F:System.Single.PositiveInfinity" />.
  
- oder - 
 <see cref="F:System.Single.NaN" /> wenn <paramref name="x" /> ist gleich <see cref="F:System.Single.NaN" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt">
      <MemberSignature Language="C#" Value="public static float Cbrt (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cbrt(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cbrt(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cbrt (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cbrt(float x);" />
      <MemberSignature Language="F#" Value="static member Cbrt : single -&gt; single" Usage="System.MathF.Cbrt x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x">Die Zahl, deren Kubikwurzel bestimmt werden soll.</param>
        <summary>Gibt die Kubikwurzel einer angegebenen Zahl zurück.</summary>
        <returns>Die Kubikwurzel von <paramref name="x" />.
  
- oder - 
 <see cref="F:System.Single.NaN" /> wenn <paramref name="x" /> ist gleich <see cref="F:System.Single.NaN" />.</returns>
        <remarks></remarks>
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static float Ceiling (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Ceiling(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Ceiling(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Ceiling(float x);" />
      <MemberSignature Language="F#" Value="static member Ceiling : single -&gt; single" Usage="System.MathF.Ceiling x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt den kleinsten ganzzahligen Wert zurück, der größer oder gleich der angegebenen Gleitkommazahl mit einfacher Genauigkeit ist.</summary>
        <returns>Der kleinste ganzzahlige Wert, der größer oder gleich <paramref name="x" /> ist. Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird dieser Wert zurückgegeben. Beachten Sie, dass diese Methode einen <see cref="T:System.Single" /> anstelle eines ganzzahligen Typs zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten dieser Methode folgt Standard IEEE-754, Abschnitt 4. Diese Art der Rundung wird manchmal bezeichnet runden in Richtung plus unendlich. Das heißt, wenn `x` positiv ist, wird das Vorhandensein von jedem Nachkommawert Ursachen `x` auf die nächste ganze Zahl gerundet werden soll. Wenn `x` ist negativ, Rundung bewirkt, dass alle Nachkommawert `x` verworfen werden. Die Ausführung der Methode unterscheidet sich von der <xref:System.MathF.Floor%28System.Single%29> -Methode, die in Richtung minus unendlich Rundung unterstützt.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="CopySign">
      <MemberSignature Language="C#" Value="public static float CopySign (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CopySign(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.CopySign(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CopySign (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CopySign(float x, float y);" />
      <MemberSignature Language="F#" Value="static member CopySign : single * single -&gt; single" Usage="System.MathF.CopySign (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Eine Zahl, deren Betrag im Ergebnis verwendet wird.</param>
        <param name="y">Eine Zahl, deren Vorzeichen im Ergebnis verwendet wird.</param>
        <summary>Gibt einen Wert mit dem Betrag <paramref name="x" /> und dem Vorzeichen <paramref name="y" /> zurück.</summary>
        <returns>Ein Wert mit dem Betrag <paramref name="x" /> und dem Vorzeichen <paramref name="y" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static float Cos (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cos(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cos(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cos(float x);" />
      <MemberSignature Language="F#" Value="static member Cos : single -&gt; single" Usage="System.MathF.Cos x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Ein im Bogenmaß angegebener Winkel.</param>
        <summary>Gibt den Kosinus des angegebenen Winkels zurück.</summary>
        <returns>Der Kosinus von <paramref name="x" />. Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird <see cref="F:System.Single.NaN" /> von dieser Methode zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Winkel `x`, im Bogenmaß angegeben werden muss. Multipliziert mit <xref:System.MathF.PI?displayProperty=nameWithType>/180 zur Konvertierung von Grad in Bogenmaß.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static float Cosh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cosh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cosh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cosh(float x);" />
      <MemberSignature Language="F#" Value="static member Cosh : single -&gt; single" Usage="System.MathF.Cosh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Ein im Bogenmaß angegebener Winkel.</param>
        <summary>Gibt den Hyperbelkosinus des angegebenen Winkels zurück.</summary>
        <returns>Der Hyperbelkosinus von <paramref name="x" />. Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird <see cref="F:System.Single.PositiveInfinity" /> zurückgegeben. Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Winkel `x`, im Bogenmaß angegeben werden muss. Multipliziert mit <xref:System.MathF.PI?displayProperty=nameWithType>/180 zur Konvertierung von Grad in Bogenmaß.    
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const float E = 2.718282;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 E = (2.718282)" />
      <MemberSignature Language="DocId" Value="F:System.MathF.E" />
      <MemberSignature Language="VB.NET" Value="Public Const E As Single  = 2.718282" />
      <MemberSignature Language="C++ CLI" Value="public: float E = 2.718282;" />
      <MemberSignature Language="F#" Value="val mutable E : single" Usage="System.MathF.E" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>2.718282</MemberValue>
      <Docs>
        <summary>Stellt die Basis des natürlichen Logarithmus durch die Konstante <see langword="e" /> dar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Der Wert dieser Konstanten ist 2.71828175.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static float Exp (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exp(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Exp(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exp(float x);" />
      <MemberSignature Language="F#" Value="static member Exp : single -&gt; single" Usage="System.MathF.Exp x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Eine Zahl, die einen Exponenten angibt.</param>
        <summary>Gibt die angegebene Potenz von <see langword="e" /> zurück.</summary>
        <returns>Die Zahl <see langword="e" /> hoch <paramref name="x" />. Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird dieser Wert zurückgegeben. Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NegativeInfinity" /> ist, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e` ist eine mathematische Konstante, deren Wert die näherungsweise 2,71828 beträgt.  
  
 Verwenden der <xref:System.MathF.Pow%2A> Methode, um Potenzen von anderen Basen zu berechnen.  
  
 <xref:System.MathF.Exp%2A> ist die Umkehrung der <xref:System.MathF.Log%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.MathF.E" />
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
        <altmember cref="M:System.MathF.Log(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static float Floor (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Floor(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Floor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Floor(float x);" />
      <MemberSignature Language="F#" Value="static member Floor : single -&gt; single" Usage="System.MathF.Floor x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt die größte Ganzzahl zurück, die kleiner oder gleich der angegebenen Gleitkommazahl mit einfacher Genauigkeit ist.</summary>
        <returns>Die größte Ganzzahl, die kleiner oder gleich <paramref name="x" /> ist. Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird dieser Wert zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten dieser Methode folgt Standard IEEE-754, Abschnitt 4. Diese Art der Rundung wird manchmal bezeichnet runden in Richtung minus unendlich. Das heißt, wenn `x` positiv ist, werden alle Nachkommawert wird abgeschnitten. Wenn `x` ist negativ ist, das Vorhandensein jede Nachkommastelle bewirkt, dass es auf die kleinere ganze Zahl gerundet werden soll. Die Ausführung der Methode unterscheidet sich von der <xref:System.MathF.Ceiling%2A> -Methode, die unterstützt runden in Richtung plus unendlich.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd">
      <MemberSignature Language="C#" Value="public static float FusedMultiplyAdd (float x, float y, float z);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 FusedMultiplyAdd(float32 x, float32 y, float32 z) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.FusedMultiplyAdd(System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FusedMultiplyAdd (x As Single, y As Single, z As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float FusedMultiplyAdd(float x, float y, float z);" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : single * single * single -&gt; single" Usage="System.MathF.FusedMultiplyAdd (x, y, z)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="z" Type="System.Single" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Die Zahl, die mit <paramref name="y" /> multipliziert werden soll.</param>
        <param name="y">Die Zahl, die mit <paramref name="x" /> multipliziert werden soll.</param>
        <param name="z">Die Zahl, die zum Ergebnis von <paramref name="x" /> multipliziert mit <paramref name="y" /> addiert werden soll.</param>
        <summary>Gibt (x * y) + z, gerundet als ternärer Vorgang, zurück.</summary>
        <returns>(x * y) + z, gerundet als ternärer Vorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser berechnet `(x * y)` als ob Sie sich mit unendlicher Genauigkeit, fügt `z` auf, die dazu führen, als ob Sie sich mit unendlicher Genauigkeit und rundet schließlich auf den nächsten darstellbaren Wert.
  
 Dies unterscheidet sich von der Sequenz ohne Sicherung, die compute-würde `(x * y)` als ob es sich um unbegrenzte Preicision, runden Sie das Ergebnis in der nächsten darstellbaren Wert, fügen Sie "Z", um das gerundete Ergebnis aus, als ob Sie sich mit unendlicher Genauigkeit und schließlich auf runden die nächste dargestellt werden kann -Wert.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static float IEEERemainder (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 IEEERemainder(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.IEEERemainder(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IEEERemainder (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float IEEERemainder(float x, float y);" />
      <MemberSignature Language="F#" Value="static member IEEERemainder : single * single -&gt; single" Usage="System.MathF.IEEERemainder (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Ein Dividend.</param>
        <param name="y">Ein Divisor.</param>
        <summary>Gibt den Rest der Division zweier angegebener Zahlen zurück.</summary>
        <returns>Eine Zahl gleich <paramref name="x" /> – (<paramref name="y" /> Q), wobei Q der auf die nächste ganze Zahl gerundete Quotient von <paramref name="x" /> / <paramref name="y" /> ist (wenn <paramref name="x" /> / <paramref name="y" /> genau in der Mitte zwischen zwei ganzen Zahlen liegt, wird die gerade ganze Zahl zurückgegeben).  
  
Wenn <paramref name="x" /> - (<paramref name="y" />Q) gleich 0 ist, wird bei positivem <paramref name="x" /> +0 und bei negativem <paramref name="x" /> -0 zurückgegeben.  
  
Wenn <paramref name="y" /> = 0 ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang entspricht der Remainder-Prozess, Abschnitt 5.1 des ANSI/IEEE Std 754-1985 definiert; IEEE-Standard für binäre Gleitkommaarithmetik; Institute of Electrical and Electronics Engineers, Inc.; 1985.  
  
 Die <xref:System.MathF.IEEERemainder%2A> Methode ist nicht identisch mit der [Restoperator](~/docs/csharp/language-reference/operators/remainder-operator.md). Obwohl beide den Rest nach der Division zurückgeben, unterscheiden sich die Formeln, die sie verwenden. Die Formel für die <xref:System.MathF.IEEERemainder%2A> Methode ist:  
  
```  
IEEERemainder = dividend - (divisor * MathF.Round(dividend / divisor))  
```  
  
 Im Gegensatz dazu wird die Formel für den Restoperator:  
  
```  
Remainder = (MathF.Abs(dividend) - (MathF.Abs(divisor) *   
            (MathF.Floor(MathF.Abs(dividend) / MathF.Abs(divisor))))) *   
            MathF.Sign(dividend)  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB">
      <MemberSignature Language="C#" Value="public static int ILogB (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ILogB(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.ILogB(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ILogB (x As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ILogB(float x);" />
      <MemberSignature Language="F#" Value="static member ILogB : single -&gt; int" Usage="System.MathF.ILogB x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Die Zahl, deren Logarithmus bestimmt werden soll.</param>
        <summary>Gibt den Logarithmus einer angegebenen ganzen Zahl zur Basis 2 zurück.</summary>
        <returns>Einer der Werte aus der folgenden Tabelle.  
  
 <list type="table"><listheader><term><paramref name="x" />-Parameter 
 </term><description> Rückgabewert 
 </description></listheader><item><term> Standard 
 </term><description> Der Logarithmus einer ganzen Zahl zur Basis 2 von <paramref name="x" />; d.h. (int)log2(<paramref name="x" />).  
  
 </description></item><item><term> Zero 
 </term><description> <see cref="F:System.Int32.MinValue" />
  
 </description></item><item><term> Gleich <see cref="F:System.Single.NaN" /> oder <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" />
  
 </term><description> <see cref="F:System.Int32.MaxValue" />
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter `x` als Zahl zur Basis 10 angegeben ist.   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static float Log (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log(float x);" />
      <MemberSignature Language="F#" Value="static member Log : single -&gt; single" Usage="System.MathF.Log x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die Zahl, deren Logarithmus bestimmt werden soll.</param>
        <summary>Gibt den natürlichen Logarithmus (zur Basis <see langword="e" />) der angegebenen Zahl zurück.</summary>
        <returns>Einer der Werte aus der folgenden Tabelle.  
  
 <list type="table"><listheader><term><paramref name="x" />-Parameter 
 </term><description> Rückgabewert 
 </description></listheader><item><term> Positiv 
 </term><description> Der natürliche Logarithmus von <paramref name="x" />, d.h. ln <paramref name="x" /> oder log e <paramref name="x" /></description></item><item><term> Zero 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> Negativ 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Gleich <see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Gleich <see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter `x` als Zahl zur Basis 10 angegeben ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.MathF.E" />
        <altmember cref="M:System.MathF.Exp(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static float Log (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Log : single * single -&gt; single" Usage="System.MathF.Log (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die Zahl, deren Logarithmus bestimmt werden soll.</param>
        <param name="newBase">Die Basis des Logarithmus.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl bezüglich einer angegebenen Basis zurück.</summary>
        <returns>Einer der Werte aus der folgenden Tabelle. (Plus unendlich steht für <see cref="F:System.Single.PositiveInfinity" />, minus unendlich für <see cref="F:System.Single.NegativeInfinity" /> und NaN für <see cref="F:System.Single.NaN" />.) 
 <list type="table"><listheader><term><paramref name="x" /></term><description><paramref name="newBase" /></description><description> Rückgabewert 
 </description></listheader><item><term><paramref name="x" />&gt; 0 
 </term><description> (0 &lt;<paramref name="newBase" />&lt; 1) – oder – (<paramref name="newBase" />&gt; 1) 
 </description><description> lognewBase(a) 
 </description></item><item><term><paramref name="x" />&lt; 0 
 </term><description> (beliebiger Wert) 
 </description><description> NaN 
 </description></item><item><term> (beliebiger Wert) 
 </term><description><paramref name="newBase" />&lt; 0 
 </description><description> NaN 
 </description></item><item><term><paramref name="x" /> != 1 
 </term><description><paramref name="newBase" /> = 0 
 </description><description> NaN 
 </description></item><item><term><paramref name="x" /> != 1 
 </term><description><paramref name="newBase" /> = plus unendlich 
 </description><description> NaN 
 </description></item><item><term><paramref name="x" /> = NaN 
 </term><description> (beliebiger Wert) 
 </description><description> NaN 
 </description></item><item><term> (beliebiger Wert) 
 </term><description><paramref name="newBase" /> = NaN 
 </description><description> NaN 
 </description></item><item><term> (beliebiger Wert) 
 </term><description><paramref name="newBase" /> = 1 
 </description><description> NaN 
 </description></item><item><term><paramref name="x" /> = 0 
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1 
 </description><description> plus unendlich 
 </description></item><item><term><paramref name="x" /> = 0 
 </term><description><paramref name="newBase" />&gt; 1 
 </description><description> -Infinity 
 </description></item><item><term><paramref name="x" /> =  +unendlich 
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1 
 </description><description> -Infinity 
 </description></item><item><term><paramref name="x" /> =  +unendlich 
 </term><description><paramref name="newBase" />&gt; 1 
 </description><description> plus unendlich 
 </description></item><item><term><paramref name="x" /> = 1 
 </term><description><paramref name="newBase" /> = 0 
 </description><description> 0 
 </description></item><item><term><paramref name="x" /> = 1 
 </term><description><paramref name="newBase" /> = plus unendlich 
 </description><description> 0 
 </description></item></list></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static float Log10 (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log10(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log10(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log10(float x);" />
      <MemberSignature Language="F#" Value="static member Log10 : single -&gt; single" Usage="System.MathF.Log10 x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Eine Zahl, deren Logarithmus gesucht wird.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl zur Basis 10 zurück.</summary>
        <returns>Einer der Werte aus der folgenden Tabelle.  
  
 <list type="table"><listheader><term><paramref name="x" />-Parameter 
 </term><description> Rückgabewert 
 </description></listheader><item><term> Positiv 
 </term><description> Der Logarithmus von <paramref name="x" /> zur Basis 10, d.h. log 10<paramref name="x" />.  
  
 </description></item><item><term> Zero 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> Negativ 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Gleich <see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Gleich <see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter `x` als Zahl zur Basis 10 angegeben ist.   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static float Log2 (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log2(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log2(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2 (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log2(float x);" />
      <MemberSignature Language="F#" Value="static member Log2 : single -&gt; single" Usage="System.MathF.Log2 x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Eine Zahl, deren Logarithmus gesucht wird.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl zur Basis 2 zurück.</summary>
        <returns>Einer der Werte aus der folgenden Tabelle.  
  
 <list type="table"><listheader><term><paramref name="x" />-Parameter 
 </term><description> Rückgabewert 
 </description></listheader><item><term> Positiv 
 </term><description> Der Logarithmus von <paramref name="x" /> zur Basis 2, d.h. log 2<paramref name="x" />.  
  
 </description></item><item><term> Zero 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> Negativ 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Gleich <see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Gleich <see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter `x` als Zahl zur Basis 10 angegeben ist.   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Max(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Max : single * single -&gt; single" Usage="System.MathF.Max (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die erste von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</param>
        <param name="y">Die zweite von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</param>
        <summary>Gibt die größere von zwei Gleitkommazahlen mit einfacher Genauigkeit zurück.</summary>
        <returns>Der größere der Parameter <paramref name="x" /> und <paramref name="y" />. Wenn entweder <paramref name="x" /> oder <paramref name="y" /> oder sowohl <paramref name="x" /> als auch <paramref name="y" /> gleich <see cref="F:System.Single.NaN" /> ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static float MaxMagnitude (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MaxMagnitude(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.MaxMagnitude(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MaxMagnitude(float x, float y);" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : single * single -&gt; single" Usage="System.MathF.MaxMagnitude (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Die erste von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</param>
        <param name="y">Die zweite von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</param>
        <summary>Gibt den größeren Betrag von zwei Gleitkommazahlen mit einfacher Genauigkeit zurück.</summary>
        <returns>Parameter <paramref name="x" /> oder <paramref name="y" />, je nachdem, welche den größeren Betrag hat. Wenn entweder <paramref name="x" /> oder <paramref name="y" /> oder sowohl <paramref name="x" /> als auch <paramref name="y" /> gleich <see cref="F:System.Single.NaN" /> ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Min(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Min : single * single -&gt; single" Usage="System.MathF.Min (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die erste von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</param>
        <param name="y">Die zweite von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</param>
        <summary>Gibt die kleinere von zwei Gleitkommazahlen mit einfacher Genauigkeit zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="x" /> und <paramref name="y" />. Wenn entweder <paramref name="x" /> oder <paramref name="y" /> oder sowohl <paramref name="x" /> als auch <paramref name="y" /> gleich <see cref="F:System.Single.NaN" /> ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static float MinMagnitude (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MinMagnitude(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.MinMagnitude(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MinMagnitude(float x, float y);" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : single * single -&gt; single" Usage="System.MathF.MinMagnitude (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Die erste von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</param>
        <param name="y">Die zweite von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</param>
        <summary>Gibt den kleineren Betrag von zwei Gleitkommazahlen mit einfacher Genauigkeit zurück.</summary>
        <returns>Parameter <paramref name="x" /> oder <paramref name="y" />, je nachdem, welche den kleineren Betrag hat. Wenn entweder <paramref name="x" /> oder <paramref name="y" /> oder sowohl <paramref name="x" /> als auch <paramref name="y" /> gleich <see cref="F:System.Single.NaN" /> ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const float PI = 3.141593;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PI = (3.141593)" />
      <MemberSignature Language="DocId" Value="F:System.MathF.PI" />
      <MemberSignature Language="VB.NET" Value="Public Const PI As Single  = 3.141593" />
      <MemberSignature Language="C++ CLI" Value="public: float PI = 3.141593;" />
      <MemberSignature Language="F#" Value="val mutable PI : single" Usage="System.MathF.PI" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.141593</MemberValue>
      <Docs>
        <summary>Stellt das Verhältnis eines Kreisumfangs zum Kreisdurchmesser durch die Konstante π dar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Der Wert dieses Felds ist 3.14159274.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static float Pow (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Pow(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Pow(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Pow(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Pow : single * single -&gt; single" Usage="System.MathF.Pow (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Eine Gleitkommazahl mit einfacher Genauigkeit, die potenziert werden soll.</param>
        <param name="y">Eine Gleitkommazahl mit einfacher Genauigkeit, die einen Exponenten darstellt.</param>
        <summary>Potenziert eine angegebene Zahl mit dem angegebenen Exponenten.</summary>
        <returns>Die Zahl <paramref name="x" /> hoch <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgende Tabelle gibt der Rückgabewert aus, wenn verschiedene Werte oder Wertebereiche, für angegeben werden die `x` und `y` Parameter. Weitere Informationen finden Sie unter <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> und <xref:System.Single.NaN?displayProperty=nameWithType>.  
  
|Parameter|Rückgabewert|  
|----------------|------------------|  
|`x` oder `y`  =  `NaN`.|`NaN`|  
|`x` = Alle Werte außer `NaN`; `y` = 0.|1|  
|`x` = `NegativeInfinity`; `y` < 0.|0|  
|`x` = `NegativeInfinity`; `y` eine ganze Zahl ungerade ist.|`NegativeInfinity`|  
|`x` = `NegativeInfinity`; `y` ist positiv, aber keine ungerade ganze Zahl.|`PositiveInfinity`|  
|`x` < 0, nicht jedoch `NegativeInfinity`; `y` ist kein intergerwert, `NegativeInfinity`, oder `PositiveInfinity`.|`NaN`|  
|`x` = -1; `y`  =  `NegativeInfinity` oder `PositiveInfinity`.|`NaN`|  
|-1 < `x` < 1; `y` = `NegativeInfinity`.|`PositiveInfinity`|  
|-1 < `x` < 1; `y` = `PositiveInfinity`.|0|  
|`x` <-1 oder `x` > 1. `y` = `NegativeInfinity`.|0|  
|`x` <-1 oder `x` > 1. `y` = `PositiveInfinity`.|`PositiveInfinity`|  
|`x` = 0; `y` < 0.|`PositiveInfinity`|  
|`x` = 0; `y` > 0.|0|  
|`x` = 1; `y` beliebiger Wert außer `NaN`.|1|  
|`x` = `PositiveInfinity`; `y` < 0.|0|  
|`x` = `PositiveInfinity`; `y` > 0.|`PositiveInfinity`|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.MathF.Sqrt(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x);" />
      <MemberSignature Language="F#" Value="static member Round : single -&gt; single" Usage="System.MathF.Round x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Eine zu rundende Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Rundet einen Gleitkommawert mit einfacher Genauigkeit auf den nächstgelegenen ganzzahligen Wert und Mittelpunktwerte auf die nächstgelegene gerade Zahl.</summary>
        <returns>Die zu <paramref name="x" /> nächste Ganzzahl. Wenn der Nachkommawert von <paramref name="x" /> genau in der Mitte zwischen zwei Ganzzahlen liegt, von denen eine gerade und die andere ungerade ist, wird die gerade Zahl zurückgegeben. Beachten Sie, dass diese Methode einen <see cref="T:System.Single" /> anstelle eines ganzzahligen Typs zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Diese Methode verwendet die Standardeinstellung Konvention <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

Wenn der Wert des der `x` Argument <xref:System.Single.NaN?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Single.NaN?displayProperty=nameWithType>. Wenn `x` ist <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>bzw.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Aufgrund der Verlust an Genauigkeit, die entstehen kann, die als Gleitkommazahlen Dezimalwerte darstellt oder arithmetische Vorgänge für Gleitkommawerte, in einigen Fällen die <see cref="M:System.MathF.Round(System.Single)" /> Methode möglicherweise nicht angezeigt, zu rundende Mittelwert der Werte für die nächste gerade ganze Zahl.</para></block>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, digits As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, int digits);" />
      <MemberSignature Language="F#" Value="static member Round : single * int -&gt; single" Usage="System.MathF.Round (x, digits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Eine zu rundende Gleitkommazahl mit einfacher Genauigkeit.</param>
        <param name="digits">Die Anzahl von Dezimalstellen im Rückgabewert.</param>
        <summary>Rundet einen Gleitkommawert mit einfacher Genauigkeit auf eine angegebene Anzahl Dezimalstellen und Mittelpunktwerte auf die nächstgelegene gerade Zahl.</summary>
        <returns>Die Zahl, die <paramref name="x" /> am nächsten liegt und deren Anzahl von Nachkommastellen gleich <paramref name="digits" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Der Wert des der `digits` Argument kann zwischen 0 und 6 liegen. Beachten Sie, dass 6 die maximale Anzahl von vor- und Nachkommastellen Ziffern, die von unterstützt die <xref:System.Single> Typ.

Diese Methode verwendet die Standardeinstellung Konvention <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>. 

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

Wenn der Wert des der `x` Argument <xref:System.Single.NaN?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Single.NaN?displayProperty=nameWithType>. Wenn `x` ist <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>bzw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="digits" /> ist kleiner als 0 (null) oder größer als 6.</exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, mode As MidpointRounding) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : single * MidpointRounding -&gt; single" Usage="System.MathF.Round (x, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="x">Eine zu rundende Gleitkommazahl mit einfacher Genauigkeit.</param>
        <param name="mode">Angabe, wie <paramref name="x" /> gerundet werden soll, wenn der Wert genau in der Mitte zwischen zwei anderen Zahlen liegt.</param>
        <summary>Rundet einen Gleitkommawert mit einfacher Genauigkeit auf die nächstgelegene ganze Zahl und verwendet den angegebenen Rundungsmodus für Mittelpunktwerte.</summary>
        <returns>Die zu <paramref name="x" /> nächste Ganzzahl. Wenn <paramref name="x" /> genau in der Mitte zwischen zwei Zahlen liegt, von denen eine gerade und die andere ungerade ist, bestimmt der <paramref name="mode" />-Parameter, welche der beiden Zahlen zurückgegeben wird. Beachten Sie, dass diese Methode einen <see cref="T:System.Single" /> anstelle eines ganzzahligen Typs zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  


[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

Wenn der Wert des der `x` Argument <xref:System.Single.NaN?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Single.NaN?displayProperty=nameWithType>. Wenn `x` ist <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>bzw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mode" /> ist kein gültiger Wert von <see cref="T:System.MidpointRounding" />.</exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, digits As Integer, mode As MidpointRounding) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, int digits, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : single * int * MidpointRounding -&gt; single" Usage="System.MathF.Round (x, digits, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="x">Eine zu rundende Gleitkommazahl mit einfacher Genauigkeit.</param>
        <param name="digits">Die Anzahl von Dezimalstellen im Rückgabewert.</param>
        <param name="mode">Angabe, wie <paramref name="x" /> gerundet werden soll, wenn der Wert genau in der Mitte zwischen zwei anderen Zahlen liegt.</param>
        <summary>Rundet einen Gleitkommawert mit einfacher Genauigkeit auf die angegebene Anzahl Dezimalstellen und verwendet den angegebenen Rundungsmodus für Mittelpunktwerte.</summary>
        <returns>Die Zahl, die <paramref name="x" /> am nächsten liegt und deren Anzahl von Dezimalstellen gleich <paramref name="digits" /> ist. Wenn <paramref name="x" /> weniger Dezimalstellen als <paramref name="digits" /> hat, wird <paramref name="x" /> unverändert zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Der Wert des der `digits` Argument kann zwischen 0 und 6 liegen. Beachten Sie, dass 6 die maximale Anzahl von vor- und Nachkommastellen Ziffern, die von unterstützt die <xref:System.Single> Typ.


[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

Wenn der Wert des der `x` Argument <xref:System.Single.NaN?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Single.NaN?displayProperty=nameWithType>. Wenn `x` ist <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>bzw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="digits" /> ist kleiner als 0 (null) oder größer als 6.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mode" /> ist kein gültiger Wert von <see cref="T:System.MidpointRounding" />.</exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleB">
      <MemberSignature Language="C#" Value="public static float ScaleB (float x, int n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ScaleB(float32 x, int32 n) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.ScaleB(System.Single,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ScaleB (x As Single, n As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ScaleB(float x, int n);" />
      <MemberSignature Language="F#" Value="static member ScaleB : single * int -&gt; single" Usage="System.MathF.ScaleB (x, n)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Eine Gleitkommazahl mit einfacher Genauigkeit, die den Basiswert darstellt.</param>
        <param name="n">Eine Gleitkommazahl mit einfacher Genauigkeit, die den Exponenten darstellt.</param>
        <summary>Gibt x * 2^n effizient berechnet zurück.</summary>
        <returns>x * 2^n effizient berechnet.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sign(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (x As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(float x);" />
      <MemberSignature Language="F#" Value="static member Sign : single -&gt; int" Usage="System.MathF.Sign x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Eine Zahl mit Vorzeichen.</param>
        <summary>Gibt eine ganze Zahl zurück, die das Vorzeichen einer Gleitkommazahl mit einfacher Genauigkeit angibt.</summary>
        <returns>Eine Zahl, die das Vorzeichen von <paramref name="x" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Bedeutung 
 </description></listheader><item><term> -1 
 </term><description><paramref name="x" /> ist kleiner als 0.  
  
 </description></item><item><term> 0 
 </term><description><paramref name="x" /> ist gleich 0 (null).  
  
 </description></item><item><term> 1 
 </term><description><paramref name="x" /> ist größer als 0 (null).  
  
 </description></item></list></returns>
        <remarks></remarks>
        <exception cref="T:System.ArithmeticException"><paramref name="x" /> ist gleich <see cref="F:System.Single.NaN" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static float Sin (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sin(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sin(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sin(float x);" />
      <MemberSignature Language="F#" Value="static member Sin : single -&gt; single" Usage="System.MathF.Sin x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Ein im Bogenmaß angegebener Winkel.</param>
        <summary>Gibt den Sinus des angegebenen Winkels zurück.</summary>
        <returns>Der Sinus von <paramref name="x" />. Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird <see cref="F:System.Single.NaN" /> von dieser Methode zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Winkel `x`, im Bogenmaß angegeben werden muss. Multipliziert mit <xref:System.MathF.PI?displayProperty=nameWithType>/180 zur Konvertierung von Grad in Bogenmaß.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static float Sinh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sinh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sinh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sinh(float x);" />
      <MemberSignature Language="F#" Value="static member Sinh : single -&gt; single" Usage="System.MathF.Sinh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Ein im Bogenmaß angegebener Winkel.</param>
        <summary>Gibt den Hyperbelsinus des angegebenen Winkels zurück.</summary>
        <returns>Der Hyperbelsinus von <paramref name="x" />. Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NegativeInfinity" />, <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NaN" /> ist, gibt diese Methode einen <see cref="T:System.Single" /> mit dem Wert <paramref name="x" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Winkel `x`, im Bogenmaß angegeben werden muss. Multipliziert mit <xref:System.MathF.PI?displayProperty=nameWithType>/180 zur Konvertierung von Grad in Bogenmaß.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static float Sqrt (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sqrt(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sqrt(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sqrt(float x);" />
      <MemberSignature Language="F#" Value="static member Sqrt : single -&gt; single" Usage="System.MathF.Sqrt x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die Zahl, deren Quadratwurzel bestimmt werden soll.</param>
        <summary>Gibt die Quadratwurzel einer angegebenen Zahl zurück.</summary>
        <returns>Einer der Werte aus der folgenden Tabelle.  
  
 <list type="table"><listheader><term><paramref name="x" />-Parameter 
 </term><description> Rückgabewert 
 </description></listheader><item><term> 0 oder positiv 
 </term><description> Die positive Quadratwurzel von <paramref name="x" />.  
  
 </description></item><item><term> Negativ 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Entspricht <see cref="F:System.Single.NaN" />.</term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Entspricht <see cref="F:System.Single.PositiveInfinity" />.</term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks></remarks>
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static float Tan (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Tan(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Tan(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Tan(float x);" />
      <MemberSignature Language="F#" Value="static member Tan : single -&gt; single" Usage="System.MathF.Tan x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Ein im Bogenmaß angegebener Winkel.</param>
        <summary>Gibt den Tangens des angegebenen Winkels zurück.</summary>
        <returns>Der Tangens von <paramref name="x" />. Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird <see cref="F:System.Single.NaN" /> von dieser Methode zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Winkel `x`, im Bogenmaß angegeben werden muss. Multipliziert mit <xref:System.MathF.PI?displayProperty=nameWithType>/180 zur Konvertierung von Grad in Bogenmaß.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static float Tanh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Tanh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Tanh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Tanh(float x);" />
      <MemberSignature Language="F#" Value="static member Tanh : single -&gt; single" Usage="System.MathF.Tanh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Ein im Bogenmaß angegebener Winkel.</param>
        <summary>Gibt den Hyperbeltangens des angegebenen Winkels zurück.</summary>
        <returns>Der Hyperbeltangens von <paramref name="x" />. Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NegativeInfinity" /> ist, gibt diese Methode -1 zurück. Wenn value gleich <see cref="F:System.Single.PositiveInfinity" /> ist, gibt diese Methode 1 zurück. Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> ist, gibt diese Methode <see cref="F:System.Single.NaN" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Winkel `x`, im Bogenmaß angegeben werden muss. Multipliziert mit <xref:System.MathF.PI?displayProperty=nameWithType>/180 zur Konvertierung von Grad in Bogenmaß.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static float Truncate (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Truncate(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Truncate(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Truncate(float x);" />
      <MemberSignature Language="F#" Value="static member Truncate : single -&gt; single" Usage="System.MathF.Truncate x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Eine abzuschneidende Zahl.</param>
        <summary>Berechnet den ganzzahligen Teil einer angegebenen Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Der ganzzahlige Teil von <paramref name="x" />, d. h. die Zahl, die übrig bleibt, wenn alle Dezimalstellen verworfen wurden, oder einer der Werte in der folgenden Tabelle.  
  
 <list type="table"><listheader><term><paramref name="x" /></term><description> Rückgabewert 
 </description></listheader><item><term><see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term><see cref="F:System.Single.NegativeInfinity" /></term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term><see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.MathF.Truncate%2A> Rundet `x` auf die nächste Ganzzahl in Richtung 0 (null).  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
  </Members>
</Type>
