<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="babdcdbad5bec13d604ddedb87ba703ca6714a73" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37755254" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Erstellt und steuert einen Thread, legt dessen Priorität fest und ruft den Status ab.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Prozess gestartet wird, erstellt die common Language Runtime automatisch eine einzelne Vordergrundthread, um Anwendungscode auszuführen. Zusammen mit diesem Hauptmenü Vordergrundthread kann ein Prozess eine oder mehrere Threads, um einen Teil der Programmcode, der dem Prozess zugeordneten ausführen erstellen. Diese Threads können entweder im Vordergrund oder im Hintergrund ausführen. Darüber hinaus können Sie die <xref:System.Threading.ThreadPool> Klasse zum Ausführen von Code auf die Anzahl der Arbeitsthreads, die von der common Language Runtime verwaltet werden.  
  
 In diesem Abschnitt  
  
 [Starten eines Threads](#Starting)   
 [Abrufen von Thread-Objekten](#Retrieving)   
 [Vordergrund-und Hintergrundthreads](#Foreground)   
 [Kultur und threads](#Culture)   
 [Abrufen von Informationen zu und Steuern von threads](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>Starten eines Threads  
 Sie starten ein Threads durch Angabe ein Delegaten, das die Methode darstellt, die der Thread befindet sich in seinem Klassenkonstruktor ausgeführt. Rufen Sie dann die <xref:System.Threading.Thread.Start%2A> Methode, um die Ausführung zu starten.  
  
 Die <xref:System.Threading.Thread> Konstruktoren akzeptiert entweder von zwei Delegattypen, je nachdem, ob Sie ein Argument an die Methode, die ausgeführt werden übergeben können:  
  
-   Wenn die Methode keine Argumente verfügt, Sie übergeben eine <xref:System.Threading.ThreadStart> delegieren an den Konstruktor. Er trägt die Signatur:  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     Das folgende Beispiel erstellt und startet einen Thread, der ausgeführt wird die `ExecuteInForeground` Methode. Die Methode zeigt Informationen zu einigen Threadeigenschaften, führt dann eine Schleife in der sie für eine halbe Sekunde angehalten wird, und zeigt die verstrichene Anzahl von Sekunden. Wenn der Thread mindestens fünf Sekunden lang ausgeführt wurde, beendet die Schleife beendet und der Thread die Ausführung.  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   Wenn die Methode ein Argument verfügt, Sie übergeben eine <xref:System.Threading.ParameterizedThreadStart> delegieren an den Konstruktor. Er trägt die Signatur:  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     Die Methode ausgeführt wird, durch den Delegaten kann dann umgewandelt (in C# -Referenz) oder konvertieren den Parameter (in Visual Basic) aus, in den entsprechenden Typ.  
  
     Im folgende Beispiel ist identisch mit dem vorherigen Beispiel, außer dass sie ruft die <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Konstruktor. Diese Version von der `ExecuteInForeground` Methode verfügt über einen einzelnen Parameter, der die ungefähre Anzahl von Millisekunden darstellt, die Schleife wird ausgeführt.  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 Es ist nicht erforderlich, beizubehalten, einen Verweis auf eine <xref:System.Threading.Thread> Objekt, nachdem Sie den Thread gestartet haben. Der Thread wird weiterhin ausgeführt, bis die Threadprozedur abgeschlossen ist.  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>Abrufen von Thread-Objekten  
 Sie können mithilfe der statischen (`Shared` in Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> Eigenschaft, um einen Verweis auf den gerade ausgeführten Thread aus dem Code abzurufen, die der Thread ausgeführt wird. Im folgenden Beispiel wird die <xref:System.Threading.Thread.CurrentThread%2A> Eigenschaft, um Informationen zum Thread der hauptanwendung, eine andere Vordergrundthread, einem Hintergrundthread und einen Threadpool-Thread anzuzeigen.  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>Vordergrund-und Hintergrundthreads  
 Instanzen der <xref:System.Threading.Thread> Vordergrundthreads oder Hintergrundthreads Klasse darstellen. Hintergrundthreads sind identisch mit Vordergrundthreads mit einer Ausnahme: ein Hintergrundthread keinen laufenden Prozess beibehalten, wenn alle Vordergrundthreads beendet wurden. Sobald alle Vordergrundthreads beendet wurden, wird die Laufzeit beendet alle Hintergrundthreads und fährt.  
  
 Führen die folgenden Threads in der Standardeinstellung im Vordergrund:  
  
-   Der Thread der hauptanwendung.  
  
-   Alle Threads, die durch den Aufruf erstellt einen <xref:System.Threading.Thread> Klassenkonstruktor.  
  
 Die folgenden Threads, die standardmäßig im Hintergrund ausgeführt werden:  
  
-   Thread Poolthreads, die einen Pool von Arbeitsthreads, die von der Laufzeit verwaltet werden.  Sie können die Thread-Pool und den Zeitplan der Arbeit in Threads im Threadpool konfigurieren, mit der <xref:System.Threading.ThreadPool> Klasse.  
  
    > [!NOTE]
    >  Aufgabenbasierte asynchrone Vorgänge werden automatisch in Threads im Threadpool ausgeführt. Aufgabenbasierte asynchrone Vorgänge verwenden die <xref:System.Threading.Tasks.Task> und <xref:System.Threading.Tasks.Task%601> Klassen implementieren die [aufgabenbasierte asynchrone Muster](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).  
  
-   Alle Threads, die die verwaltete ausführungsumgebung von nicht verwaltetem Code eingeben.  
  
 Sie können ändern, dass einen Thread im Hintergrund ausführen, durch Festlegen der <xref:System.Threading.Thread.IsBackground%2A> Eigenschaft zu einem beliebigen Zeitpunkt.  Hintergrundthreads sind nützlich für jeden Vorgang, der fortgesetzt werden soll, solange Sie eine Anwendung ausgeführt wird, jedoch sollte nicht zu verhindern, dass die Anwendung beendet wird, wie z. B. das Überwachen von dateisystemänderungen oder eingehende WebSocket-Verbindungen.  
  
 Das folgende Beispiel veranschaulicht den Unterschied zwischen Vordergrund-und Hintergrundthreads. Es ist wie im ersten Beispiel in der [Starten eines Threads](#Starting) Abschnitt, außer dass sie im Hintergrund ausführen, vor dem Starten des Threads. Die Ausgabe zeigt, wird die Schleife unterbrochen, bevor er fünf Sekunden ausgeführt wird.  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>Kultur und threads  
 Jeder Thread hat eine Kultur, dargestellt durch die <xref:System.Threading.Thread.CurrentCulture%2A> -Eigenschaft und eine Benutzeroberflächenkultur, dargestellt durch die <xref:System.Threading.Thread.CurrentUICulture%2A> Eigenschaft.  Die aktuelle Kultur unterstützt kulturabhängige Vorgänge wie Analyse und Formatierung, Zeichenfolgenvergleich und-Sortierung und steuert auch die Schriftsystems und Kalenders, die von einem Thread verwendet. Die aktuelle Benutzeroberflächenkultur bietet für kulturabhängige-Abruf von Ressourcen in Ressourcendateien.  
  
 Wenn ein neuer Thread instanziiert wird, werden die Kultur und Benutzeroberflächenkultur definiert, durch die aktuelle Systemkultur und UI-Kultur, und nicht von der Kultur und Benutzeroberflächenkultur des Threads aus der der neue Thread erstellt wird. Also, z. B. wenn die aktuelle Systemkultur Englisch (Vereinigte Staaten ist) und der aktuellen Kultur des Threads primäranwendung Französisch (Frankreich), die Kultur eines neuen Threads erstellt durch Aufrufen der <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Konstruktor aus dem primären Thread ist nicht Französisch (Frankreich) und Englisch (USA). Weitere Informationen finden Sie im Abschnitt "Kultur und Threads", der die <xref:System.Globalization.CultureInfo> Thema-Klasse.  
  
> [!IMPORTANT]
>  Dies gilt nicht für Threads, die ausgeführt werden asynchrone Vorgänge für apps, die auf die [!INCLUDE[net_v46](~/includes/net-v46-md.md)] und höhere Versionen, In diesem Fall werden die Kultur und Benutzeroberflächenkultur ist Teil eines asynchronen Vorgänge Kontext; der Thread auf dem eines asynchronen Vorgangs führt standardmäßig erbt der Kultur und Benutzeroberflächenkultur des Threads, von dem der asynchrone Vorgang gestartet wurde. Weitere Informationen finden Sie im Abschnitt "Kultur und aufgabenbasierte asynchrone Vorgänge" im Thema zur <xref:System.Globalization.CultureInfo>-Klasse.  
  
 Führen Sie einen der folgenden Optionen, um sicherzustellen, dass alle Threads in einer Anwendung ausführen freigeben, das dieselbe Kultur und Benutzeroberflächenkultur:  
  
-   Können Sie übergeben eine <xref:System.Globalization.CultureInfo> -Objekt, das diese Kultur entspricht der <xref:System.Threading.ParameterizedThreadStart> delegieren oder <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> Methode.  
  
-   Für apps, die unter der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] und höheren Versionen können Sie definieren, die Kultur und Benutzeroberflächenkultur, die für alle Threads in einer Anwendungsdomäne erstellt, durch Festlegen des Werts der zugewiesen werden soll die <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> und <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> Eigenschaften. Beachten Sie, dass es sich um eine pro-AppDomain-Einstellung handelt.  
  
 Weitere Informationen und Beispiele finden Sie im Abschnitt "Kultur und Threads", der die <xref:System.Globalization.CultureInfo> Thema-Klasse.  
  
<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>Abrufen von Informationen zu und Steuern von threads  
 Sie können eine Anzahl von Eigenschaftswerten abrufen, die Informationen über einen Thread zu bieten. In einigen Fällen können Sie auch diese Eigenschaftswerte, die Ausführung des Threads steuern festlegen. Zu diesen Threadeigenschaften zählen:  
  
-   Einen Namen. <xref:System.Threading.Thread.Name%2A> ein Schreibvorgang-einmal-Eigenschaft, die Sie verwenden können, um einen Thread zu identifizieren.  Der Standardwert ist `null`.  
  
-   Ein Hashcode, die Sie durch den Aufruf abrufen können die <xref:System.Threading.Thread.GetHashCode%2A> Methode. Der Hashcode kann verwendet werden, um einen Thread eindeutig zu identifizieren. für die Lebensdauer des Threads wird der Hashcode nicht mit dem Wert eines anderen Threads, unabhängig von der Anwendungsdomäne in Konflikt stehen aus dem Sie den Wert abrufen.  
  
-   Ein Thread-ID. Der Wert der Read-only <xref:System.Threading.Thread.ManagedThreadId%2A> Eigenschaft wird von der Laufzeit zugewiesen und einen Thread innerhalb des Prozesses eindeutig identifiziert.  
  
    > [!NOTE]
    >  Eine Betriebssystem-[ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) hat keine feste Beziehung zu einem verwalteten Thread, da ein nicht verwalteter Host die Beziehung zwischen verwalteten und nicht verwalteten Threads steuern kann. Ein komplexer Host können insbesondere die [CLR Hosting-API](https://msdn.microsoft.com/library/ms404385.aspx) um viele verwaltete Threads für die gleiche Betriebssystemthread zu planen oder um einen verwalteten Thread zwischen verschiedenen Betriebssystemthreads zu verschieben.  
  
-   Der Thread den aktuellen Status. Für die Dauer der vorhanden ist, ein Thread ist immer in einer oder mehreren der Zustände von definiert die <xref:System.Threading.ThreadState> Eigenschaft.  
  
-   Eine Planung Prioritätsstufe, die durch definiert wird die <xref:System.Threading.ThreadPriority> Eigenschaft. Obwohl Sie diesen Wert zum Anfordern der Priorität des Threads festlegen können, ist es nicht garantiert, vom Betriebssystem berücksichtigt werden.  
  
-   Die schreibgeschützte <xref:System.Threading.Thread.IsThreadPoolThread%2A> -Eigenschaft, die angibt, ob ein Thread einen Threadpool-Thread ist.  
  
-   Die <xref:System.Threading.Thread.IsBackground%2A>-Eigenschaft Weitere Informationen finden Sie unter den [Vordergrund-und Hintergrundthreads](#Foreground) Abschnitt.  
  
## Examples  
 Das folgende Beispiel zeigt einfachen threading-Funktionen.  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 Dieser Code erzeugt eine Ausgabe ähnlich der folgenden:  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Ein Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse und gibt dabei einen Delegaten an, der das Übergeben eines Objekts an den Thread bei dessen Start ermöglicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread ausführen, bei der Erstellung nicht gestartet. Um die Ausführung des Threads zu planen, rufen die <xref:System.Threading.Thread.Start%2A> Methode. Um ein Datenobjekt an den Thread zu übergeben, verwenden die <xref:System.Threading.Thread.Start%28System.Object%29> -methodenüberladung.  
  
> [!NOTE]
>  Lassen Sie Visual Basic-Benutzer können die <xref:System.Threading.ThreadStart> Konstruktor beim Erstellen eines Threads. Verwenden der `AddressOf` beim Übergeben der Methode, z. B. den Operator `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic ruft automatisch die <xref:System.Threading.ThreadStart> Konstruktor.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Syntax zum Erstellen und Verwenden einer <xref:System.Threading.ParameterizedThreadStart> Delegat mit einer statischen Methode und eine Instanzmethode handeln.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Ein <see cref="T:System.Threading.ThreadStart" />-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread ausführen, bei der Erstellung nicht gestartet. Um die Ausführung des Threads zu planen, rufen die <xref:System.Threading.Thread.Start%2A> Methode.  
  
> [!NOTE]
>  Lassen Sie Visual Basic-Benutzer können die <xref:System.Threading.ThreadStart> Konstruktor beim Erstellen eines Threads. Verwenden der `AddressOf` beim Übergeben von der Methode z. B. den Operator `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic ruft automatisch die <xref:System.Threading.ThreadStart> Konstruktor.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht das Erstellen eines Threads, die eine statische Methode ausgeführt wird.  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht das Erstellen eines Threads, die eine Instanzmethode ausgeführt wird.  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="start" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Ein <see cref="T:System.Threading.ParameterizedThreadStart" />-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</param>
        <param name="maxStackSize">Die maximale Stapelgröße, in Bytes, für den Thread, oder 0 (null), wenn die angegebene maximale Standardstapelgröße aus dem Header der ausführbaren Datei verwendet werden soll.  Wichtig   Für teilweise vertrauenswürdigen Code wird <c>maxStackSize</c> ignoriert, wenn sie größer als die Standardstapelgröße ist. Es werden keine Ausnahmen ausgelöst.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse und gibt dabei einen Delegaten, der das Übergeben eines Objekts an den Thread bei dessen Start ermöglicht, sowie eine maximale Stapelgröße für den Thread an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung des Konstruktors. Die standardmäßige Stapelgröße, die ein, die die <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Überladung des Konstruktors ist die empfohlene Stapelgröße für Threads. Wenn ein Thread Speicherprobleme verfügt, wird die wahrscheinlichste Ursache Programmierfehler, z. B. unendliche Rekursion.  
  
> [!IMPORTANT]
>  Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]kann nur voll vertrauenswürdiger Code kann festgelegt werden `maxStackSize` auf einen Wert, der größer als die Standardstapelgröße (1 MB). Wenn für ein größerer Wert angegeben ist `maxStackSize` Code mit teilweiser Vertrauenswürdigkeit ausgeführt wird `maxStackSize` wird ignoriert, und die standardmäßige Stapelgröße verwendet wird. Es werden keine Ausnahmen ausgelöst. Code auf eine beliebige Vertrauensebene festlegen kann `maxStackSize` auf einen Wert, der kleiner als die Standardstapelgröße ist.  
  
> [!NOTE]
>  Wenn Sie entwickeln eine vollkommen vertrauenswürdige Bibliothek, die von teilweise vertrauenswürdigem Code verwendet werden, müssen Sie zum Starten eines Threads, die einen großen Stapel erfordert, müssen Sie volle Vertrauenswürdigkeit zusichern, vor dem Erstellen des Threads oder die standardmäßige Stapelgröße verwendet werden. Verwenden Sie keine, wenn Sie den Code, der auf dem Thread ausgeführt wird, vollständig steuern.  
  
 Wenn `maxStackSize` ist kleiner als die minimale Stapelgröße, wird die minimale Stapelgröße verwendet. Wenn `maxStackSize` ist kein Vielfaches der Seitengröße, gerundet auf die nächstgrößere Vielfache der Seitengröße. Wenn Sie .NET Framework, Version 2.0 unter Windows Vista verwenden, z. B. 256KB (262.144 Bytes) ist die minimale Stapelgröße, und die Seitengröße ist 64KB (65.536 Byte).  
  
> [!NOTE]
>  In Versionen von Microsoft Windows vor Windows XP und Windows Server 2003 `maxStackSize` ignoriert, und die Größe des Stapels im Header ausführbaren Datei angegeben werden.  
  
 Wenn Sie eine sehr kleine Stapelgröße angeben, müssen Sie möglicherweise Stapelüberlaufs deaktivieren. Wenn der Stapel stark eingeschränkt ist, kann, auf dem sich selbst einen Stapelüberlauf verursachen die Überprüfung. Um Stapelüberlaufs zu deaktivieren, fügen Sie Folgendes, um die Konfigurationsdatei der Anwendung.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Ein <see cref="T:System.Threading.ThreadStart" />-Delegat, der die Methoden darstellt, die bei Beginn der Ausführung dieses Threads aufgerufen werden müssen.</param>
        <param name="maxStackSize">Die maximale Stapelgröße, in Bytes, für den Thread, oder 0 (null), wenn die angegebene maximale Standardstapelgröße aus dem Header der ausführbaren Datei verwendet werden soll.  Wichtig   Für teilweise vertrauenswürdigen Code wird <c>maxStackSize</c> ignoriert, wenn sie größer als die Standardstapelgröße ist. Es werden keine Ausnahmen ausgelöst.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Threading.Thread" />-Klasse und gibt die maximale Stapelgröße für den Thread an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung des Konstruktors. Die standardmäßige Stapelgröße, die ein, die die <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> Überladung des Konstruktors ist die empfohlene Stapelgröße für Threads. Wenn ein Thread Speicherprobleme verfügt, wird die wahrscheinlichste Ursache Programmierfehler, z. B. unendliche Rekursion.  
  
> [!IMPORTANT]
>  Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]kann nur voll vertrauenswürdiger Code kann festgelegt werden `maxStackSize` auf einen Wert, der größer als die Standardstapelgröße (1 MB). Wenn für ein größerer Wert angegeben ist `maxStackSize` Code mit teilweiser Vertrauenswürdigkeit ausgeführt wird `maxStackSize` wird ignoriert, und die standardmäßige Stapelgröße verwendet wird. Es werden keine Ausnahmen ausgelöst. Code auf eine beliebige Vertrauensebene festlegen kann `maxStackSize` auf einen Wert, der kleiner als die Standardstapelgröße ist.  
  
> [!NOTE]
>  Wenn Sie entwickeln eine vollkommen vertrauenswürdige Bibliothek, die von teilweise vertrauenswürdigem Code verwendet werden, müssen Sie zum Starten eines Threads, die einen großen Stapel erfordert, müssen Sie volle Vertrauenswürdigkeit zusichern, vor dem Erstellen des Threads oder die standardmäßige Stapelgröße verwendet werden. Verwenden Sie keine, wenn Sie den Code, der auf dem Thread ausgeführt wird, vollständig steuern.  
  
 Wenn `maxStackSize` ist kleiner als die minimale Stapelgröße, wird die minimale Stapelgröße verwendet. Wenn `maxStackSize` ist kein Vielfaches der Seitengröße, gerundet auf die nächstgrößere Vielfache der Seitengröße. Wenn Sie .NET Framework, Version 2.0 unter Windows Vista verwenden, z. B. 256KB (262.144 Bytes) ist die minimale Stapelgröße, und die Seitengröße ist 64KB (65.536 Byte).  
  
> [!NOTE]
>  In Versionen von Microsoft Windows vor Windows XP und Windows Server 2003 `maxStackSize` ignoriert, und die Größe des Stapels im Header ausführbaren Datei angegeben werden.  
  
 Wenn Sie eine sehr kleine Stapelgröße angeben, müssen Sie möglicherweise Stapelüberlaufs deaktivieren. Wenn der Stapel stark eingeschränkt ist, kann, auf dem sich selbst einen Stapelüberlauf verursachen die Überprüfung. Um Stapelüberlaufs zu deaktivieren, fügen Sie Folgendes, um die Konfigurationsdatei der Anwendung.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löst eine <see cref="T:System.Threading.ThreadAbortException" /> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen. Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst eine <see cref="T:System.Threading.ThreadAbortException" /> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen. Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode in einem Thread aufgerufen wird, löst das System eine <xref:System.Threading.ThreadAbortException> im Thread aus, um ihn abzubrechen. `ThreadAbortException` ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, jedoch wird erneut ausgelöst wird, am Ende der `catch` blockieren, wenn <xref:System.Threading.Thread.ResetAbort%2A> aufgerufen wird. `ResetAbort` Bricht die Anforderung abbricht, ab und verhindert, dass die `ThreadAbortException` aus Beenden des Threads. Nicht ausgeführte `finally` -Blöcke werden vor dem Abbruch des Threads ausgeführt.  
  
> [!NOTE]
>  Wenn ein Thread ruft `Abort` für sich selbst, die Wirkung gleicht dem Auslösen einer Ausnahme, die <xref:System.Threading.ThreadAbortException> erfolgt sofort, und das Ergebnis ist vorhersagbar. Aber wenn ein Thread ruft `Abort` in einem anderen Thread unterbricht der Abbruch jeden beliebigen Code ausgeführt wird. Es ist auch möglich, dass ein statischer Konstruktor kann abgebrochen werden. In seltenen Fällen kann dies verhindern, dass Instanzen dieser Klasse, die in dieser Anwendungsdomäne erstellt wird. In der .NET Framework-Versionen 1.0 und 1.1, besteht die Möglichkeit den Thread abzubrechen konnte. während einer `finally` Block ausgeführt wird, in diesem Fall die `finally` abgebrochen wird.  
  
 Der Thread ist nicht garantiert, sofort oder überhaupt abgebrochen. Diese Situation kann auftreten, wenn ein Thread eine ungebundene Menge, der Berechnung in der Fall ist die `finally` Blöcke, die als Teil der Abort-Prozedur, die der Abbruch dadurch auf unbestimmte Zeit verzögert aufgerufen werden. Um warten, bis ein Thread abgebrochen wurde, rufen Sie die <xref:System.Threading.Thread.Join%2A> Methode für den Thread nach dem Aufruf der <xref:System.Threading.Thread.Abort%2A> -Methode, aber es gibt keine Garantie der Wartevorgang wird beendet.  
  
> [!NOTE]
>  Der aufrufende Thread <xref:System.Threading.Thread.Abort%2A> möglicherweise blockiert, wenn der Thread, die abgebrochen wird in einen geschützten Codebereich, z. B. eine `catch` Block `finally` Block oder eingeschränkten Ausführungsbereich. Wenn der Thread aufruft <xref:System.Threading.Thread.Abort%2A> eine Sperre, die der abgebrochene Thread erforderlich ist, kann ein Deadlock auftreten, enthält.  
  
 Wenn `Abort` wird aufgerufen, in einem Thread, der nicht gestartet wurde, wird den Thread abzubrechen Wenn <xref:System.Threading.Thread.Start%2A> aufgerufen wird. Wenn `Abort` wird aufgerufen, in einem Thread, der blockiert ist oder im Ruhezustand, der Thread unterbrochen wird, und dann abgebrochen.  
  
 Wenn `Abort` für einen Thread, der angehalten wurde, aufgerufen wird eine <xref:System.Threading.ThreadStateException> wird ausgelöst, in dem Thread, <xref:System.Threading.Thread.Abort%2A>, und <xref:System.Threading.ThreadState.AbortRequested> hinzugefügt wird die <xref:System.Threading.Thread.ThreadState%2A> Eigenschaft des Threads wird abgebrochen. Ein <xref:System.Threading.ThreadAbortException> wird nicht ausgelöst, in den angehaltenen Thread, bis <xref:System.Threading.Thread.Resume%2A> aufgerufen wird.  
  
 Wenn `Abort` für einen verwalteten Thread aufgerufen wird, während er nicht verwalteten Code ausführt, wird eine `ThreadAbortException` wird nicht ausgelöst, bis der Thread zu verwaltetem Code zurückkehrt.  
  
 Wenn zwei Aufrufe `Abort` kommen zur gleichen Zeit, es ist möglich, dass ein Aufruf zum Festlegen von Informationen über den Zustand und der andere Aufruf zum Ausführen der `Abort`. Eine Anwendung kann nicht jedoch, diese Situation erkennen.  
  
 Nach dem `Abort` wird aufgerufen, in einem Thread der Zustand des Threads enthält <xref:System.Threading.ThreadState.AbortRequested>. Nachdem der Thread, als Ergebnis einer erfolgreichen Aufruf von beendet wurde `Abort`, der Status des Threads wird geändert, um <xref:System.Threading.ThreadState.Stopped>. Ein Thread, der ist mit den entsprechenden Berechtigungen das Ziel einer `Abort` können abbrechen, diesen Vorgang unter Verwendung der `ResetAbort` Methode. Ein Beispiel zur Veranschaulichung von Aufrufen der `ResetAbort` -Methode finden Sie unter den `ThreadAbortException` Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der abgebrochene Thread ist derzeit angehalten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für erweiterte Vorgänge in Threads. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">Ein Objekt, das anwendungsspezifische Informationen enthält (z. B. über den Zustand), die vom abgebrochenen Thread verwendet werden können.</param>
        <summary>Löst eine <see cref="T:System.Threading.ThreadAbortException" /> im Thread aus, für den der Aufruf erfolgte, um das Beenden des Threads zu beginnen. Gleichzeitig werden Ausnahmeinformationen über das Beenden des Threads bereitgestellt. Durch den Aufruf dieser Methode wird der Thread i. d. R. beendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode in einem Thread aufgerufen wird, löst das System eine <xref:System.Threading.ThreadAbortException> im Thread aus, um ihn abzubrechen. `ThreadAbortException` ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, jedoch wird erneut ausgelöst wird, am Ende der `catch` blockieren, wenn <xref:System.Threading.Thread.ResetAbort%2A> aufgerufen wird. `ResetAbort` Bricht die Anforderung abbricht, ab und verhindert, dass die `ThreadAbortException` aus Beenden des Threads. Nicht ausgeführte `finally` -Blöcke werden vor dem Abbruch des Threads ausgeführt.  
  
> [!NOTE]
>  Wenn ein Thread ruft `Abort` für sich selbst, die Wirkung gleicht dem Auslösen einer Ausnahme, die <xref:System.Threading.ThreadAbortException> erfolgt sofort, und das Ergebnis ist vorhersagbar. Aber wenn ein Thread ruft `Abort` in einem anderen Thread unterbricht der Abbruch jeden beliebigen Code ausgeführt wird. Es besteht die Möglichkeit, dass ein statischer Konstruktor kann abgebrochen werden. In seltenen Fällen kann dies verhindern, dass Instanzen dieser Klasse, die in dieser Anwendungsdomäne erstellt wird. In der .NET Framework-Versionen 1.0 und 1.1, besteht die Möglichkeit den Thread abzubrechen konnte. während einer `finally` Block ausgeführt wird, in diesem Fall die `finally` abgebrochen wird.  
  
 Der Thread ist nicht garantiert, sofort oder überhaupt abgebrochen. Diese Situation kann auftreten, wenn ein Thread eine ungebundene Menge, der Berechnung in der Fall ist die `finally` Blöcke, die als Teil der Abort-Prozedur, die der Abbruch dadurch auf unbestimmte Zeit verzögert aufgerufen werden. Um warten, bis ein Thread abgebrochen wurde, rufen Sie die <xref:System.Threading.Thread.Join%2A> Methode für den Thread nach dem Aufruf der <xref:System.Threading.Thread.Abort%2A> -Methode, aber es gibt keine Garantie, die der Wartevorgang beendet wird.  
  
> [!NOTE]
>  Der aufrufende Thread <xref:System.Threading.Thread.Abort%2A> möglicherweise blockiert, wenn der Thread, die abgebrochen wird in einen geschützten Codebereich, z. B. eine `catch` Block `finally` Block oder eingeschränkten Ausführungsbereich. Wenn der Thread aufruft <xref:System.Threading.Thread.Abort%2A> eine Sperre, die der abgebrochene Thread erforderlich ist, kann ein Deadlock auftreten, enthält.  
  
 Wenn `Abort` wird aufgerufen, in einem Thread, der nicht gestartet wurde, wird den Thread abzubrechen Wenn <xref:System.Threading.Thread.Start%2A> aufgerufen wird. Wenn `Abort` wird aufgerufen, in einem Thread, der blockiert ist oder im Ruhezustand, der Thread unterbrochen wird, und dann abgebrochen.  
  
 Wenn `Abort` für einen Thread, der angehalten wurde, aufgerufen wird eine <xref:System.Threading.ThreadStateException> wird ausgelöst, in dem Thread, <xref:System.Threading.Thread.Abort%2A>, und <xref:System.Threading.ThreadState.AbortRequested> hinzugefügt wird die <xref:System.Threading.Thread.ThreadState%2A> Eigenschaft des Threads wird abgebrochen. Ein <xref:System.Threading.ThreadAbortException> wird nicht ausgelöst, in den angehaltenen Thread, bis <xref:System.Threading.Thread.Resume%2A> aufgerufen wird.  
  
 Wenn `Abort` für einen verwalteten Thread aufgerufen wird, während er nicht verwalteten Code ausführt, wird eine `ThreadAbortException` wird nicht ausgelöst, bis der Thread zu verwaltetem Code zurückkehrt.  
  
 Wenn zwei Aufrufe `Abort` kommen zur gleichen Zeit, es ist möglich, dass ein Aufruf zum Festlegen von Informationen über den Zustand und der andere Aufruf zum Ausführen der `Abort`. Eine Anwendung kann nicht jedoch, diese Situation erkennen.  
  
 Nach dem `Abort` wird aufgerufen, in einem Thread der Zustand des Threads enthält <xref:System.Threading.ThreadState.AbortRequested>. Nachdem der Thread, als Ergebnis einer erfolgreichen Aufruf von beendet wurde `Abort`, der Status des Threads wird geändert, um <xref:System.Threading.ThreadState.Stopped>. Ein Thread, der ist mit den entsprechenden Berechtigungen das Ziel einer `Abort` können abbrechen, diesen Vorgang unter Verwendung der `ResetAbort` Methode. Ein Beispiel zur Veranschaulichung von Aufrufen der `ResetAbort` -Methode finden Sie unter den `ThreadAbortException` Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Informationen an einen Thread zu übergeben, die abgebrochen wird.  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der abgebrochene Thread ist derzeit angehalten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für erweiterte Vorgänge in Threads. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reserviert einen unbenannten Datenslot für alle Threads. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <returns>Der reservierte benannte Datenslot für alle Threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework bietet zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (d. h. die Felder, die mit markiert sind die <xref:System.ThreadStaticAttribute> Attribut) und Datenslots. Threadbezogene statische Felder bieten viel bessere Leistung als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread-lokalen Speicher: threadbezogene statische Felder und Datenslots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Der Slot wird auf alle Threads zugeordnet.  
  
 Threads verwenden einen lokaler Speichermechanismus, um die Thread-spezifische Daten zu speichern. Die common Language Runtime ordnet ein Array mit mehreren Slot Data Store jeder Prozess, bei der Erstellung. Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen eines Wert im Slot und den Slot für die Wiederverwendung nach Ablauf des Threads freigeben. Datenslots sind pro Thread eindeutig. Kein anderer Thread (nicht einmal ein untergeordneter-Thread), kann diese Daten abzurufen.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel zeigt, wie Sie ein Feld verwenden, die mit der <xref:System.ThreadStaticAttribute> Attribut zum Speichern von Thread-spezifische Informationen. Das zweite Beispiel zeigt, wie Sie einen Datenslot, um das gleiche tun.  
  
 **Erste Beispiel**  
  
 Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit markierten <xref:System.ThreadStaticAttribute> zum Speichern von Thread-spezifische Informationen. Diese Technik bietet eine bessere Leistung als die Technik, die im zweiten Beispiel angezeigt wird.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweite Beispiel**  
  
 Das folgende Codebeispiel veranschaulicht einen Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu reservierenden Datenslots.</param>
        <summary>Reserviert einen benannten Datenslot für alle Threads. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <returns>Der reservierte benannte Datenslot für alle Threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework bietet zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (d. h. die Felder, die mit markiert sind die <xref:System.ThreadStaticAttribute> Attribut) und Datenslots. Threadbezogene statische Felder bieten viel bessere Leistung als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread-lokalen Speicher: threadbezogene statische Felder und Datenslots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads verwenden einen lokaler Speichermechanismus, um die Thread-spezifische Daten zu speichern. Die common Language Runtime ordnet ein Array mit mehreren Slot Data Store jeder Prozess, bei der Erstellung. Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen eines Wert im Slot und den Slot für die Wiederverwendung nach Ablauf des Threads freigeben. Datenslots sind pro Thread eindeutig. Kein anderer Thread (nicht einmal ein untergeordneter-Thread), kann diese Daten abzurufen.  
  
 Es ist nicht erforderlich, verwenden die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> Methode, um einen benannten Datenslot, reserviert werden, da die <xref:System.Threading.Thread.GetNamedDataSlot%2A> Methode ordnet den Slot an, wenn es nicht bereits zugewiesen wurde.  
  
> [!NOTE]
>  Wenn die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> Methode wird verwendet, es sollte im Hauptthread bei Programmstart aufgerufen werden, da es eine Ausnahme auslöst, wenn ein Slot mit dem angegebenen Namen bereits zugewiesen wurde. Es gibt keine Möglichkeit zu prüfen, ob es sich bei ein Slot bereits zugeordnet wurde.  
  
 Slots zugewiesen, die mit dieser Methode müssen mit dem freigegeben <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel zeigt, wie Sie ein Feld verwenden, die mit der <xref:System.ThreadStaticAttribute> Attribut zum Speichern von Thread-spezifische Informationen. Das zweite Beispiel zeigt, wie Sie einen Datenslot, um das gleiche tun.  
  
 **Erste Beispiel**  
  
 Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit markierten <xref:System.ThreadStaticAttribute> zum Speichern von Thread-spezifische Informationen. Diese Technik bietet eine bessere Leistung als die Technik, die im zweiten Beispiel angezeigt wird.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweite Beispiel**  
  
 Im folgende Beispiel wird veranschaulicht, wie Sie einen benannten Datenslot, um die Thread-spezifische Informationen zu speichern.  
  
> [!NOTE]
>  Der Beispielcode verwendet nicht die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> -Methode, da die <xref:System.Threading.Thread.GetNamedDataSlot%2A> Methode ordnet den Slot an, wenn es nicht bereits zugewiesen wurde. Wenn die <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> Methode wird verwendet, sollte im Hauptthread beim Programmstart aufgerufen werden.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es ist bereits ein benannter Datenslot mit dem angegebenen Namen vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Apartmentzustand dieses Threads ab oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Threading.ApartmentState" />-Werte. Der Anfangswert ist <see langword="Unknown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Die <xref:System.Threading.Thread.ApartmentState%2A> Eigenschaft ist veraltet.**  Der nicht veralteten Alternativen sind die <xref:System.Threading.Thread.GetApartmentState%2A> Methode, um den Apartmentzustand abzurufen und die <xref:System.Threading.Thread.SetApartmentState%2A> Methode, um der Apartmentzustand festgelegt.  
  
 In den .NET Framework-Versionen 1.0 und 1.1 die `ApartmentState` Eigenschaft kennzeichnet einen Thread aus, um anzugeben, dass er in einem Singlethread-Apartment oder Multithread-Apartment ausgeführt wird. Diese Eigenschaft kann festgelegt werden, wenn der Thread in ist die `Unstarted` oder `Running` Threadzustand befindet; er kann jedoch festgelegt werden nur einmal für einen Thread. Wenn die Eigenschaft nicht festgelegt wurde, gibt es `Unknown`.  
  
 Verwendung der <xref:System.Threading.Thread.ApartmentState%2A> Eigenschaft, um den Apartmentzustand eines Threads festzulegen, dessen Apartmentzustand bereits festgelegt wurde wurde, wird ignoriert. Allerdings die <xref:System.Threading.Thread.SetApartmentState%2A> -Methode löst eine <xref:System.InvalidOperationException> in diesem Fall.  
  
> [!IMPORTANT]
>  In .NET Framework, Version 2.0, neue Threads werden als initialisiert <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> Wenn ihr Apartmentzustand nicht festgelegt wurde, bevor sie gestartet werden. Thread der hauptanwendung wird initialisiert, um <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> standardmäßig. Legen Sie nicht mehr den Hauptanwendungsthread auf <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> durch Festlegen der <xref:System.Threading.ApartmentState?displayProperty=nameWithType> Eigenschaft in der ersten Zeile des Codes. Verwenden der <xref:System.STAThreadAttribute> stattdessen.  
  
 In .NET Framework, Version 2.0, können Sie angeben, die COM-Threadingmodell für eine C++-Anwendung mit der [/CLRTHREADATTRIBUTE (festlegen CLR-Threadattributs)](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) -Linkeroption.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Apartmentzustand eines Threads festgelegt wird.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wird versucht, diese Eigenschaft in einen Zustand zu versetzen, der kein gültiger Apartmentzustand ist, d. h. in einen anderen Zustand als Singlethread-Apartment (<see langword="STA" />) oder Multithread-Apartment (<see langword="MTA" />).</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt einen Host, dass die Ausführung im Begriff ist, zu einem Codebereich überzugehen, in dem die Auswirkungen eines Threadabbruchs oder einer nicht behandelten Ausnahme andere Aufgaben in der Anwendungsdomäne gefährden könnten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosts, der die common Language Runtime (CLR), z. B. Microsoft SQL Server 2005 können unterschiedliche Richtlinien für Fehler in kritischen und nicht kritische Bereiche des Codes herstellen. Ein kritischen Bereich sind in dem die Auswirkungen eines Threadabbruchs oder einer nicht behandelten Ausnahme möglicherweise nicht auf die aktuelle Aufgabe beschränkt werden. Im Gegensatz dazu, wirkt sich auf einen Abbruch oder Fehler in einem nicht-kritische Codebereich nur die Aufgabe, die in der der Fehler aufgetreten.  
  
 Betrachten Sie beispielsweise einen Task, der versucht wird, um Speicher zu belegen, während eine Sperre. Wenn die speicherbelegung fehlschlägt, Abbrechen der aktuellen Aufgabe ist nicht ausreichend, um die Stabilität des gewährleisten die <xref:System.AppDomain>, da möglicherweise andere Aufgaben in der Domäne, die die gleiche Sperre warten. Wenn die aktuelle Aufgabe beendet wird, können andere Aufgaben zum Stillstand.  
  
 Wenn ein Fehler in einem kritischen Bereich auftritt, kann der Host die gesamte entladen <xref:System.AppDomain> statt das Risiko der Ausführung in einem potenziell unstabilen Status fortzusetzen eingehen. Aufrufen, um dem Host darüber zu informieren, dass der Code einen kritischen Bereich eintritt, <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Rufen Sie <xref:System.Threading.Thread.EndCriticalRegion%2A> Ausführung in einem nicht-kritischen Bereich des Codes zurück.  
  
 Mit dieser Methode im Code, der unter SQL Server 2005 ausgeführt wird, muss der Code auf die höchste Schutzebene für den Host ausgeführt werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.Threading.Thread.BeginCriticalRegion%2A> und <xref:System.Threading.Thread.EndCriticalRegion%2A> Methoden, um einen Codeblock in kritische und nicht kritische Bereiche zu unterteilen.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt einen Host, dass verwalteter Code im Begriff ist, Anweisungen auszuführen, die von der Identität des aktuellen physischen Betriebssystemthreads abhängen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Hosts von der common Language Runtime, z. B. Microsoft SQL Server 2005, geben Sie ihre eigenen Threads zu verwalten. Ein Host, der einen eigenen Threadverwaltung bereitstellt, kann eine auszuführende Aufgabe zu einem beliebigen Zeitpunkt aus einem physischen Betriebssystemthreads zu einem anderen verschieben. Die meisten Aufgaben sind von diesem Wechsel nicht betroffen. Allerdings einige Aufgaben Threadaffinität –, also in dem sie die Identität des physischen Betriebssystemthreads abhängen. Dazu müssen der Host informieren, wenn sie Code ausführen, der nicht verwendet werden soll.  
  
 Wenn z. B. sperren, ruft Ihre Anwendung eine System-API zum Abrufen eines Betriebssystems, die Threadaffinität, z. B. Win32 CRITICAL_SECTION, müssen Sie aufrufen <xref:System.Threading.Thread.BeginThreadAffinity%2A> vor dem Abrufen der Sperre und <xref:System.Threading.Thread.EndThreadAffinity%2A> nach dem Aufheben der Sperre.  
  
 Mit dieser Methode im Code, der unter SQL Server 2005 ausgeführt wird, muss der Code auf die höchste Schutzebene für den Host ausgeführt werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.Threading.Thread.BeginThreadAffinity%2A> und <xref:System.Threading.Thread.EndThreadAffinity%2A> Methoden, um einen Host zu benachrichtigen, die ein Codeblock auf die Identität des physischen Betriebssystemthreads abhängen.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den aktuellen Kontext ab, in dem der Thread ausgeführt wird.</summary>
        <value>Ein <see cref="T:System.Runtime.Remoting.Contexts.Context" /> der den aktuellen Kontext des Threads darstellt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Kultur für den aktuellen Thread ab oder legt diese fest.</summary>
        <value>Ein Objekt, das die Kultur für den aktuellen Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Globalization.CultureInfo> Objekt, das von dieser Eigenschaft zusammen mit seiner zugeordneten Objekte, zurückgegeben wird zu bestimmen, das Standardformat für Datum, Uhrzeit, Zahlen, Currency-Werte, die Sortierreihenfolge des Texts, Groß-/ Kleinschreibungskonventionen und Zeichenfolgenvergleichen. Finden Sie unter den <xref:System.Globalization.CultureInfo> Klasse, um Informationen über Kulturnamen und Bezeichner, die Unterschiede zwischen invarianten, neutrale und spezifische Kulturen und wirkt sich die kulturinformationen für die Möglichkeit, Threads und Anwendungsdomänen. Finden Sie unter den <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> Eigenschaft, um zu erfahren, wie die Kultur eines Threads Standardwert festgelegt wird und wie Benutzer Informationen zur Kultur für ihre Computer festgelegt.  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], Sie können festlegen, die <xref:System.Threading.Thread.CurrentCulture%2A> Eigenschaft, um eine neutrale Kultur. Grund hierfür ist, das Verhalten von der <xref:System.Globalization.CultureInfo> Klasse hat sich geändert: Wenn sie eine neutrale Kultur, die Eigenschaftswerte darstellt (insbesondere die <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, und <xref:System.Globalization.CultureInfo.TextInfo%2A> Eigenschaften) jetzt entsprechend die spezifische Kultur, die die neutrale Kultur zugeordnet ist. In früheren Versionen von .NET Framework die <xref:System.Threading.Thread.CurrentCulture%2A> Eigenschaft hat einen <xref:System.NotSupportedException> Ausnahme aus, wenn eine neutrale Kultur zugewiesen wurde.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die threading-Anweisung, die können die Benutzeroberfläche einer Windows Forms in der Kultur angezeigt, die in der Systemsteuerung festgelegt wird. Es ist zusätzlicher Code erforderlich.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Eigenschaft ist auf <see langword="null" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Festlegen der Eigenschaft an. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den aktuellen Prinzipal des Threads (für rollenbasierte Sicherheit) ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Security.Principal.IPrincipal" />-Wert, der den Sicherheitskontext darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen und Abrufen des Prinzipals eines Threads.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung zum Festlegen des Prinzipals.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">das Prinzipalobjekt bearbeiten zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den derzeit ausgeführten Thread ab.</summary>
        <value>Ein <see cref="T:System.Threading.Thread" />, der den derzeit ausgeführten Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine Aufgabe, die wiederum 20 untergeordneten Aufgaben erstellt. Ruft die Anwendung selbst, wie auch jede Aufgabe die `ShowThreadInformation` Methode, die verwendet die <xref:System.Threading.Thread.CurrentThread%2A> Eigenschaft, um Informationen zum Thread anzuzeigen, auf dem er ausgeführt wird.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 Jede untergeordnete Aufgabe 1 Millionen zufällige Zahlen zwischen 1 und 1 Million generiert und ihrem Mittelwert zurückgegeben. Der übergeordnete Task Ruft die <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> Methode, um sicherzustellen, dass die untergeordneten Aufgaben abgeschlossen wurden, vor der Anzeige des Mittelwerts von jeder Aufgabe zurückgegebenen und berechnet den Mittelwert der bedeutet.  
  
 Beachten Sie, dass während der Ausführung der Anwendung auf ein Vordergrundthread, jede Aufgabe in einem Threadpoolthread ausgeführt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Kultur ab, mit deren Hilfe der Ressourcen-Manager zur Laufzeit kulturabhängige Ressourcen sucht, oder legt diese fest.</summary>
        <value>Ein Objekt, das die aktuelle Kultur darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Benutzeroberflächenkultur gibt die Ressourcen, die eine Anwendung Benutzer ein- und Ausgaben unterstützen muss, die und in der Standardeinstellung ist identisch mit dem Betriebssystem-Kultur, an. Finden Sie unter den <xref:System.Globalization.CultureInfo> Klasse, um Informationen über Kulturnamen und Bezeichner, die Unterschiede zwischen invarianten, neutrale und spezifische Kulturen und wirkt sich die kulturinformationen für die Möglichkeit, Threads und Anwendungsdomänen. Finden Sie unter den <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft, um zu erfahren, wie die Standard-Benutzeroberflächenkultur eines Threads bestimmt wird.  
  
 Die <xref:System.Globalization.CultureInfo> von dieser Eigenschaft zurückgegebene eine neutrale Kultur sein können. Neutrale Kulturen sollte nicht verwendet werden, z. B. Formatierungsmethoden <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, und <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>. Verwenden Sie die <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> Methode, um eine bestimmte Kultur abrufen oder verwenden Sie die <xref:System.Threading.Thread.CurrentCulture%2A> Eigenschaft.  
  
> [!NOTE]
>  Die <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> -Methode löst <xref:System.ArgumentException> für die neutralen Kulturen "Zh-Hant" ("Zh-CHT") und "Zh-Hans" ("Zh-CHS").  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob die Sprache des UI-Kultur des aktuellen Threads Französisch. Wenn sie nicht der Fall ist, wird die UI-Kultur des aktuellen Threads auf Englisch (Vereinigte Staaten) festgelegt.  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 Das folgende Codebeispiel zeigt die threading-Anweisung, die können die Benutzeroberfläche einer Windows Forms in der Kultur angezeigt, die in der Systemsteuerung festgelegt wird. Es ist zusätzlicher Code erforderlich.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Eigenschaft ist auf <see langword="null" /> festgelegt.</exception>
        <exception cref="T:System.ArgumentException">Die Eigenschaft ist auf einen Kulturnamen festgelegt, der nicht zum Suchen einer Ressourcendatei verwendet werden kann. Ressourcendateinamen dürfen nur Buchstaben, Zahlen, Bindestriche oder Unterstriche enthalten.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deaktiviert die automatische Bereinigung von Runtime Callable Wrappern (RCW) für den aktuellen Thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löscht die common Language Runtime (CLR) Runtime callable Wrapper automatisch. Die CLR Pumpen Nachrichten bei der Bereinigung, die Eintrittsinvarianz Probleme für einige Anwendungen verursachen kann, die folgenden ungewöhnlichen Kriterien erfüllen:  
  
-   Die Anwendung führt eine eigene meldungsweiterleitung.  
  
-   Die Anwendung muss genau bei meldungsweiterleitung zu steuern.  
  
 Solche Anwendungen können die <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> Methode, um zu verhindern, dass die CLR ausführen Automatische Freigabe von Runtime callable Wrapper.  
  
 Wenn diese Methode in einem Thread aufgerufen wurde, darf nicht die automatische Bereinigung erneut für diesen Thread aktiviert sein. Wenn Ihre Anwendung zum Bereinigen von Runtime callable Wrapper bereit ist, verwenden Sie die <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> Methode, um die Laufzeitkomponente anzuweisen, bereinigen alle Runtime callable Wrapper im aktuellen Kontext. Meldungsweiterleitung tritt auf, während die Methode ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt einen Host, dass die Ausführung im Begriff ist, zu einem Codebereich überzugehen, in dem die Auswirkungen eines Threadabbruchs oder einer nicht behandelten Ausnahme auf die aktuelle Aufgabe beschränkt sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosts, der die common Language Runtime (CLR), z. B. Microsoft SQL Server 2005 können unterschiedliche Richtlinien für Fehler in kritischen und nicht kritische Bereiche des Codes herstellen. Ein kritischen Bereich sind in dem die Auswirkungen eines Threadabbruchs oder einer nicht behandelten Ausnahme möglicherweise nicht auf die aktuelle Aufgabe beschränkt werden. Im Gegensatz dazu, wirkt sich auf einen Abbruch oder Fehler in einem nicht-kritische Codebereich nur die Aufgabe, die in der der Fehler aufgetreten.  
  
 Betrachten Sie beispielsweise einen Task, der versucht wird, um Speicher zu belegen, während eine Sperre. Wenn die speicherbelegung fehlschlägt, Abbrechen der aktuellen Aufgabe ist nicht ausreichend, um die Stabilität des gewährleisten die <xref:System.AppDomain>, da möglicherweise andere Aufgaben in der Domäne, die die gleiche Sperre warten. Wenn die aktuelle Aufgabe beendet wird, können andere Aufgaben zum Stillstand.  
  
 Wenn ein Fehler in einem kritischen Bereich auftritt, kann der Host die gesamte entladen <xref:System.AppDomain> statt das Risiko der Ausführung in einem potenziell unstabilen Status fortzusetzen eingehen. Aufrufen, um dem Host darüber zu informieren, dass der Code einen kritischen Bereich eintritt, <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Rufen Sie <xref:System.Threading.Thread.EndCriticalRegion%2A> Ausführung in einem nicht-kritischen Bereich des Codes zurück.  
  
 Mit dieser Methode im Code, der unter SQL Server 2005 ausgeführt wird, muss der Code auf die höchste Schutzebene für den Host ausgeführt werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.Threading.Thread.BeginCriticalRegion%2A> und <xref:System.Threading.Thread.EndCriticalRegion%2A> Methoden, um einen Codeblock in kritische und nicht kritische Bereiche zu unterteilen.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt einen Host, dass verwalteter Code die Ausführung von Anweisungen beendet hat, die von der Identität des aktuellen physischen Betriebssystemthreads abhängen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Hosts von der common Language Runtime, z. B. Microsoft SQL Server 2005, geben Sie ihre eigenen Threads zu verwalten. Ein Host, der einen eigenen Threadverwaltung bereitstellt, kann eine auszuführende Aufgabe zu einem beliebigen Zeitpunkt aus einem physischen Betriebssystemthreads zu einem anderen verschieben. Die meisten Aufgaben sind von diesem Wechsel nicht betroffen. Allerdings einige Aufgaben Threadaffinität –, also in dem sie die Identität des physischen Betriebssystemthreads abhängen. Dazu müssen der Host informieren, wenn sie Code ausführen, der nicht verwendet werden soll.  
  
 Wenn z. B. sperren, ruft Ihre Anwendung eine System-API zum Abrufen eines Betriebssystems, die Threadaffinität, z. B. Win32 CRITICAL_SECTION, müssen Sie aufrufen <xref:System.Threading.Thread.BeginThreadAffinity%2A> vor dem Abrufen der Sperre und <xref:System.Threading.Thread.EndThreadAffinity%2A> nach dem Aufheben der Sperre.  
  
 Mit dieser Methode im Code, der unter SQL Server 2005 ausgeführt wird, muss der Code auf die höchste Schutzebene für den Host ausgeführt werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.Threading.Thread.BeginThreadAffinity%2A> und <xref:System.Threading.Thread.EndThreadAffinity%2A> Methoden, um einen Host zu benachrichtigen, die ein Codeblock auf die Identität des physischen Betriebssystemthreads abhängen.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.ExecutionContext" />-Objekt ab, das Informationen zu den verschiedenen Kontexten des aktuellen Threads enthält.</summary>
        <value>Ein <see cref="T:System.Threading.ExecutionContext" />-Objekt, das Kontextinformationen für den aktuellen Thread konsolidiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.ExecutionContext> Klasse stellt einen einzelnen Container für alle Informationen relevant für einen logischen Thread der Ausführung bereit. Dies schließt Sicherheitskontext, Aufrufkontext, Synchronisierungskontext, Lokalisierungskontext und Transaktionskontext.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt das Freigeben von Ressourcen und das Ausführen anderer Garbage Collector-Vorgänge sicher, wenn der Garbage Collector das <see cref="T:System.Threading.Thread" />-Objekt verarbeitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Garbage Collector ruft <xref:System.Threading.Thread.Finalize%2A> Wenn das aktuelle Objekt wird finalisiert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des freizugebenden Datenslots.</param>
        <summary>Entfernt die Zuordnung zwischen einem Namen und einem Slot für alle Threads in dem Prozess. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework bietet zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (d. h. die Felder, die mit markiert sind die <xref:System.ThreadStaticAttribute> Attribut) und Datenslots. Threadbezogene statische Felder bieten viel bessere Leistung als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread-lokalen Speicher: threadbezogene statische Felder und Datenslots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Nach dem Aufrufen `FreeNamedDataSlot`, jeden Thread, der Aufrufe <xref:System.Threading.Thread.GetNamedDataSlot%2A> mit dem gleichen Namen wird einen neuen Slot verknüpft ist, mit dem Namen zuordnen. Nachfolgende Aufrufe von `GetNamedDataSlot` von jedem Thread des neuen Slots zurück. Allerdings einen beliebigen Thread, der immer noch eine <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> von einem früheren Aufruf zurückgegebenen `GetNamedDataSlot` können weiterhin den alten Slot verwenden.  
  
 Ein Slot, die mit einem Namen zugeordnet wurde freigegeben nur, wenn alle `LocalDataStoreSlot` , die abgerufen wurde, vor dem Aufruf von `FreeNamedDataSlot` veröffentlicht und Garbage Collection durchgeführt wurde.  
  
 Threads verwenden einen lokaler Speichermechanismus, um die Thread-spezifische Daten zu speichern. Die common Language Runtime ordnet ein Array mit mehreren Slot Data Store jeder Prozess, bei der Erstellung. Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen eines Wert im Slot und den Slot für die Wiederverwendung nach Ablauf des Threads freigeben. Datenslots sind pro Thread eindeutig. Kein anderer Thread (nicht einmal ein untergeordneter-Thread), kann diese Daten abzurufen.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel zeigt, wie Sie ein Feld verwenden, die mit der <xref:System.ThreadStaticAttribute> Attribut zum Speichern von Thread-spezifische Informationen. Das zweite Beispiel zeigt, wie Sie einen Datenslot, um das gleiche tun.  
  
 **Erste Beispiel**  
  
 Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit markierten <xref:System.ThreadStaticAttribute> zum Speichern von Thread-spezifische Informationen. Diese Technik bietet eine bessere Leistung als die Technik, die im zweiten Beispiel angezeigt wird.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweite Beispiel**  
  
 Im folgende Beispiel wird veranschaulicht, wie Sie einen benannten Datenslot, um die Thread-spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Threading.ApartmentState" />-Wert zurück, der den Apartmentzustand angibt.</summary>
        <returns>Einer der <see cref="T:System.Threading.ApartmentState" />-Werte, der den Apartmentzustand des verwalteten Threads angibt. Der Standardwert ist <see cref="F:System.Threading.ApartmentState.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zusammen mit den <xref:System.Threading.Thread.SetApartmentState%2A> Methode und die <xref:System.Threading.Thread.TrySetApartmentState%2A> Methode ersetzt die <xref:System.Threading.Thread.ApartmentState%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, und <xref:System.Threading.Thread.TrySetApartmentState%2A> Methoden. Das Codebeispiel erstellt einen Thread. Vor dem Starten des Threads <xref:System.Threading.Thread.GetApartmentState%2A> zeigt den ersten <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> Zustand und <xref:System.Threading.Thread.SetApartmentState%2A> ändert den Zustand in <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Die <xref:System.Threading.Thread.TrySetApartmentState%2A> dann Methodenrückgabe `false` beim Versuch, den Status zu ändern, <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> da bereits der Apartmentzustand festgelegt wurde. Bei der Ausführung des gleichen Vorgangs mit <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> würde ausgelöst wurden.  
  
 Nachdem der Thread gestartet wurde, die <xref:System.Threading.Thread.TrySetApartmentState%2A> Methode erneut verwendet wird. Sie löst dieses Mal <xref:System.Threading.ThreadStateException> , da der Thread wurde bereits gestartet wurde.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Threading.CompressedStack" />-Objekt zurück, mit dem der Stapel für den aktuellen Thread erfasst werden kann.</summary>
        <returns>Keine</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird nicht mehr unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In allen Fällen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">Der <see cref="T:System.LocalDataStoreSlot" />, aus dem der Wert abgerufen werden soll.</param>
        <summary>Ruft in der aktuellen Domäne des aktuellen Threads den Wert aus dem angegebenen Slot für den aktuellen Thread ab. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <returns>Der abgerufene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework bietet zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (d. h. die Felder, die mit markiert sind die <xref:System.ThreadStaticAttribute> Attribut) und Datenslots. Threadbezogene statische Felder bieten viel bessere Leistung als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread-lokalen Speicher: threadbezogene statische Felder und Datenslots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads verwenden einen lokaler Speichermechanismus, um die Thread-spezifische Daten zu speichern. Die common Language Runtime ordnet ein Array mit mehreren Slot Data Store jeder Prozess, bei der Erstellung. Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen eines Wert im Slot und den Slot für die Wiederverwendung nach Ablauf des Threads freigeben. Datenslots sind pro Thread eindeutig. Kein anderer Thread (nicht einmal ein untergeordneter-Thread), kann diese Daten abzurufen.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> ist eine `Shared` -Methode, die immer auf den derzeit ausgeführten Thread angewendet wird, auch wenn Sie mit einer Variablen, die auf einem anderen Thread aufgerufen. Um Verwirrung zu vermeiden, verwenden Sie den Namen der Klasse beim Aufrufen von `Shared` Methoden: `Dim test As Object = Thread.GetData(testSlot)`.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel zeigt, wie Sie ein Feld verwenden, die mit der <xref:System.ThreadStaticAttribute> Attribut zum Speichern von Thread-spezifische Informationen. Das zweite Beispiel zeigt, wie Sie einen Datenslot, um das gleiche tun.  
  
 **Erste Beispiel**  
  
 Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit markierten <xref:System.ThreadStaticAttribute> zum Speichern von Thread-spezifische Informationen. Diese Technik bietet eine bessere Leistung als die Technik, die im zweiten Beispiel angezeigt wird.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweite Beispiel**  
  
 Das folgende Beispiel veranschaulicht einen Datenslot zu verwenden, um die Thread-spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die aktuelle Domäne zurück, in der der aktuelle Thread ausgeführt wird.</summary>
        <returns>Eine <see cref="T:System.AppDomain" />, die die aktuelle Anwendungsdomäne des ausgeführten Threads darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Namen und die ID des abzurufenden der `AppDomain` in der der Thread ausgeführt wird.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen eindeutigen Bezeichner der Anwendungsdomäne zurück.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, mit der die Anwendungsdomäne eindeutig bezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Namen und die ID des abzurufenden der `AppDomain` in der der Thread ausgeführt wird.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashcode für den aktuellen Thread zurück.</summary>
        <returns>Ein ganzzahliger Hashcodewert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Hashcode ist nicht unbedingt eindeutig sein. Verwenden der <xref:System.Threading.Thread.ManagedThreadId%2A> Eigenschaft, wenn Sie einen eindeutigen Bezeichner für einen verwalteten Thread benötigen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des lokalen Datenslots.</param>
        <summary>Sucht einen benannten Datenslot. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <returns>Ein für diesen Thread reservierter <see cref="T:System.LocalDataStoreSlot" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework bietet zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (d. h. die Felder, die mit markiert sind die <xref:System.ThreadStaticAttribute> Attribut) und Datenslots. Threadbezogene statische Felder bieten viel bessere Leistung als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread-lokalen Speicher: threadbezogene statische Felder und Datenslots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads verwenden einen lokaler Speichermechanismus, um die Thread-spezifische Daten zu speichern. Die common Language Runtime ordnet ein Array mit mehreren Slot Data Store jeder Prozess, bei der Erstellung. Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen eines Wert im Slot und den Slot für die Wiederverwendung nach Ablauf des Threads freigeben. Datenslots sind pro Thread eindeutig. Kein anderer Thread (nicht einmal ein untergeordneter-Thread), kann diese Daten abzurufen.  
  
 Wenn der benannte Datenslot nicht vorhanden ist, wird ein neuer Slot zugeordnet. Benannte Datenslots sind öffentlich und können von jedermann bearbeitet werden.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel zeigt, wie Sie ein Feld verwenden, die mit der <xref:System.ThreadStaticAttribute> Attribut zum Speichern von Thread-spezifische Informationen. Das zweite Beispiel zeigt, wie Sie einen Datenslot, um das gleiche tun.  
  
 **Erste Beispiel**  
  
 Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit markierten <xref:System.ThreadStaticAttribute> zum Speichern von Thread-spezifische Informationen. Diese Technik bietet eine bessere Leistung als die Technik, die im zweiten Beispiel angezeigt wird.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweite Beispiel**  
  
 Im folgende Beispiel wird veranschaulicht, wie Sie einen benannten Datenslot, um die Thread-spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterbricht einen Thread, der sich im <see langword="WaitSleepJoin" />-Threadzustand befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieser Thread zurzeit nicht in einer warten, Standby- oder Verknüpfungszustand blockiert wird, werden sie beim Beginn des nächsten block unterbrochen.  
  
 <xref:System.Threading.ThreadInterruptedException> in den unterbrochenen THEAD, aber erst, nachdem der Thread blockiert wird ausgelöst werden. Wenn der Thread nie blockiert wird, wird keine Ausnahme ausgelöst und daher möglicherweise der Thread abgeschlossen, ohne jemals unterbrochen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Verhalten der einen laufenden Thread auf, wenn er unterbrochen wird, und anschließend gesperrt wird.  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für erweiterte Vorgänge in Threads. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den Ausführungsstatus des aktuellen Threads angibt.</summary>
        <value>
          <see langword="true" />, wenn dieser Thread gestartet und ordnungsgemäß beendet bzw. abgebrochen wurde, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob es sich bei einem Thread um einen Hintergrundthread handelt, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn dieser Thread ein Hintergrundthread ist oder zu einem solchen wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread ist entweder ein Hintergrund- oder Vordergrundthread. Hintergrundthreads sind identisch mit Vordergrundthreads, außer dass Hintergrundthreads einen Prozess beendet wird nicht verhindern. Sobald alle zu einem Prozess gehörenden Vordergrundthreads beendet wurden, beendet die common Language Runtime den Prozess an. Alle verbleibenden Hintergrundthreads werden beendet und nicht vollständig.  
  
 Standardmäßig werden die folgenden Threads im Vordergrund ausgeführt (d. h. deren <xref:System.Threading.Thread.IsBackground%2A> -Eigenschaft gibt `false`):  
  
-   Der primäre Thread (oder den Hauptthread der Anwendung).  
  
-   Alle Threads, die durch den Aufruf erstellt einen <xref:System.Threading.Thread> Klassenkonstruktor.  
  
 Standardmäßig werden die folgenden Threads im Hintergrund ausführen (d. h. ihre <xref:System.Threading.Thread.IsBackground%2A> -Eigenschaft gibt `true`):  
  
-   Thread Poolthreads, die einen Pool von Arbeitsthreads, die von der Laufzeit verwaltet werden. Sie können die Thread-Pool und den Zeitplan der Arbeit in Threads im Threadpool konfigurieren, mit der <xref:System.Threading.ThreadPool> Klasse.  
  
    > [!NOTE]
    >  Aufgabenbasierte asynchrone Vorgänge werden automatisch in Threads im Threadpool ausgeführt.  
  
-   Alle Threads, die die verwaltete ausführungsumgebung von nicht verwaltetem Code eingeben.  
  
   
  
## Examples  
 Im folgende Beispiel steht im Gegensatz zu dem Verhalten der Vordergrund-und Hintergrundthreads. Erstellt ein Vordergrundthread und einem Hintergrundthread. Der Vordergrundthread erhält den Prozess bis abgeschlossen ist seine `for` Schleife und wird beendet. Allerdings wie die Ausgabe des Beispiels zeigt, da der Vordergrundthread Ausführung abgeschlossen wurde, wird der Prozess beendet, bevor der Hintergrundthread die Ausführung abgeschlossen wurde.  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread ist deaktiviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Thread zu dem verwalteten Threadpool gehört.</summary>
        <value>
          <see langword="true" />, wenn der Thread zu dem verwalteten Threadpool gehört, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [der verwaltete Thread Pool](~/docs/standard/threading/the-managed-thread-pool.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, zu bestimmen, ob ein Thread aus dem Threadpool ist.  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blockiert den aufrufenden Thread, bis der durch diese Instanz dargestellte Thread beendet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blockiert den aufrufenden Thread, bis der durch diese Instanz dargestellte Thread beendet wird, während das Standard-COM- und das <see langword="SendMessage" />-Pumping fortgesetzt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> ist eine Synchronisierungsmethode, die blockiert den aufrufenden Thread (d. h. der Thread, der die Methode aufruft), bis der Thread, dessen <xref:System.Threading.Thread.Join%2A> aufgerufen wurde abgeschlossen. Verwenden Sie diese Methode, um sicherzustellen, dass ein Thread beendet wurde. Der Aufrufer wird auf unbestimmte Zeit blockiert, wenn der Thread nicht beendet wird. Im folgenden Beispiel die `Thread1` thread Ruft die <xref:System.Threading.Thread.Join> -Methode der `Thread2`, bewirkt, dass `Thread1` Block bis `Thread2` wurde abgeschlossen.  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 Wenn der Thread bereits beendet wurde <xref:System.Threading.Thread.Join%2A> aufgerufen wird, wird die Methode sofort zurückgegeben.  
  
> [!WARNING]
>  Sie sollten niemals aufrufen, die <xref:System.Threading.Thread.Join%2A> -Methode der der <xref:System.Threading.Thread> Objekt, das den aktuellen Thread aus dem aktuellen Thread darstellt. Dies bewirkt, dass Ihre app nicht mehr reagiert, da der aktuelle Thread auf sich selbst beim unbegrenzt wartet,  
  
 Diese Methode ändert den Zustand des aufrufenden Threads einschließen <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Sie können nicht aufgerufen werden `Join` auf einen Thread, in der <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> Zustand.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Aufrufer hat versucht, mit einem Thread zu verknüpfen, der den Zustand <see cref="F:System.Threading.ThreadState.Unstarted" /> hat.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Der Thread wird beim Warten unterbrochen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl der Millisekunden, die auf das Beenden des Threads gewartet werden soll.</param>
        <summary>Blockiert den aufrufenden Thread, bis der von dieser Instanz dargestellte Thread beendet wird, oder die festgelegte Zeit verstreicht, während das Standard-COM- und das SendMessage-Pumping fortgesetzt werden.</summary>
        <returns>
          <see langword="true" />, wenn der Thread beendet wurde. <see langword="false" />, wenn der Thread nach Ablauf des vom <paramref name="millisecondsTimeout" />-Parameter angegebenen Zeitraums nicht beendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> ist eine Synchronisierungsmethode, die blockiert den aufrufenden Thread (d. h. der Thread, der die Methode aufruft), bis entweder der Thread, dessen <xref:System.Threading.Thread.Join%2A> Methode wird aufgerufen, abgeschlossen wurde oder das Timeoutintervall verstrichen ist. Im folgenden Beispiel die `Thread1` thread Ruft die <xref:System.Threading.Thread.Join> -Methode der `Thread2`, bewirkt, dass `Thread1` entweder bis zum Blockieren `Thread2` abgeschlossen wurde oder 2 Sekunden verstrichen sind.  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 Wenn <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> angegeben ist, für die `millisecondsTimeout` Parameter dieser Methode verhält sich genauso wie die <xref:System.Threading.Thread.Join> methodenüberladung, mit Ausnahme der zurückgegebene Wert.  
  
 Wenn der Thread bereits beendet wurde <xref:System.Threading.Thread.Join%2A> aufgerufen wird, wird die Methode sofort zurückgegeben.  
  
 Diese Methode ändert den Zustand des aufrufenden Threads einschließen <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Sie können nicht aufgerufen werden `Join` auf einen Thread, in der <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> Zustand.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="millisecondsTimeout" /> ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> in Millisekunden.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde nicht gestartet.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Ein <see cref="T:System.TimeSpan" />-Wert, der auf den Zeitraum festgelegt ist, während dessen auf das Beenden des Threads gewartet werden soll.</param>
        <summary>Blockiert den aufrufenden Thread, bis der von dieser Instanz dargestellte Thread beendet wird, oder die festgelegte Zeit verstreicht, während das Standard-COM- und das SendMessage-Pumping fortgesetzt werden.</summary>
        <returns>
          <see langword="true" />, wenn der Thread beendet wurde. <see langword="false" />, wenn der Thread nach Ablauf des vom <paramref name="timeout" />-Parameter angegebenen Zeitraums nicht beendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> ist eine Synchronisierungsmethode, die blockiert den aufrufenden Thread (d. h. der Thread, der die Methode aufruft), bis entweder der Thread, dessen <xref:System.Threading.Thread.Join%2A> Methode wird aufgerufen, abgeschlossen wurde oder das Timeoutintervall verstrichen ist. Im folgenden Beispiel die `Thread1` thread Ruft die <xref:System.Threading.Thread.Join> -Methode der `Thread2`, bewirkt, dass `Thread1` entweder bis zum Blockieren `Thread2` abgeschlossen wurde oder 2 Sekunden verstrichen sind.  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 Wenn <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für angegeben `timeout`, diese Methode verhält sich genauso wie die <xref:System.Threading.Thread.Join> methodenüberladung, mit Ausnahme der zurückgegebene Wert.  
  
 Wenn der Thread bereits beendet wurde <xref:System.Threading.Thread.Join%2A> aufgerufen wird, wird die Methode sofort zurückgegeben.  
  
 Diese Methode ändert den Zustand des aktuellen Threads einschließen <xref:System.Threading.ThreadState.WaitSleepJoin>. Sie können nicht aufgerufen werden `Join` auf einen Thread, in der <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> Zustand.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit einem `TimeSpan` Wert mit dem `Join` Methode.  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> in Millisekunden oder größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Aufrufer hat versucht, mit einem Thread zu verknüpfen, der den Zustand <see cref="F:System.Threading.ThreadState.Unstarted" /> hat.</exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen eindeutigen Bezeichner für den aktuellen verwalteten Thread ab.</summary>
        <value>Eine Ganzzahl, die einen eindeutigen Bezeichner für diesen verwalteten Thread darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eines Threads <xref:System.Threading.Thread.ManagedThreadId%2A> Eigenschaftswert dient zur eindeutigen Identifizierung von diesem Thread innerhalb des Prozesses.  
  
 Der Wert des der <xref:System.Threading.Thread.ManagedThreadId%2A> Eigenschaft ändern sich nicht im Laufe der Zeit, auch wenn nicht verwalteter Code, der die common Language Runtime hostet, den Thread als Fiber implementiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Der Prozessor, der den aktuellen Thread ausführt, kann Anweisungen nicht so neu anordnen, dass Speicherzugriffe vor dem Aufruf von <see cref="M:System.Threading.Thread.MemoryBarrier" /> nach Speicherzugriffen ausgeführt werden, die nach dem Aufruf von <see cref="M:System.Threading.Thread.MemoryBarrier" /> erfolgen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> ist nur auf Systemen mit mehreren Prozessoren mit schwachen Sortierung (z. B. ein System mehrere Intel Itanium-Prozessoren) Arbeitsspeicher erforderlich.  
  
 Den meisten Fällen ist die C#- `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung oder der <xref:System.Threading.Monitor> Klasse bereitstellen, einfachere Möglichkeiten, um Daten zu synchronisieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Threads ab oder legt diesen fest.</summary>
        <value>Eine Zeichenfolge mit dem Namen des Threads, oder <see langword="null" />, wenn kein Name festgelegt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist die Write-nachdem. Da der Standardwert eines Threads <xref:System.Threading.Thread.Name%2A> Eigenschaft `null`, können Sie bestimmen, ob ein Name bereits explizit an den Thread zugewiesen wurde durch einen Vergleich mit `null`.  
  
 Die zugewiesene Zeichenfolge die <xref:System.Threading.Thread.Name%2A> Eigenschaft kann ein Unicode-Zeichen enthalten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen Thread zu benennen.  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ein SET-Vorgang wurde angefordert, aber die <see langword="Name" />-Eigenschaft wurde bereits festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Planungspriorität eines Threads angibt, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Threading.ThreadPriority" />-Werte. Der Standardwert ist <see cref="F:System.Threading.ThreadPriority.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread kann eines der folgenden Priorität zugewiesen werden <xref:System.Threading.ThreadPriority> Werte:  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 Betriebssysteme sind nicht erforderlich, die Priorität eines Threads zu berücksichtigen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Ergebnis einer Änderung der Priorität eines Threads. Drei Threads erstellt wurden, die Priorität eines Threads wird festgelegt, um <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, und die Priorität einer Sekunde auf <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>. Jeder Thread erhöht eine Variable in einem `while` Schleife und führt für einen bestimmten Zeitraum.  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread hat einen Endzustand erreicht, z. B. <see cref="F:System.Threading.ThreadState.Aborted" />.</exception>
        <exception cref="T:System.ArgumentException">Der für eine Set-Operation angegebene Wert ist kein gültiger <see cref="T:System.Threading.ThreadPriority" />-Wert.</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht ein <see cref="M:System.Threading.Thread.Abort(System.Object)" /> ab, das für den aktuellen Thread angefordert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nur von Code mit den entsprechenden Berechtigungen aufgerufen werden.  
  
 Wenn ein Aufruf ausgelöst wird, um `Abort` um einen Thread zu beenden, löst das System eine <xref:System.Threading.ThreadAbortException>. `ThreadAbortException` ist eine besondere Ausnahme, die vom Anwendungscode abgefangen werden kann, aber am Ende des Catch-Blocks erneut ausgelöst wird, wenn `ResetAbort` aufgerufen wird. `ResetAbort` Bricht die Anforderung abbricht, ab und verhindert, dass die `ThreadAbortException` aus Beenden des Threads.  
  
 Finden Sie unter <xref:System.Threading.ThreadAbortException> ein Beispiel zur Veranschaulichung von Aufrufen der `ResetAbort` Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <see langword="Abort" /> wurde für den aktuellen Thread nicht aufgerufen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Sicherheitsberechtigungen für den aktuellen Thread.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für erweiterte Vorgänge in Threads. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt die Ausführung eines angehaltenen Threads wieder auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Verwenden Sie nicht die <xref:System.Threading.Thread.Suspend%2A> und <xref:System.Threading.Thread.Resume%2A> Methoden zum Synchronisieren der Aktivitäten von Threads. Sie haben keine Möglichkeit festzustellen, welchen Code ein Thread ausgeführt wird, wenn Sie ihn anhalten. Wenn Sie einen Thread anhalten, während es bei der Auswertung von Sicherheitsberechtigungen Sperren aufrechterhält, andere threads in der <xref:System.AppDomain> blockiert werden. Wenn Sie einen Thread anhalten, während der Konstruktor einer Klasse ausgeführt wird, andere threads in der <xref:System.AppDomain> , die versuchen, zu verwenden, der Klasse werden blockiert. Deadlocks können sehr leicht auftreten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde nicht gestartet, ist deaktiviert oder befindet sich nicht im angehaltenen Zustand.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für erweiterte Vorgänge in Threads. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">Der neue Apartmentzustand.</param>
        <summary>Legt den Apartmentzustand eines Threads fest, bevor dieser gestartet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Neue Threads werden als initialisiert <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> Wenn ihr Apartmentzustand nicht festgelegt wurde, bevor sie gestartet werden. Apartmentzustand muss festgelegt werden, bevor ein Thread gestartet wird.  
  
> [!NOTE]
>  Thread der hauptanwendung wird initialisiert, um <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> standardmäßig. Die einzige Möglichkeit, legen Sie den Apartmentzustand der Hauptanwendungsthread, dass <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> ist die Anwendung die <xref:System.STAThreadAttribute> -Attribut auf die Einstiegspunktmethode.  
  
 Die <xref:System.Threading.Thread.SetApartmentState%2A> -Methode zusammen mit den <xref:System.Threading.Thread.GetApartmentState%2A> Methode und die <xref:System.Threading.Thread.TrySetApartmentState%2A> Methode ersetzt die <xref:System.Threading.Thread.ApartmentState%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, und <xref:System.Threading.Thread.TrySetApartmentState%2A> Methoden. Das Codebeispiel erstellt einen Thread. Vor dem Starten des Threads <xref:System.Threading.Thread.GetApartmentState%2A> zeigt den ersten <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> Zustand und <xref:System.Threading.Thread.SetApartmentState%2A> ändert den Zustand in <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Die <xref:System.Threading.Thread.TrySetApartmentState%2A> dann Methodenrückgabe `false` beim Versuch, den Status zu ändern, <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> da bereits der Apartmentzustand festgelegt wurde. Bei der Ausführung des gleichen Vorgangs mit <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> würde ausgelöst wurden.  
  
 Nachdem der Thread gestartet wurde, die <xref:System.Threading.Thread.TrySetApartmentState%2A> Methode erneut verwendet wird. Sie löst dieses Mal <xref:System.Threading.ThreadStateException> , da der Thread wurde bereits gestartet wurde.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird auf den Plattformen macOS und Linux nicht unterstützt.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> ist kein gültiger Apartmentzustand.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde bereits gestartet.</exception>
        <exception cref="T:System.InvalidOperationException">Der Apartmentzustand wurde bereits initialisiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">Das <see cref="T:System.Threading.CompressedStack" />-Objekt, das für den aktuellen Thread übernommen werden soll.</param>
        <summary>Übernimmt einen erfassten <see cref="T:System.Threading.CompressedStack" /> für den aktuellen Thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird nicht mehr unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In allen Fällen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">Der <see cref="T:System.LocalDataStoreSlot" />, in dem der Wert festgelegt werden soll.</param>
        <param name="data">Der festzulegende Wert.</param>
        <summary>Legt die Daten im angegebenen Slot auf den derzeit ausgeführten Thread und für die aktuelle Domäne des betreffenden Threads fest. Eine höhere Leistung erzielen Sie, wenn Sie stattdessen Felder verwenden, die mit dem <see cref="T:System.ThreadStaticAttribute" />-Attribut markiert sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework bietet zwei Mechanismen für die Verwendung von lokalen Threadspeicher (TLS): threadbezogene statische Felder (d. h. die Felder, die mit markiert sind die <xref:System.ThreadStaticAttribute> Attribut) und Datenslots. Threadbezogene statische Felder bieten viel bessere Leistung als Datenslots, und aktivieren die typüberprüfung zur Kompilierzeit. Weitere Informationen zur Verwendung von TLS finden Sie unter [Thread-lokalen Speicher: threadbezogene statische Felder und Datenslots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads verwenden einen lokaler Speichermechanismus, um die Thread-spezifische Daten zu speichern. Die common Language Runtime ordnet ein Array mit mehreren Slot Data Store jeder Prozess, bei der Erstellung. Der Thread kann einen Datenslot im Datenspeicher reservieren, speichern und Abrufen eines Wert im Slot und den Slot für die Wiederverwendung freigeben, nachdem die Threadprozedur beendet und die <xref:System.Threading.Thread> Objekt wurde durch die Garbagecollection freigegeben wurde. Datenslots sind pro Thread eindeutig. Kein anderer Thread (nicht einmal ein untergeordneter-Thread), kann diese Daten abzurufen.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> ist eine `Shared` -Methode, die immer auf den derzeit ausgeführten Thread angewendet wird, auch wenn Sie mit einer Variablen, die auf einem anderen Thread aufgerufen. Um Verwirrung zu vermeiden, verwenden Sie den Namen der Klasse beim Aufrufen von `Shared` Methoden: `Thread.SetData(testSlot, "test data")`.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel zeigt, wie Sie ein Feld verwenden, die mit der <xref:System.ThreadStaticAttribute> Attribut zum Speichern von Thread-spezifische Informationen. Das zweite Beispiel zeigt, wie Sie einen Datenslot, um das gleiche tun.  
  
 **Erste Beispiel**  
  
 Das folgende Beispiel zeigt, wie Sie ein Feld verwenden, die mit markierten <xref:System.ThreadStaticAttribute> zum Speichern von Thread-spezifische Informationen. Diese Technik bietet eine bessere Leistung als die Technik, die im zweiten Beispiel angezeigt wird.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Zweite Beispiel**  
  
 Im folgende Beispiel wird veranschaulicht, wie Sie einen benannten Datenslot, um die Thread-spezifische Informationen zu speichern.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hält den aktuellen Thread während des angegebenen Zeitraums an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Anzahl von Millisekunden, die der Thread angehalten wird. Wenn der Wert des <c>millisecondsTimeout</c>-Arguments 0 (null) lautet, gibt der Thread den Rest seines Zeitanteils an einen beliebigen Thread mit gleicher Priorität ab, der für die Ausführung bereit ist. Sind keine anderen Threads mit gleicher Priorität vorhanden, die ausgeführt werden können, wird die Ausführung des aktuellen Threads nicht angehalten.</param>
        <summary>Hält den aktuellen Thread für die angegebene Anzahl von Millisekunden an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread wird nicht vom Betriebssystem für die angegebene Zeitdauer für die Ausführung geplant werden. Diese Methode ändert den Zustand des Threads, sodass <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Sie können angeben, <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für die `millisecondsTimeout` Parameter, um das Anhalten des Threads auf unbestimmte Zeit. Allerdings wird empfohlen, dass Sie andere verwenden <xref:System.Threading?displayProperty=nameWithType> Klassen wie z. B. <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, oder <xref:System.Threading.Semaphore> stattdessen zusammenarbeitsszenarien konzipiert sind Threads oder Ressourcen verwalten.  
  
 Die System-Zeiteinheiten in einer bestimmten Rate wird aufgerufen, die Auflösung der Uhr. Die tatsächliche timeoutsekunden möglicherweise nicht genau dem angegebenen Timeout, da das angegebene Timeout mit Teilstrichen berichtsausführung die Verarbeitung angepasst wird. Weitere Informationen zur Auflösung der Uhr und die Wartezeit, finden Sie unter den [Standbymodus Funktion](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) Thema. Diese Methode ruft die [Standbymodus Funktion](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) aus dem Windows-System-APIs.  
  
 Diese Methode führt keine standardmäßigen COM- und SendMessage-Pumping fortgesetzt.  
  
> [!NOTE]
>  Bei Bedarf in einem Thread, die in den Standbymodus <xref:System.STAThreadAttribute>, aber Sie möchten Ausführen von standardmäßigen COM- und SendMessage-Pumping fortgesetzt, sollten eine der Überladungen der der <xref:System.Threading.Thread.Join%2A> Methode, die ein Timeoutintervall angibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Thread.Sleep%2A> Methode, um den Hauptthread der Anwendung zu blockieren.  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Timeoutwert ist negativ und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Der Zeitraum, während dessen der Thread angehalten wird. Wenn der Wert des <c>millisecondsTimeout</c>-Arguments <see cref="F:System.TimeSpan.Zero" /> lautet, gibt der Thread den Rest seines Zeitanteils an einen beliebigen Thread mit gleicher Priorität ab, der für die Ausführung bereit ist. Sind keine anderen Threads mit gleicher Priorität vorhanden, die ausgeführt werden können, wird die Ausführung des aktuellen Threads nicht angehalten.</param>
        <summary>Hält den aktuellen Thread während des angegebenen Zeitraums an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread wird nicht vom Betriebssystem für die angegebene Zeitdauer für die Ausführung geplant werden. Diese Methode ändert den Zustand des Threads, sodass <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Sie können angeben, <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> für die `timeout` Parameter, um das Anhalten des Threads auf unbestimmte Zeit. Allerdings wird empfohlen, dass Sie andere verwenden <xref:System.Threading?displayProperty=nameWithType> Klassen wie z. B. <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, oder <xref:System.Threading.Semaphore> stattdessen zusammenarbeitsszenarien konzipiert sind Threads oder Ressourcen verwalten.  
  
 Diese Überladung der <xref:System.Threading.Thread.Sleep%2A> verwendet die Gesamtanzahl von ganzen Millisekunden in `timeout`. Bruchteile von Millisekunden werden verworfen.  
  
 Diese Methode führt keine standardmäßigen COM- und SendMessage-Pumping fortgesetzt.  
  
> [!NOTE]
>  Bei Bedarf in einem Thread, die in den Standbymodus <xref:System.STAThreadAttribute>, aber Sie möchten Ausführen von standardmäßigen COM- und SendMessage-Pumping fortgesetzt, sollten eine der Überladungen der der <xref:System.Threading.Thread.Join%2A> Methode, die ein Timeoutintervall angibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> -methodenüberladung, um den Hauptthread der Anwendung zwei Sekunden jedes Mal fünf Mal blockieren.  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="timeout" /> ist negativ und nicht gleich <see cref="F:System.Threading.Timeout.Infinite" /> in Millisekunden oder größer als <see cref="F:System.Int32.MaxValue" /> Millisekunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">Eine 32-Bit-Ganzzahl mit Vorzeichen, die den Zeitraum definiert, den ein Thread warten soll.</param>
        <summary>Veranlasst, dass ein Thread so oft wartet, wie vom <paramref name="iterations" />-Parameter definiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Thread.SpinWait%2A> Methode eignet sich für die Implementierung von Sperren. Klassen in .NET Framework, z. B. <xref:System.Threading.Monitor> und <xref:System.Threading.ReaderWriterLock>, verwenden Sie diese Methode intern. <xref:System.Threading.Thread.SpinWait%2A> setzt im Wesentlichen den Prozessor in einer sehr kurzen Schleife mit der Zahl der Schleifen, die gemäß der `iterations` Parameter. Die Dauer des Wartevorgangs hängt daher von der Geschwindigkeit des Prozessors.  
  
 Vergleichen Sie dies mit der <xref:System.Threading.Thread.Sleep%2A> Methode. Ein Thread, der Aufrufe <xref:System.Threading.Thread.Sleep%2A> führt zu den Rest der seiner aktuellen Segment der Prozessorzeit, selbst wenn das angegebene Intervall auf 0 (null) ist. Angeben eines Intervalls ungleich NULL für <xref:System.Threading.Thread.Sleep%2A> unberücksichtigt bleiben sollen, durch den Threadplaner den Thread entfernt, bis das Zeitintervall verstrichen ist.  
  
 <xref:System.Threading.Thread.SpinWait%2A> ist nicht für normale Anwendungen in der Regel sinnvoll. In den meisten Fällen sollten Sie die von .NET Framework bereitgestellten Synchronisierungsklassen verwenden; Rufen Sie z. B. <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> oder eine Anweisung, die umschließt <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in c# oder `SyncLock` in Visual Basic).  
  
> [!CAUTION]
>  Stellen Sie in dem seltenen Fall, in denen es empfiehlt sich zum Vermeiden von eines Kontextwechsel, z. B., wenn Sie wissen, dass eine statusänderung bevorsteht, einen Aufruf der <xref:System.Threading.Thread.SpinWait%2A> -Methode in der Schleife. Der Code <xref:System.Threading.Thread.SpinWait%2A> führt wurde entwickelt, um Probleme zu vermeiden, die auf Computern mit mehreren Prozessoren auftreten können. Auf Computern mit mehreren Intel-Prozessoren mit Hyper-Threading-Technologie beispielsweise <xref:System.Threading.Thread.SpinWait%2A> Prozessor verhungern in bestimmten Situationen verhindert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bewirkt, dass die Ausführung eines Threads geplant wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Weist das Betriebssystem an, den Zustand der aktuellen Instanz in <see cref="F:System.Threading.ThreadState.Running" /> zu ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sobald ein Thread die <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> aufweist, das Betriebssystem für die Ausführung planen. Der Thread beginnt in der ersten Zeile der Methode, dargestellt durch die <xref:System.Threading.ThreadStart> oder <xref:System.Threading.ParameterizedThreadStart> -Delegaten an den Threadkonstruktor. Beachten Sie, dass der Aufruf von <xref:System.Threading.Thread.Start%2A> den aufrufenden Thread nicht blockiert.  
  
> [!NOTE]
>  Wenn diese Überladung, mit einem Thread erstellt verwendet wird, mit einer <xref:System.Threading.ParameterizedThreadStart> zu delegieren, `null` übergeben wird, an die Methode, die vom Thread ausgeführt.  
  
 Sobald der Thread beendet wird, es kann nicht neu gestartet werden mit einem weiteren Aufruf von `Start`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt und startet einen Thread.  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde bereits gestartet.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Speicher zum Starten dieses Threads verfügbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Ein Objekt mit Daten, die von der vom Thread ausgeführten Methode verwendet werden sollen.</param>
        <summary>Bewirkt, dass das Betriebssystem den Zustand der aktuellen Instanz in <see cref="F:System.Threading.ThreadState.Running" /> ändert, und stellt optional ein Objekt mit Daten bereit, die von der vom Thread ausgeführten Methode verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sobald ein Thread die <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> aufweist, das Betriebssystem für die Ausführung planen. Der Thread beginnt in der ersten Zeile der Methode, dargestellt durch die <xref:System.Threading.ThreadStart> oder <xref:System.Threading.ParameterizedThreadStart> -Delegaten an den Threadkonstruktor. Beachten Sie, dass der Aufruf von <xref:System.Threading.Thread.Start%2A> den aufrufenden Thread nicht blockiert.  
  
 Sobald der Thread beendet wird, es kann nicht neu gestartet werden mit einem weiteren Aufruf von `Start`.  
  
 Diese Überladung und <xref:System.Threading.ParameterizedThreadStart> Delegaten erleichtern Ihnen die Daten an eine Threadprozedur zu übergeben, aber das Verfahren ist nicht typsicher, da jedes beliebige Objekt an diese Überladung übergeben werden kann. Eine stabilere Möglichkeit, Daten an eine Threadprozedur übergeben werden sowohl die Threadprozedur und die Datenfelder in einer Worker-Objekt eingefügt. Weitere Informationen finden Sie unter [Erstellen von Threads und übergeben von Daten zur Startzeit](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Threading.ParameterizedThreadStart> Delegat mit einer statischen Methode und eine Instanzmethode handeln.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde bereits gestartet.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Speicher zum Starten dieses Threads verfügbar.</exception>
        <exception cref="T:System.InvalidOperationException">Dieser Thread wurde mithilfe eines <see cref="T:System.Threading.ThreadStart" />-Delegaten anstelle eines <see cref="T:System.Threading.ParameterizedThreadStart" />-Delegaten erstellt.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hält den Thread an. Hat keine Auswirkungen, wenn der Thread bereits angehalten ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Thread bereits angehalten ist, hat diese Methode keine Auswirkungen.  
  
> [!CAUTION]
>  Verwenden Sie nicht die <xref:System.Threading.Thread.Suspend%2A> und <xref:System.Threading.Thread.Resume%2A> Methoden zum Synchronisieren der Aktivitäten von Threads. Sie haben keine Möglichkeit festzustellen, welchen Code ein Thread ausgeführt wird, wenn Sie ihn anhalten. Wenn Sie einen Thread anhalten, während es bei der Auswertung von Sicherheitsberechtigungen Sperren aufrechterhält, andere threads in der <xref:System.AppDomain> blockiert werden. Wenn Sie einen Thread anhalten, während der Konstruktor einer Klasse ausgeführt wird, andere threads in der <xref:System.AppDomain> , die versuchen, zu verwenden, der Klasse werden blockiert. Deadlocks können sehr leicht auftreten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde nicht gestartet oder reagiert nicht.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche <see cref="T:System.Security.Permissions.SecurityPermission" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für erweiterte Vorgänge in Threads. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="rgszNames">Das übergebene Array von zuzuordnenden Namen.</param>
        <param name="cNames">Die Anzahl der zuzuordnenden Namen.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</param>
        <param name="rgDispId">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</param>
        <summary>Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetIDsOfNames`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Die zurückzugebenden Typinformationen.</param>
        <param name="lcid">Der Gebietsschemabezeichner für die Typinformationen.</param>
        <param name="ppTInfo">Empfängt einen Zeiger auf das angeforderte Objekt mit den Typinformationen.</param>
        <summary>Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfo`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</param>
        <summary>Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfoCount`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Bezeichnet den Member.</param>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</param>
        <param name="wFlags">Flags, die den Kontext des Aufrufs beschreiben.</param>
        <param name="pDispParams">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</param>
        <param name="pVarResult">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</param>
        <param name="pExcepInfo">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</param>
        <param name="puArgErr">Der Index des ersten Arguments mit einem Fehler.</param>
        <summary>Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::Invoke`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zustände des aktuellen Threads enthält.</summary>
        <value>Einer der <see cref="T:System.Threading.ThreadState" />-Werte, der den Zustand des aktuellen Threads angibt. Der Anfangswert ist <see langword="Unstarted" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Thread.ThreadState%2A> Eigenschaft enthält spezifischere Informationen als die <xref:System.Threading.Thread.IsAlive%2A> Eigenschaft.  
  
> [!IMPORTANT]
>  Threadzustand ist nur in Debugszenarien von Interesse. Sie sollten den Threadzustand niemals verwenden, um die Aktivitäten von Threads zu synchronisieren.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht den Zugriff auf die `ThreadState` eines Threads.  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">Der neue Apartmentzustand.</param>
        <summary>Legt den Apartmentzustand eines Threads fest, bevor dieser gestartet wird.</summary>
        <returns>
          <see langword="true" />, wenn der Apartmentzustand festgelegt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Neue Threads werden als initialisiert <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> Wenn ihr Apartmentzustand nicht festgelegt wurde, bevor sie gestartet werden. Apartmentzustand muss festgelegt werden, bevor ein Thread gestartet wird.  
  
> [!NOTE]
>  Thread der hauptanwendung wird initialisiert, um <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> standardmäßig. Die einzige Möglichkeit, legen Sie den Apartmentzustand der Hauptanwendungsthread, dass <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> ist die Anwendung die <xref:System.STAThreadAttribute> -Attribut auf die Einstiegspunktmethode.  
  
 Die <xref:System.Threading.Thread.TrySetApartmentState%2A> -Methode zusammen mit den <xref:System.Threading.Thread.GetApartmentState%2A> Methode und die <xref:System.Threading.Thread.SetApartmentState%2A> Methode ersetzt die <xref:System.Threading.Thread.ApartmentState%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, und <xref:System.Threading.Thread.TrySetApartmentState%2A> Methoden. Das Codebeispiel erstellt einen Thread. Vor dem Starten des Threads <xref:System.Threading.Thread.GetApartmentState%2A> zeigt den ersten <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> Zustand und <xref:System.Threading.Thread.SetApartmentState%2A> ändert den Zustand in <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Die <xref:System.Threading.Thread.TrySetApartmentState%2A> dann Methodenrückgabe `false` beim Versuch, den Status zu ändern, <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> da bereits der Apartmentzustand festgelegt wurde. Bei der Ausführung des gleichen Vorgangs mit <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> würde ausgelöst wurden.  
  
 Nachdem der Thread gestartet wurde, die <xref:System.Threading.Thread.TrySetApartmentState%2A> Methode erneut verwendet wird. Sie löst dieses Mal <xref:System.Threading.ThreadStateException> , da der Thread wurde bereits gestartet wurde.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> ist kein gültiger Apartmentzustand.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Der Thread wurde bereits gestartet.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Das zu lesende Feld.</param>
        <summary>Liest den Wert eines Felds. Der Wert entspricht dem letzten von einem Prozessor in dem Computer geschriebenen Wert, unabhängig von der Anzahl der Prozessoren und dem Zustand des Prozessorcaches.</summary>
        <returns>Der letzte von einem Prozessor in das Feld geschriebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> Ruft den neuesten Wert, der auf einen Speicherbereich geschrieben werden, von einem Prozessor ab. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">Das Feld, in das der Wert geschrieben werden soll.</param>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Wert sofort in ein Feld, sodass der Wert für alle Prozessoren des Computers sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> der Synchronisierung in bestimmten Fällen sind. Unter normalen Umständen c# `lock` -Anweisung, die Visual Basic `SyncLock` -Anweisung, und die <xref:System.Threading.Monitor> Klasse geben Sie einfachere alternativen.  
  
 Auf einem Multiprozessorsystem <xref:System.Threading.Thread.VolatileWrite%2A> wird sichergestellt, dass ein Wert, der auf einen Speicherbereich geschrieben sofort für alle Prozessoren sichtbar ist. Dies erfordert möglicherweise, Prozessor-Caches leeren.  
  
 Sogar auf einem Einprozessorsystem <xref:System.Threading.Thread.VolatileRead%2A> und <xref:System.Threading.Thread.VolatileWrite%2A> stellen Sie sicher, dass ein Wert gelesen oder in den Speicher geschrieben werden, und (z. B. in einem Prozessorregister) nicht zwischengespeichert. Daher können Sie sie verwenden, um den Zugriff auf ein Feld zu synchronisieren, die von einem anderen Thread oder von der Hardware aktualisiert werden können.  
  
 Das Aufrufen dieser Methode wirkt sich auf nur einen einzigen Speicherzugriff aus. Um effektive Synchronisierung für ein Feld bereitzustellen, muss alle Zugriffe auf das Feld verwenden <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c# mithilfe der `volatile` Modifizierer für ein Feld wird sichergestellt, dass alle Zugriffe auf das Feld verwendet <xref:System.Threading.Thread.VolatileRead%2A> oder <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass der aufrufende Thread die Ausführung an einen anderen Thread übergibt, der auf dem aktuellen Prozessor ausgeführt werden kann. Das Betriebssystem wählt den Thread für die Übergabe aus.</summary>
        <returns>
          <see langword="true" />, wenn das Betriebssystem die Ausführung an einen anderen Thread übergeben hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode erfolgreich ist, wird die restliche Zeitsegment des Threads aktuelle ergab. Das Betriebssystem plant den aufrufenden Thread für einen anderen Zeitraum verwendet haben, gemäß seiner Priorität und den Status von anderen Threads, die ausgeführt werden.  
  
 Rückgabe ist beschränkt, an den Prozessor, der den aufrufenden Thread ausgeführt wird. Das Betriebssystem wird nicht auf einen anderen Prozessor Ausführung wechseln, selbst wenn der Prozessor im Leerlauf befindet oder einen Thread mit niedrigerer Priorität ausgeführt wird. Wenn keine anderen Threads, die auf dem aktuellen Prozessor ausgeführt werden, das Betriebssystem keine Ausführung Beenden dieser Methode `false`.  
  
 Diese Methode entspricht, mithilfe eines Plattformaufrufs zum Aufrufen von systemeigenen Win32 `SwitchToThread` Funktion. Rufen Sie die <xref:System.Threading.Thread.Yield%2A> Methode anstelle von Plattform aufrufen, da ein Plattformaufruf umgeht alle benutzerdefiniertes threading Verhalten des Hosts angefordert hat.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>