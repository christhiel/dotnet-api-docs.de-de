<Type Name="ReservationCollection" FullName="System.IO.Log.ReservationCollection">
  <TypeSignature Language="C#" Value="public abstract class ReservationCollection : System.Collections.Generic.ICollection&lt;long&gt;, System.Collections.Generic.IEnumerable&lt;long&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ReservationCollection extends System.Object implements class System.Collections.Generic.ICollection`1&lt;int64&gt;, class System.Collections.Generic.IEnumerable`1&lt;int64&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.ReservationCollection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ReservationCollection&#xA;Implements ICollection(Of Long), IEnumerable(Of Long)" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReservationCollection abstract : System::Collections::Generic::ICollection&lt;long&gt;, System::Collections::Generic::IEnumerable&lt;long&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Int64&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="3c99a-101">Verwaltet die Auflistung von Speicherplatzreservierungen, die in einer Datensatzsequenz vorgenommen wurden.</span><span class="sxs-lookup"><span data-stu-id="3c99a-101">Manages the collection of space reservations made in a record sequence.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c99a-102">Diese Klasse stellt einen Satz Reservierungsbereiche dar, die in einer Datensatzsequenz erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="3c99a-102">This class represents a set of reservation areas that are made in a record sequence.</span></span> <span data-ttu-id="3c99a-103">Durch das Hinzufügen von Elementen zur Auflistung werden neue Reservierungen zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="3c99a-103">Adding items to the collection allocates new reservations.</span></span> <span data-ttu-id="3c99a-104">Werden Elemente aus der Auflistung entfernt, werden diese Reservierungen freigegeben.</span><span class="sxs-lookup"><span data-stu-id="3c99a-104">Removing items from the collection frees those reservations.</span></span>  
  
 <span data-ttu-id="3c99a-105">Eine Anwendung reserviert Speicherplatz im Protokoll, wenn sie über Daten verfügt, die in Zukunft in das Protokoll geschrieben werden sollen, aber nicht unmittelbar geschrieben werden können.</span><span class="sxs-lookup"><span data-stu-id="3c99a-105">An application reserves space in the log when it has data that is to be written to the log in the future, but cannot write it immediately.</span></span> <span data-ttu-id="3c99a-106">Reservierungen gewährleisten, dass die Daten in das Protokoll geschrieben werden können, wenn sie für den Schreibvorgang verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="3c99a-106">Reservations provide a guarantee that the data can be written to the log when the data is available to be written.</span></span> <span data-ttu-id="3c99a-107">Wenn sie Protokolle verwenden, reservieren Anwendungen oft einen oder mehrere Protokolldatensätze in einem Marshallingbereich.</span><span class="sxs-lookup"><span data-stu-id="3c99a-107">When using logs, applications often reserve one or more log records in a marshalling area.</span></span> <span data-ttu-id="3c99a-108">Sie müssen Datensätze vor dem Anfügen reservieren.</span><span class="sxs-lookup"><span data-stu-id="3c99a-108">You must reserve records prior to appending them.</span></span>  
  
 <span data-ttu-id="3c99a-109">Mit Reservierungen kann gewährleistet werden, dass ein Vorgang abgeschlossen werden kann, bevor die Daten übertragen werden. Andernfalls werden die Änderungen zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="3c99a-109">Reservations can be used to guarantee that an operation can be completed before the data is committed; otherwise, the changes are rolled back.</span></span> <span data-ttu-id="3c99a-110">Außerdem können Reservierungen verwendet werden, um eine "Rückgängigaktion" im Protokoll aufzuzeichnen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-110">It can also be used to record an "undo action" in the log.</span></span> <span data-ttu-id="3c99a-111">Während eines Rollbackvorgangs muss ein Ressourcen-Manager (RM) für Transaktionen in der Lage sein, seinen Status wiederherzustellen, wenn der RM während des Rollbackvorgangs unterbrochen wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-111">During a rollback operation, a transactional resource manager (RM) must be able to recover its state if the RM is interrupted during the rollback operation.</span></span> <span data-ttu-id="3c99a-112">Durch die Verwendung eines Reservierungsbereichs kann ein RM Speicherplatz in einem Protokoll reservieren, bevor es verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-112">By using a reservation area, an RM can reserve space in a log before it is used.</span></span>  
  
 <span data-ttu-id="3c99a-113">Die <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>-Methode kann je nach den Parametern, die beim Aufruf angegeben werden, Speicherplatz reservieren und/oder Daten anfügen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-113">The <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> method can either reserve space or append data, or both, depending on the parameters that are specified when making the call.</span></span> <span data-ttu-id="3c99a-114">Im Lauf der Transaktion kann eine Anwendung die Rückgängiginformationen anfügen und Speicherplatz für Kompensierungsdatensätze reservieren.</span><span class="sxs-lookup"><span data-stu-id="3c99a-114">As work progresses in a transaction, an application can append the undo information and reserve space for compensation records.</span></span> <span data-ttu-id="3c99a-115">Während eines Rollbackvorgangs geben Kompensierungsdatensätze, die erstellt werden, an, welche Aktionen auf dem Datenträger rückgängig gemacht wurden.</span><span class="sxs-lookup"><span data-stu-id="3c99a-115">During a rollback operation, compensation records that are created indicate what has been undone on the disk.</span></span> <span data-ttu-id="3c99a-116">Die Datensätze werden mit zuvor reserviertem Speicherplatz angefügt.</span><span class="sxs-lookup"><span data-stu-id="3c99a-116">The records are appended using space that has been previously reserved.</span></span> <span data-ttu-id="3c99a-117">Dadurch ist gewährleistet, dass einem RM während eines Rollbackvorgangs nicht genügend Protokollspeicherplatz zur Verfügung steht, was ein schwerwiegender Fehler ist.</span><span class="sxs-lookup"><span data-stu-id="3c99a-117">This guarantees that an RM does not run out of log space, which is a fatal condition, while performing a rollback operation.</span></span> <span data-ttu-id="3c99a-118">Wenn ein Protokoll während einer Transaktion aufgefüllt wird, kann eine Anwendung eine Transaktion sicher zurücksetzen, ohne dauerhafte Daten zu beschädigen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-118">If a log fills up during a transaction, an application can safely roll back a transaction without corrupting durable data.</span></span>  
  
 <span data-ttu-id="3c99a-119">CLFS ist ein ARIES-kompatibles Protokollierungssystem, das für das Write-Ahead-Logging eingesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-119">CLFS is an ARIES-compliant logging system, meant for write-ahead logging.</span></span> <span data-ttu-id="3c99a-120">Beim Write-Ahead-Logging schreibt eine Anwendung einen Rückgängigdatensatz, bevor sie den Vorgang ausführt und reserviert den Speicherplatz, der im Protokoll zum Schreiben eines Kompensierungsdatensatzes erforderlich ist, der unter Umständen während des Rollbackvorgangs verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-120">In write-ahead logging, an application writes an undo record before it performs the operation, reserving the amount of space it takes in the log to write a compensating record, which may be used during rollback.</span></span> <span data-ttu-id="3c99a-121">Später wird der reservierte Speicherplatz verwendet, wenn der Kompensierungsdatensatz tatsächlich geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-121">Later, the reserved space is used when the compensation record is actually written.</span></span>  
  
 <span data-ttu-id="3c99a-122">Anwendungen können Protokollspeicherplatz zu einem beliebigen Zeitpunkt reservieren oder darauf zugreifen (diese Vorgänge schließen sich gegenseitig aus).</span><span class="sxs-lookup"><span data-stu-id="3c99a-122">Applications can either reserve or access long space at any given time (they are mutually exclusive operations).</span></span> <span data-ttu-id="3c99a-123">Wenn ein Commit-Datensatz in das Protokoll geschrieben wurde, kann eine Anwendung Reservierungen für die Kompensierungsdatensätze freigeben.</span><span class="sxs-lookup"><span data-stu-id="3c99a-123">After a commit record is written to the log, an application can free up the reservations for the compensation records.</span></span> <span data-ttu-id="3c99a-124">Diese Aktion kann ausgeführt werden, indem die <xref:System.IO.Log.ReservationCollection.FreeReservation%2A>-Methode oder die <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-124">This action can be done by calling either the <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> or <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> method.</span></span> <span data-ttu-id="3c99a-125">Das Aufrufen der <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>-Methode gewährleistet, dass der Vorgang unteilbar ist, während ein Aufruf der <xref:System.IO.Log.ReservationCollection.FreeReservation%2A>-Methode dies nicht gewährleistet.</span><span class="sxs-lookup"><span data-stu-id="3c99a-125">Calling the <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> method guarantees that the operation is atomic, while calling the <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> method does not.</span></span>  
  
 <span data-ttu-id="3c99a-126">Wenn Sie Datensätze freigeben, müssen Sie dieselben Datensätze freigeben, die Sie in einem vorherigen Aufruf der <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>-Methode zusammen reserviert haben.</span><span class="sxs-lookup"><span data-stu-id="3c99a-126">When you free records, you must free the same records that you reserved together in a previous call to the <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3c99a-127">Ihre Implementierung von <xref:System.IO.Log.IRecordSequence> muss die <xref:System.IO.Log.ReservationCollection.MakeReservation%2A>-Methode und die <xref:System.IO.Log.ReservationCollection.FreeReservation%2A>-Methode implementieren, um die eigentliche Reservierung und Freigabe vorzunehmen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-127">Your implementation of <xref:System.IO.Log.IRecordSequence> must implement the <xref:System.IO.Log.ReservationCollection.MakeReservation%2A> and <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> methods to perform the actual reservation allocation and deallocation.</span></span> <span data-ttu-id="3c99a-128">Darüber hinaus muss die Implementierung auch <xref:System.IO.Log.ReservationCollection.ReservationFreed%2A> aufrufen, wenn ein Datensatz in reservierten Speicherplatz geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-128">In addition, your implementation must also call <xref:System.IO.Log.ReservationCollection.ReservationFreed%2A> when a record is written into a reserved space.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3c99a-129">Reservierungen können auf zwei Arten vorgenommen werden, wie in den nachstehenden Beispielen beschrieben.</span><span class="sxs-lookup"><span data-stu-id="3c99a-129">Reservations can be performed in two ways as shown in the following examples.</span></span> <span data-ttu-id="3c99a-130">Sie können die Vorgehensweise aus den Beispielen für stabile Verarbeitung übernehmen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-130">You can adopt the practices in the samples for robust processing.</span></span> <span data-ttu-id="3c99a-131">Beachten Sie, dass diese Aufgabe nur bei Verwendung der CLFS-basierten <xref:System.IO.Log.LogRecordSequence>-Klasse ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3c99a-131">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ReservationCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3c99a-132">Initialisiert eine neue Instanz der <see cref="T:System.IO.Log.ReservationCollection" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="3c99a-132">Initializes a new instance of the <see cref="T:System.IO.Log.ReservationCollection" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Add(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(long size);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size"><span data-ttu-id="3c99a-133">Die Größe der angeforderten Reservierung in Byte.</span><span class="sxs-lookup"><span data-stu-id="3c99a-133">The size of the requested reservation, in bytes.</span></span></param>
        <summary><span data-ttu-id="3c99a-134">Ordnet eine Reservierung zu und fügt sie der Auflistung hinzu.</span><span class="sxs-lookup"><span data-stu-id="3c99a-134">Allocates a reservation and adds it to the collection.</span></span> <span data-ttu-id="3c99a-135">Diese Methode kann nicht vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="3c99a-135">This method cannot be inherited.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3c99a-136">Das folgende Beispiel stellt dar, wie Sie manuell eine Reservierung vornehmen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-136">The following example shows how to manually make a reservation.</span></span> <span data-ttu-id="3c99a-137">Beachten Sie, dass diese Aufgabe nur bei Verwendung der CLFS-basierten <xref:System.IO.Log.LogRecordSequence>-Klasse ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3c99a-137">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3c99a-138"><paramref name="archiveTail" /> befindet sich nicht zwischen der Basissequenznummer und der letzten Sequenznummer dieser Sequenz.</span><span class="sxs-lookup"><span data-stu-id="3c99a-138"><paramref name="archiveTail" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3c99a-139"><paramref name="size" /> ist ungültig oder übersteigt die maximale Reservierungsgröße.</span><span class="sxs-lookup"><span data-stu-id="3c99a-139"><paramref name="size" /> is invalid or exceeds maximum reservation size.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="3c99a-140">Ein E/A-Fehler tritt auf, wenn die Archivmomentaufnahme erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-140">An I/O error occurs when creating the archive snapshot.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3c99a-141">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-141">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3c99a-142">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-142">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="3c99a-143">Der Zugriff auf den angegebenen Protokollspeicher wird vom Betriebssystem verweigert.</span><span class="sxs-lookup"><span data-stu-id="3c99a-143">Access for the specified log store is denied by the operating system.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="3c99a-144">Die Datensatzsequenz ist voll.</span><span class="sxs-lookup"><span data-stu-id="3c99a-144">The record sequence is full.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3c99a-145">Gibt alle Reservierungen in der Auflistung frei.</span><span class="sxs-lookup"><span data-stu-id="3c99a-145">Releases all of the reservations in the collection.</span></span> <span data-ttu-id="3c99a-146">Diese Methode kann nicht vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="3c99a-146">This method cannot be inherited.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3c99a-147"><paramref name="size" /> ist ungültig oder übersteigt die maximale Reservierungsgröße.</span><span class="sxs-lookup"><span data-stu-id="3c99a-147"><paramref name="size" /> is invalid or exceeds maximum reservation size.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="3c99a-148">Ein E/A-Fehler tritt auf, wenn die Archivmomentaufnahme erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-148">An I/O error occurs when creating the archive snapshot.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3c99a-149">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-149">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3c99a-150">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-150">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="3c99a-151">Die Datensatzsequenz ist voll.</span><span class="sxs-lookup"><span data-stu-id="3c99a-151">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="3c99a-152">Der Zugriff auf den angegebenen Protokollspeicher wird vom Betriebssystem verweigert.</span><span class="sxs-lookup"><span data-stu-id="3c99a-152">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Contains(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (size As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(long size);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size"><span data-ttu-id="3c99a-153">Die in der Auflistung zu suchende Größe.</span><span class="sxs-lookup"><span data-stu-id="3c99a-153">The size to locate in the collection.</span></span></param>
        <summary><span data-ttu-id="3c99a-154">Ermittelt, ob eine Reservierung der angegebenen Größe vorgenommen wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-154">Determines whether a reservation of the specified size has been made.</span></span> <span data-ttu-id="3c99a-155">Diese Methode kann nicht vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="3c99a-155">This method cannot be inherited.</span></span></summary>
        <returns>
          <span data-ttu-id="3c99a-156"><see langword="true" />, wenn wenigstens eine Reservierung der angegebenen Größe vorgenommen wurde; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3c99a-156"><see langword="true" /> if at least one reservation of the specified size has been made; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3c99a-157">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-157">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3c99a-158">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-158">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="3c99a-159">Der Zugriff auf den angegebenen Protokollspeicher wird vom Betriebssystem verweigert.</span><span class="sxs-lookup"><span data-stu-id="3c99a-159">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (long[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(int64[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As Long(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;long&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Int64[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3c99a-160">Das Array, das das Ziel des Kopiervorgangs ist.</span><span class="sxs-lookup"><span data-stu-id="3c99a-160">The array that is the destination of the copy.</span></span></param>
        <param name="arrayIndex"><span data-ttu-id="3c99a-161">Der nullbasierte Index im Array, ab dem der Kopiervorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="3c99a-161">The zero-based index in the array at which copying begins.</span></span></param>
        <summary><span data-ttu-id="3c99a-162">Kopiert die gesamte Auflistung in ein kompatibles Array, wobei am angegebenen Index im Zielarray begonnen wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-162">Copies the entire collection to a one-dimensional array, starting at the specified index of the target array.</span></span> <span data-ttu-id="3c99a-163">Diese Methode kann nicht vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="3c99a-163">This method cannot be inherited.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3c99a-164"><paramref name="array" /> oder <paramref name="arrayIndex" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3c99a-164"><paramref name="array" /> or <paramref name="arrayIndex" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3c99a-165"><paramref name="arrayIndex" /> ist kleiner als 0 (null) oder größer oder gleich der Länge von <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3c99a-165"><paramref name="arrayIndex" /> is less than zero, or greater than or equal to the length of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3c99a-166">Das angegebene Array verfügt nicht über genügend Speicherplatz, um die Daten zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="3c99a-166">There is not enough space in the specified array to copy the data.</span></span>  
  
 <span data-ttu-id="3c99a-167">- oder - </span><span class="sxs-lookup"><span data-stu-id="3c99a-167">-or-</span></span>  
  
 <span data-ttu-id="3c99a-168"><paramref name="array" /> ist kein eindimensionales Array, das der einzige für die angeforderte Aktion unterstützte Typ ist.</span><span class="sxs-lookup"><span data-stu-id="3c99a-168"><paramref name="array" /> is not a single dimensional array, which is the only type supported for the requested action.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3c99a-169">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-169">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3c99a-170">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-170">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="3c99a-171">Der Zugriff auf den angegebenen Protokollspeicher wird vom Betriebssystem verweigert.</span><span class="sxs-lookup"><span data-stu-id="3c99a-171">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3c99a-172">Ruft die Anzahl der Reservierungen in der Auflistung ab.</span><span class="sxs-lookup"><span data-stu-id="3c99a-172">Gets the number of reservations in the collection.</span></span></summary>
        <value><span data-ttu-id="3c99a-173">Die Anzahl der Reservierungen in der Auflistung.</span><span class="sxs-lookup"><span data-stu-id="3c99a-173">The number of reservations in the collection.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReservationCollection ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3c99a-174">Ermöglicht <see cref="T:System.IO.Log.ReservationCollection" /> das Freigeben von Ressourcen, bevor die Zerstörung durch den Garbage Collector stattfindet.</span><span class="sxs-lookup"><span data-stu-id="3c99a-174">Allows the <see cref="T:System.IO.Log.ReservationCollection" /> to free resources before it is destroyed by the garbage collector.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeReservation">
      <MemberSignature Language="C#" Value="protected abstract void FreeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FreeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.FreeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FreeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FreeReservation(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size"><span data-ttu-id="3c99a-175">Die Größe der freizugebenden Reservierung.</span><span class="sxs-lookup"><span data-stu-id="3c99a-175">The size of the reservation to release.</span></span></param>
        <summary><span data-ttu-id="3c99a-176">Gibt beim Überschreiben in einer abgeleiteten Klasse eine Reservierung der angegebenen Größe frei.</span><span class="sxs-lookup"><span data-stu-id="3c99a-176">When overridden in a derived class, releases a reservation of the specified size.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="3c99a-177">Wenn Sie aus <see cref="T:System.IO.Log.ReservationCollection" /> übernehmen, müssen Sie diese Methode implementieren, um tatsächlich Speicherplatz in der Datensatzsequenz freizugeben.</span><span class="sxs-lookup"><span data-stu-id="3c99a-177">When you inherit from <see cref="T:System.IO.Log.ReservationCollection" />, you must implement this method to actually release space in the record sequence.</span></span> <span data-ttu-id="3c99a-178">Sie sollten <see cref="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" /> nicht aufrufen, wenn diese Methode vollständig ist; diese Logik wird für Sie verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="3c99a-178">You should not call <see cref="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" /> when this method is complete; that logic is handled for you.</span></span>  
  
 <span data-ttu-id="3c99a-179">Wenn Sie Datensätze freigeben, müssen Sie dieselben Datensätze freigeben, die Sie in einem vorherigen Aufruf der <see cref="Overload:System.IO.Log.IRecordSequence.ReserveAndAppend" />-Methode zusammen reserviert haben.</span><span class="sxs-lookup"><span data-stu-id="3c99a-179">When you free records, you must free the same records that you reserved together in a previous call to the <see cref="Overload:System.IO.Log.IRecordSequence.ReserveAndAppend" /> method.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBestMatchingReservation">
      <MemberSignature Language="C#" Value="protected long GetBestMatchingReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance int64 GetBestMatchingReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetBestMatchingReservation (size As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; long GetBestMatchingReservation(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size"><span data-ttu-id="3c99a-180">Die Größe der Reservierung, die geeignet sein muss.</span><span class="sxs-lookup"><span data-stu-id="3c99a-180">The size of the reservation that must be fit.</span></span></param>
        <summary><span data-ttu-id="3c99a-181">Ruft beim Überschreiben in einer abgeleiteten Klasse die am besten passende Reservierung für eine bestimmte Größe ab.</span><span class="sxs-lookup"><span data-stu-id="3c99a-181">When overridden in a derived class, gets the best matching reservation for a given size.</span></span></summary>
        <returns><span data-ttu-id="3c99a-182">Eine Reservierung aus der Auflistung, die größer oder gleich der angegebenen Größe ist, oder -1, wenn keine derartige Reservierung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="3c99a-182">A reservation from the collection that is greater than or equal to the specified size, or -1 if no such reservation exists.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c99a-183">Diese Methode wird in der Regel aufgerufen, wenn Sie einen Datensatz aus reserviertem Speicherplatz an eine Datensatzsequenz anfügen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-183">This method is typically called when appending a record from reserved space to a record sequence.</span></span> <span data-ttu-id="3c99a-184">Bei der Ausgabe wurde eine Reservierung der zurückgegebenen Größe aus der Auflistung entfernt.</span><span class="sxs-lookup"><span data-stu-id="3c99a-184">When it returns, a reservation of the returned size has been removed from the collection.</span></span> <span data-ttu-id="3c99a-185">Wenn aus einem beliebigen Grund nicht auf den reservierten Speicherplatz zugegriffen wird, sollte die <xref:System.IO.Log.ReservationCollection.ReservationMade%2A>-Methode aufgerufen werden, um zu gewährleisten, dass die <xref:System.IO.Log.ReservationCollection> den reservierten Speicherplatz in der Datensatzsequenz genau darstellt.</span><span class="sxs-lookup"><span data-stu-id="3c99a-185">If, for some reason, the reserved space is not actually accessed, the <xref:System.IO.Log.ReservationCollection.ReservationMade%2A> method should be called to ensure that the <xref:System.IO.Log.ReservationCollection> accurately represents the amount of reserved space in the record sequence.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;long&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;int64&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;long&gt; ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3c99a-186">Gibt einen Enumerator zurück, der die <see cref="T:System.IO.Log.ReservationCollection" /> durchlaufen kann.</span><span class="sxs-lookup"><span data-stu-id="3c99a-186">Returns an enumerator that can iterate through the <see cref="T:System.IO.Log.ReservationCollection" />.</span></span> <span data-ttu-id="3c99a-187">Diese Methode kann nicht vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="3c99a-187">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="3c99a-188">Ein Enumerator, der die <see cref="T:System.IO.Log.ReservationCollection" /> durchlaufen kann.</span><span class="sxs-lookup"><span data-stu-id="3c99a-188">An enumerator that can iterate through the <see cref="T:System.IO.Log.ReservationCollection" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3c99a-189">Der Vorgang ist aus einem der folgenden Gründe ungültig:</span><span class="sxs-lookup"><span data-stu-id="3c99a-189">The operation is invalid for one of the following reasons:</span></span>  
  
-   <span data-ttu-id="3c99a-190">Die Enumeration wurde beendet.</span><span class="sxs-lookup"><span data-stu-id="3c99a-190">The enumeration has ended.</span></span>  
  
-   <span data-ttu-id="3c99a-191">Die Auflistung wurde geändert.</span><span class="sxs-lookup"><span data-stu-id="3c99a-191">The collection has been modified.</span></span>  
  
-   <span data-ttu-id="3c99a-192">Die Enumeration wurde nicht gestartet.</span><span class="sxs-lookup"><span data-stu-id="3c99a-192">The enumeration has not been started.</span></span> <span data-ttu-id="3c99a-193">Ein Aufruf von <see cref="M:System.Collections.IEnumerator.MoveNext" /> muss erfolgen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-193">A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3c99a-194">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-194">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3c99a-195">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-195">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="3c99a-196">Der Zugriff auf den angegebenen Protokollspeicher wird vom Betriebssystem verweigert.</span><span class="sxs-lookup"><span data-stu-id="3c99a-196">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3c99a-197">Ruft einen Wert ab, der angibt, ob die Auflistung schreibgeschützt ist.</span><span class="sxs-lookup"><span data-stu-id="3c99a-197">Gets a value that indicates whether the collection is read-only.</span></span></summary>
        <value><span data-ttu-id="3c99a-198">Diese Eigenschaft gibt immer <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="3c99a-198">This property always returns <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c99a-199">Eine <xref:System.IO.Log.ReservationCollection> ist nie schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="3c99a-199">A <xref:System.IO.Log.ReservationCollection> is never read-only.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeReservation">
      <MemberSignature Language="C#" Value="protected abstract void MakeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void MakeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.MakeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub MakeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void MakeReservation(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size"><span data-ttu-id="3c99a-200">Die Größe der zuzuordnenden Reservierung.</span><span class="sxs-lookup"><span data-stu-id="3c99a-200">The size of the reservation to allocate.</span></span></param>
        <summary><span data-ttu-id="3c99a-201">Ordnet beim Überschreiben in einer abgeleiteten Klasse eine Reservierung der angegebenen Größe zu.</span><span class="sxs-lookup"><span data-stu-id="3c99a-201">When overridden in a derived class, allocates a reservation of the specified size.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="3c99a-202">Wenn Sie aus <see cref="T:System.IO.Log.ReservationCollection" /> übernehmen, müssen Sie diese Methode implementieren, um tatsächlich Speicherplatz in der Datensatzsequenz zu reservieren.</span><span class="sxs-lookup"><span data-stu-id="3c99a-202">When you inherit from <see cref="T:System.IO.Log.ReservationCollection" />, you must implement this method to actually reserve space in the record sequence.</span></span> <span data-ttu-id="3c99a-203">Sie sollten <see cref="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" /> nicht aufrufen, wenn diese Methode vollständig ist; diese Logik wird für Sie verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="3c99a-203">You should not call <see cref="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" /> when this method is complete; that logic is handled for you.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (long item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(int64 item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Remove(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(long item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="3c99a-204">Die Größe der freizugebenden Reservierung.</span><span class="sxs-lookup"><span data-stu-id="3c99a-204">The size of the reservation to release.</span></span></param>
        <summary><span data-ttu-id="3c99a-205">Gibt eine Reservierung der angegebenen Größe frei, wenn eine Reservierung vorgenommen wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-205">Releases a reservation of the specified size, if one has been made.</span></span> <span data-ttu-id="3c99a-206">Diese Methode kann nicht vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="3c99a-206">This method cannot be inherited.</span></span></summary>
        <returns>
          <span data-ttu-id="3c99a-207"><see langword="true" />, wenn eine Reservierung der angegebenen Größe gefunden und entfernt wurde; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3c99a-207"><see langword="true" /> if a reservation of the specified size was found and removed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3c99a-208">Das folgende Beispiel stellt dar, wie Sie manuell eine Reservierung vornehmen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-208">The following example shows how to manually make a reservation.</span></span> <span data-ttu-id="3c99a-209">Beachten Sie, dass diese Aufgabe nur bei Verwendung der CLFS-basierten <xref:System.IO.Log.LogRecordSequence>-Klasse ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3c99a-209">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3c99a-210">In der angegebenen Reservierungsauflistung wurde keine Reservierung gefunden, die groß genug für den angegebenen Datensatz ist.</span><span class="sxs-lookup"><span data-stu-id="3c99a-210">No reservation large enough to fit the provided record can be found in the specified reservation collection.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="3c99a-211">Ein E/A-Fehler tritt auf, wenn die Archivmomentaufnahme erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-211">An I/O error occurs when creating the archive snapshot.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3c99a-212">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-212">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3c99a-213">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-213">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="3c99a-214">Die Datensatzsequenz ist voll.</span><span class="sxs-lookup"><span data-stu-id="3c99a-214">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="3c99a-215">Der Zugriff auf den angegebenen Protokollspeicher wird vom Betriebssystem verweigert.</span><span class="sxs-lookup"><span data-stu-id="3c99a-215">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReservationFreed">
      <MemberSignature Language="C#" Value="protected void ReservationFreed (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationFreed(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationFreed (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationFreed(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size"><span data-ttu-id="3c99a-216">Die Größe der Reservierung, die freigegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-216">The size of the reservation that has been released.</span></span></param>
        <summary><span data-ttu-id="3c99a-217">Gibt beim Überschreiben in einer abgeleiteten Klasse an, dass eine Reservierung freigegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-217">When overridden in a derived class, indicates that a reservation has been released.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c99a-218">Wenn Sie aus <xref:System.IO.Log.ReservationCollection> übernehmen, müssen Sie diese Methode aufrufen, wenn eine Reservierung aus einem anderen Grund als dem Entfernen aus der Auflistung freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-218">When you inherit from <xref:System.IO.Log.ReservationCollection>, you must call this method when a reservation is released for a reason other than removing it from the collection.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReservationMade">
      <MemberSignature Language="C#" Value="protected void ReservationMade (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationMade(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationMade (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationMade(long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size"><span data-ttu-id="3c99a-219">Die Größe der Reservierung, die vorgenommen wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-219">The size of the reservation that has been made.</span></span></param>
        <summary><span data-ttu-id="3c99a-220">Gibt beim Überschreiben in einer abgeleiteten Klasse an, dass eine Reservierung vorgenommen wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-220">When overridden in a derived class, indicates that a reservation has been made.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c99a-221">Wenn Sie Elemente aus <xref:System.IO.Log.ReservationCollection> übernehmen, muss diese Methode aufgerufen werden, wenn eine Reservierung außerhalb eines Aufrufs von <xref:System.IO.Log.ReservationCollection.Add%2A> vorgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="3c99a-221">When you inherit from <xref:System.IO.Log.ReservationCollection>, you must call this method when a reservation is made outside of a call to <xref:System.IO.Log.ReservationCollection.Add%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3c99a-222">Gibt einen Enumerator zurück, der die <see cref="T:System.IO.Log.ReservationCollection" /> durchlaufen kann.</span><span class="sxs-lookup"><span data-stu-id="3c99a-222">Returns an enumerator that can iterate through the <see cref="T:System.IO.Log.ReservationCollection" />.</span></span> <span data-ttu-id="3c99a-223">Diese Methode kann nicht vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="3c99a-223">This method cannot be inherited.</span></span></summary>
        <returns><span data-ttu-id="3c99a-224">Ein Enumerator, der die <see cref="T:System.IO.Log.ReservationCollection" /> durchlaufen kann.</span><span class="sxs-lookup"><span data-stu-id="3c99a-224">An enumerator that can iterate through the <see cref="T:System.IO.Log.ReservationCollection" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3c99a-225">Der Vorgang ist aus einem der folgenden Gründe ungültig:</span><span class="sxs-lookup"><span data-stu-id="3c99a-225">The operation is invalid for one of the following reasons:</span></span>  
  
-   <span data-ttu-id="3c99a-226">Die Enumeration wurde beendet.</span><span class="sxs-lookup"><span data-stu-id="3c99a-226">The enumeration has ended.</span></span>  
  
-   <span data-ttu-id="3c99a-227">Die Auflistung wurde geändert.</span><span class="sxs-lookup"><span data-stu-id="3c99a-227">The collection has been modified.</span></span>  
  
-   <span data-ttu-id="3c99a-228">Die Enumeration wurde nicht gestartet.</span><span class="sxs-lookup"><span data-stu-id="3c99a-228">The enumeration has not been started.</span></span> <span data-ttu-id="3c99a-229">Ein Aufruf von <see cref="M:System.Collections.IEnumerator.MoveNext" /> muss erfolgen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-229">A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="3c99a-230">Die Methode wurde aufgerufen, nachdem die Sequenz verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="3c99a-230">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3c99a-231">Der Arbeitsspeicher reicht nicht aus, um die Ausführung des Programms fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="3c99a-231">There is not enough memory to continue the execution of the program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="3c99a-232">Der Zugriff auf den angegebenen Protokollspeicher wird vom Betriebssystem verweigert.</span><span class="sxs-lookup"><span data-stu-id="3c99a-232">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>