<Type Name="BitArray" FullName="System.Collections.BitArray">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b1cf10d304085aace8f8456134a3c6c2a84e70de" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52353465" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class BitArray : ICloneable, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit BitArray extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.BitArray" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BitArray&#xA;Implements ICloneable, ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class BitArray sealed : ICloneable, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type BitArray = class&#xA;    interface ICollection&#xA;    interface ICloneable&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Verwaltet ein komprimiertes Array von Bitwerten, die als boolesche Werte dargestellt sind. <see langword="true" /> bezeichnet hierbei ein gesetztes Bit (1), und <see langword="false" /> bezeichnet ein nicht gesetztes Bit (0).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.BitArray> Klasse ist eine Auflistungsklasse, die in der die Kapazität immer identisch mit der Anzahl ist. Werden Elemente hinzugefügt, ein <xref:System.Collections.BitArray> durch Erhöhen der <xref:System.Collections.BitArray.Length%2A> Eigenschaft Elemente gelöscht werden, verringert werden, da die <xref:System.Collections.BitArray.Length%2A> Eigenschaft. Die Größe des eine <xref:System.Collections.BitArray> ist vom Client kontrollierte Indizierung nach dem Ende der <xref:System.Collections.BitArray> löst eine <xref:System.ArgumentException>. Die <xref:System.Collections.BitArray> -Klasse bietet Methoden, die nicht, in anderen Auflistungen gefunden werden, einschließlich derjenigen, die mehrere Elemente gleichzeitig wie z. B. mit einem Filter, geändert werden, können <xref:System.Collections.BitArray.And%2A>, <xref:System.Collections.BitArray.Or%2A>, <xref:System.Collections.BitArray.Xor%2A> , <xref:System.Collections.BitArray.Not%2A>, und <xref:System.Collections.BitArray.SetAll%2A>.  
  
 Die <xref:System.Collections.Specialized.BitVector32> -Klasse ist eine Struktur, die die gleiche Funktionalität wie bietet <xref:System.Collections.BitArray>, jedoch leistungsfähiger. <xref:System.Collections.Specialized.BitVector32> ist schneller, da es sich um einen Werttyp handelt, und daher auf dem Stapel zugeordnet werden, während <xref:System.Collections.BitArray> ein Verweistyp ist, und daher auf dem Heap reserviert.  
  
 <xref:System.Collections.Specialized.BitVector32?displayProperty=nameWithType> kann genau 32 Bit, speichern, wohingegen <xref:System.Collections.BitArray> kann eine Variable Anzahl von Bits gespeichert. <xref:System.Collections.Specialized.BitVector32> Speichert Bitflags und kleine Ganzzahlen, wodurch er besonders geeignet für Daten, die nicht verfügbar gemacht werden, die dem Benutzer verwendet. Wenn die Anzahl der erforderlichen Bitflags unbekannt ist, Variable oder größer als 32, allerdings verwenden <xref:System.Collections.BitArray> stattdessen.  
  
 <xref:System.Collections.BitArray> befindet sich in der <xref:System.Collections> Namespace <xref:System.Collections.Specialized.BitVector32> befindet sich in der <xref:System.Collections.Specialized> Namespace.  
  
 Elemente in dieser Auflistung können über einen Ganzzahlenindex zugegriffen werden.  Indizes in dieser Auflistung sind nullbasiert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren eine <xref:System.Collections.BitArray> und wie Sie die entsprechenden Werte ausgegeben.  
  
 [!code-cpp[Classic BitArray Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic BitArray Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BitArray Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic BitArray Example/CS/source.cs#1)]
 [!code-vb[Classic BitArray Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic BitArray Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Diese Implementierung bietet keinen synchronisierten (threadsicheren) Wrapper für eine <see cref="T:System.Collections.BitArray" />.  
  
Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</threadsafe>
    <altmember cref="T:System.Collections.Specialized.BitVector32" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.BitArray" />-Klasse, deren Kapazität und Anfangswerte angegeben werden können.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BitArray (bool[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.#ctor(System.Boolean[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (values As Boolean())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BitArray(cli::array &lt;bool&gt; ^ values);" />
      <MemberSignature Language="F#" Value="new System.Collections.BitArray : bool[] -&gt; System.Collections.BitArray" Usage="new System.Collections.BitArray values" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="values" Type="System.Boolean[]" />
      </Parameters>
      <Docs>
        <param name="values">Ein Array mit den zu kopierenden booleschen Werten.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.BitArray" />-Klasse mit Bitwerten, die aus dem angegebenen Array von booleschen Werten kopiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist eine O (`n`)-Vorgang, in denen `n` ist die Anzahl der Elemente im `values`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BitArray (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bytes As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BitArray(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="new System.Collections.BitArray : byte[] -&gt; System.Collections.BitArray" Usage="new System.Collections.BitArray bytes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Ein Bytearray, das die zu kopierenden Werte enthält, wobei jedes Byte acht aufeinander folgende Bits darstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.BitArray" />-Klasse mit Bitwerten, die aus dem angegebenen Bytearray kopiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das erste Byte im Array stellt Bits 0 bis 7, das zweite Byte Bits 8 bis 15 und So weiter. Die niedrigsten Bit der jedes Byte stellt den niedrigsten Indexwert: " `bytes` [0] & 1" stellt Bit 0 (null) " `bytes` [0] & 2" stellt Bit 1, " `bytes` [0] & 4" stellt 2-bit- und so weiter.  
  
 Dieser Konstruktor ist eine O (`n`)-Vorgang, in denen `n` ist die Anzahl der Elemente im `bytes`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="bytes" /> überschreitet den <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BitArray (System.Collections.BitArray bits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.BitArray bits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.#ctor(System.Collections.BitArray)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bits As BitArray)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BitArray(System::Collections::BitArray ^ bits);" />
      <MemberSignature Language="F#" Value="new System.Collections.BitArray : System.Collections.BitArray -&gt; System.Collections.BitArray" Usage="new System.Collections.BitArray bits" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bits" Type="System.Collections.BitArray" />
      </Parameters>
      <Docs>
        <param name="bits">Das <see cref="T:System.Collections.BitArray" />, das kopiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.BitArray" />-Klasse mit Bitwerten, die aus dem angegebenen <see cref="T:System.Collections.BitArray" /> kopiert wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist eine O (`n`)-Vorgang, in denen `n` ist die Anzahl der Elemente im `bits`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bits" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BitArray (int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BitArray(int length);" />
      <MemberSignature Language="F#" Value="new System.Collections.BitArray : int -&gt; System.Collections.BitArray" Usage="new System.Collections.BitArray length" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="length">Die Anzahl der Bitwerte im neuen <see cref="T:System.Collections.BitArray" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.BitArray" />-Klasse, die die angegebene Anzahl von Bitwerten enthalten kann. Diese werden am Anfang auf <see langword="false" /> festgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist eine O (`n`)-Vorgang, in denen `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BitArray (int[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.#ctor(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (values As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BitArray(cli::array &lt;int&gt; ^ values);" />
      <MemberSignature Language="F#" Value="new System.Collections.BitArray : int[] -&gt; System.Collections.BitArray" Usage="new System.Collections.BitArray values" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="values" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="values">Ein Array von Ganzzahlen, das die zu kopierenden Werte enthält, wobei jede Ganzzahl 32 aufeinander folgende Bits darstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.BitArray" />-Klasse mit Bitwerten, die aus dem angegebenen Array von 32-Bit-Ganzzahlen kopiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl in der ersten `values` Arrayelement stellt Bits 0 bis 31, die zweite Zahl im Array Bits 32 bis 63 und So weiter. Das niederwertigste Bit der jede ganze Zahl darstellt, den niedrigsten Indexwert: " `values` [0] & 1" stellt Bit 0 (null) " `values` [0] & 2" stellt Bit 1, " `values` [0] & 4" stellt 2-bit- und so weiter.  
  
 Dieser Konstruktor ist eine O (`n`)-Vorgang, in denen `n` ist die Anzahl der Elemente im `values`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="values" /> überschreitet <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BitArray (int length, bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 length, bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.#ctor(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (length As Integer, defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BitArray(int length, bool defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Collections.BitArray : int * bool -&gt; System.Collections.BitArray" Usage="new System.Collections.BitArray (length, defaultValue)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="length">Die Anzahl der Bitwerte im neuen <see cref="T:System.Collections.BitArray" />.</param>
        <param name="defaultValue">Der boolesche Wert, der jedem Bit zugeordnet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.BitArray" />-Klasse, die die angegebene Anzahl von Bitwerten enthalten kann. Diese werden am Anfang auf den angegebenen Wert festgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist eine O (`n`)-Vorgang, in denen `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public System.Collections.BitArray And (System.Collections.BitArray value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.BitArray And(class System.Collections.BitArray value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.And(System.Collections.BitArray)" />
      <MemberSignature Language="VB.NET" Value="Public Function And (value As BitArray) As BitArray" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::BitArray ^ And(System::Collections::BitArray ^ value);" />
      <MemberSignature Language="F#" Value="member this.And : System.Collections.BitArray -&gt; System.Collections.BitArray" Usage="bitArray.And value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.BitArray</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Collections.BitArray" />
      </Parameters>
      <Docs>
        <param name="value">Das Array, mit dem die bitweise AND-Operation ausgeführt werden soll.</param>
        <summary>Führt die bitweise AND-Operation zwischen den Elementen des aktuellen <see cref="T:System.Collections.BitArray" />-Objekts und den entsprechenden Elementen im angegebenen Array aus. Das aktuelle <see cref="T:System.Collections.BitArray" />-Objekt wird so geändert, dass das Ergebnis der bitweisen AND-Operation gespeichert wird.</summary>
        <returns>Ein Array, das das Ergebnis der bitweisen AND-Operation enthält. Hierbei handelt es sich um einen Verweis auf das aktuelle <see cref="T:System.Collections.BitArray" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt zurück, die bitweise AND-Operation `true` Wenn beide Operanden sind `true`, und gibt `false` Wenn einer oder beide Operanden sind `false`.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.BitArray.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Ausführen der bitweisen AND-Operation zwischen zwei <xref:System.Collections.BitArray> Objekte.  
  
 [!code-cpp[Classic BitArray.And Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic BitArray.And Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BitArray.And Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic BitArray.And Example/CS/source.cs#1)]
 [!code-vb[Classic BitArray.And Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic BitArray.And Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> und das aktuelle <see cref="T:System.Collections.BitArray" /> enthalten nicht die gleiche Anzahl von Elementen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="bitArray.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine flache Kopie von <see cref="T:System.Collections.BitArray" />.</summary>
        <returns>Eine flache Kopie von <see cref="T:System.Collections.BitArray" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine flache Kopie einer Auflistung kopiert nur die Elemente der Auflistung, ob sie Verweis- oder Werttypen sind, aber die Objekte, denen auf die verwiesen wird nicht kopiert. Die Verweise in der neuen Sammlung zeigen Sie auf dieselben Objekte, denen auf die Verweise in der ursprünglichen Auflistung verweisen.  
  
 Im Gegensatz dazu wird eine tiefe Kopie einer Auflistung kopiert die Elemente, und alles, was durch die Elemente direkt oder indirekt verwiesen.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.BitArray.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="bitArray.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.BitArray" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die gesamte <see cref="T:System.Collections.BitArray" />-Instanz in ein kompatibles eindimensionales <see cref="T:System.Array" />, beginnend am angegebenen Index des Zielarrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das angegebene Array muss von einem kompatiblen Typ sein. Nur `bool`, `int`, und `byte` Typen von Arrays werden unterstützt.  
  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType> die Elemente kopiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.BitArray.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Kopieren einer <xref:System.Collections.BitArray> in ein eindimensionales <xref:System.Array>.  
  
 [!code-cpp[Classic BitArray.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic BitArray.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BitArray.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic BitArray.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic BitArray.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic BitArray.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ist mehrdimensional.  
  
- oder -  
Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.BitArray" /> ist größer als der verfügbare Platz vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
        <exception cref="T:System.InvalidCastException">Der Typ der Quell-<see cref="T:System.Collections.BitArray" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.BitArray.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.BitArray.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Collections.BitArray" /> enthalten sind.</summary>
        <value>Die Anzahl der Elemente, die in <see cref="T:System.Collections.BitArray" /> enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.BitArray.Length%2A> und <xref:System.Collections.BitArray.Count%2A> derselbe Wert zurückgegeben. <xref:System.Collections.BitArray.Length%2A> kann auf einen bestimmten Wert festgelegt werden, aber <xref:System.Collections.BitArray.Count%2A> ist schreibgeschützt.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public bool Get (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Get(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.Get(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Get (index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Get(int index);" />
      <MemberSignature Language="F#" Value="member this.Get : int -&gt; bool" Usage="bitArray.Get index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des abzurufenden Werts.</param>
        <summary>Ruft den Wert des Bits an einer bestimmten Position im <see cref="T:System.Collections.BitArray" /> ab.</summary>
        <returns>Der Wert des Bits an Position <paramref name="index" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen von bestimmten Elementen einem <xref:System.Collections.BitArray>.  
  
 [!code-cpp[Classic BitArray.Get Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic BitArray.Get Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BitArray.Get Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic BitArray.Get Example/CS/source.cs#1)]
 [!code-vb[Classic BitArray.Get Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic BitArray.Get Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.  
  
- oder -  
 <paramref name="index" /> ist größer gleich der Anzahl von Elementen im <see cref="T:System.Collections.BitArray" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="bitArray.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die <see cref="T:System.Collections.BitArray" /> durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für die gesamte <see cref="T:System.Collections.BitArray" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach`-Anweisung der Programmiersprache C# (`for each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.  Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.BitArray.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.BitArray.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.BitArray" /> schreibgeschützt ist.</summary>
        <value>Diese Eigenschaft ist immer <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.BitArray> implementiert die <xref:System.Collections.BitArray.IsReadOnly%2A> Eigenschaft, da dies erforderlich ist der <xref:System.Collections.IList?displayProperty=nameWithType> Schnittstelle.  
  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der verhindert, dass die Auflistung zu ändern; Wenn die zugrunde liegende Auflistung Änderungen vorgenommen werden, spiegelt die schreibgeschützte Auflistung aus diesem Grund diese Änderungen wider.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.BitArray.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.BitArray.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.BitArray" /> synchronisiert (threadsicher) ist.</summary>
        <value>Diese Eigenschaft ist immer <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.BitArray> implementiert die <xref:System.Collections.BitArray.IsSynchronized%2A> Eigenschaft, da dies erforderlich ist der <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Auflistung mit Sperren der <xref:System.Collections.BitArray.SyncRoot%2A> während der gesamten Enumeration.  
  
 [!code-cpp[Classic BitArray Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic BitArray Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic BitArray Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic BitArray Example/CS/source2.cs#2)]
 [!code-vb[Classic BitArray Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic BitArray Example/VB/source2.vb#2)]  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.BitArray.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public bool this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.BitArray.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool default[int] { bool get(int index); void set(int index, bool value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : bool with get, set" Usage="System.Collections.BitArray.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des Werts, der abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft den Wert eines Bits an einer bestimmten Position im <see cref="T:System.Collections.BitArray" /> ab oder legt diesen fest.</summary>
        <value>Der Wert des Bits an Position <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf ein bestimmtes Element in der Auflistung mithilfe folgender Syntax: `myCollection[index]`.  
  
 Die Programmiersprache c# verwendet das Schlüsselwort der Indexer definieren die <xref:System.Collections.BitArray.Item%2A> Eigenschaft. Visual Basic implementiert <xref:System.Collections.BitArray.Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang. Festlegen der Eigenschaft ist auch ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.  
  
- oder -  
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.BitArray.Count" />.</exception>
        <altmember cref="P:System.Collections.BitArray.Count" />
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public System.Collections.BitArray LeftShift (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.BitArray LeftShift(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.LeftShift(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LeftShift (count As Integer) As BitArray" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::BitArray ^ LeftShift(int count);" />
      <MemberSignature Language="F#" Value="member this.LeftShift : int -&gt; System.Collections.BitArray" Usage="bitArray.LeftShift count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.BitArray</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Collections.BitArray.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Collections.BitArray.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Elementen im <see cref="T:System.Collections.BitArray" /> ab oder legt diese fest.</summary>
        <value>Die Anzahl der Elemente im <see cref="T:System.Collections.BitArray" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.BitArray.Length%2A> und <xref:System.Collections.BitArray.Count%2A> derselbe Wert zurückgegeben. <xref:System.Collections.BitArray.Length%2A> kann auf einen bestimmten Wert festgelegt werden, aber <xref:System.Collections.BitArray.Count%2A> ist schreibgeschützt.  
  
 Wenn <xref:System.Collections.BitArray.Length%2A> auf einen Wert festgelegt ist kleiner als <xref:System.Collections.BitArray.Count%2A>, <xref:System.Collections.BitArray> wird abgeschnitten, und die Elemente nach dem Index `value` -1 werden gelöscht.  
  
 Wenn <xref:System.Collections.BitArray.Length%2A> festgelegt ist, auf einen Wert, der größer als <xref:System.Collections.BitArray.Count%2A>, neue Elemente werden festgelegt, um `false`.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang. Durch Festlegen dieser Eigenschaft ist eine O (`n`) Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Eigenschaft wird auf einen Wert festgelegt, der kleiner als 0 (null) ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public System.Collections.BitArray Not ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.BitArray Not() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.Not" />
      <MemberSignature Language="VB.NET" Value="Public Function Not () As BitArray" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::BitArray ^ Not();" />
      <MemberSignature Language="F#" Value="member this.Not : unit -&gt; System.Collections.BitArray" Usage="bitArray.Not " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.BitArray</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invertiert alle Bitwerte im aktuellen <see cref="T:System.Collections.BitArray" />, sodass auf <see langword="true" /> festgelegte Elemente auf <see langword="false" /> und auf <see langword="false" /> festgelegte Elemente auf <see langword="true" /> festgelegt werden.</summary>
        <returns>Die aktuelle Instanz mit invertierten Bitwerten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.BitArray.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie nicht auf Anwenden eine <xref:System.Collections.BitArray>.  
  
 [!code-cpp[Classic BitArray.Not Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic BitArray.Not Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BitArray.Not Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic BitArray.Not Example/CS/source.cs#1)]
 [!code-vb[Classic BitArray.Not Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic BitArray.Not Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public System.Collections.BitArray Or (System.Collections.BitArray value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.BitArray Or(class System.Collections.BitArray value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.Or(System.Collections.BitArray)" />
      <MemberSignature Language="VB.NET" Value="Public Function Or (value As BitArray) As BitArray" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::BitArray ^ Or(System::Collections::BitArray ^ value);" />
      <MemberSignature Language="F#" Value="member this.Or : System.Collections.BitArray -&gt; System.Collections.BitArray" Usage="bitArray.Or value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.BitArray</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Collections.BitArray" />
      </Parameters>
      <Docs>
        <param name="value">Das Array, mit dem die bitweise OR-Operation ausgeführt werden soll.</param>
        <summary>Führt die bitweise OR-Operation zwischen den Elementen des aktuellen <see cref="T:System.Collections.BitArray" />-Objekts und den entsprechenden Elementen im angegebenen Array aus. Das aktuelle <see cref="T:System.Collections.BitArray" />-Objekt wird so geändert, dass das Ergebnis der bitweisen OR-Operation gespeichert wird.</summary>
        <returns>Ein Array, das das Ergebnis der bitweisen OR-Operation enthält. Hierbei handelt es sich um einen Verweis auf das aktuelle <see cref="T:System.Collections.BitArray" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt die bitweise OR-Operation `true` Wenn einer oder beide Operanden sind `true`, und gibt `false` Wenn beide Operanden sind `false`.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.BitArray.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die OR-Operation zwischen zwei auszuführenden <xref:System.Collections.BitArray> Objekte.  
  
 [!code-cpp[Classic BitArray.Or Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic BitArray.Or Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BitArray.Or Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic BitArray.Or Example/CS/source.cs#1)]
 [!code-vb[Classic BitArray.Or Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic BitArray.Or Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> und das aktuelle <see cref="T:System.Collections.BitArray" /> enthalten nicht die gleiche Anzahl von Elementen.</exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public System.Collections.BitArray RightShift (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.BitArray RightShift(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.RightShift(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RightShift (count As Integer) As BitArray" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::BitArray ^ RightShift(int count);" />
      <MemberSignature Language="F#" Value="member this.RightShift : int -&gt; System.Collections.BitArray" Usage="bitArray.RightShift count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.BitArray</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public void Set (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Set(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.Set(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Set (index As Integer, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Set(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Set : int * bool -&gt; unit" Usage="bitArray.Set (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des festzulegenden Bits.</param>
        <param name="value">Der boolesche Wert, der dem Bit zugeordnet werden soll.</param>
        <summary>Legt das Bit an einer bestimmten Position im <see cref="T:System.Collections.BitArray" /> auf den angegebenen Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen von bestimmten Elementen einem <xref:System.Collections.BitArray>.  
  
 [!code-cpp[Classic BitArray.Get Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic BitArray.Get Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BitArray.Get Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic BitArray.Get Example/CS/source.cs#1)]
 [!code-vb[Classic BitArray.Get Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic BitArray.Get Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.  
  
- oder -  
 <paramref name="index" /> ist größer gleich der Anzahl von Elementen im <see cref="T:System.Collections.BitArray" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAll">
      <MemberSignature Language="C#" Value="public void SetAll (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAll(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.SetAll(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAll (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAll(bool value);" />
      <MemberSignature Language="F#" Value="member this.SetAll : bool -&gt; unit" Usage="bitArray.SetAll value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Der boolesche Wert, der allen Bits zugeordnet werden soll.</param>
        <summary>Legt alle Bits im <see cref="T:System.Collections.BitArray" /> auf den angegebenen Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.BitArray.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen von bestimmten Elementen einem <xref:System.Collections.BitArray>.  
  
 [!code-cpp[Classic BitArray.Get Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic BitArray.Get Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BitArray.Get Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic BitArray.Get Example/CS/source.cs#1)]
 [!code-vb[Classic BitArray.Get Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic BitArray.Get Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.BitArray.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.BitArray.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.BitArray" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Collections.BitArray" /> synchronisiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen können eigene synchronisierte Version des Bereitstellen der <xref:System.Collections.BitArray> mithilfe der <xref:System.Collections.BitArray.SyncRoot%2A> Eigenschaft. Der Synchronisierungscode dürfen Vorgänge auf den <xref:System.Collections.BitArray.SyncRoot%2A> von der <xref:System.Collections.BitArray>, nicht direkt auf die <xref:System.Collections.BitArray>. Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind. Insbesondere verwaltet ordnungsgemäße Synchronisierung mit anderen Threads, die möglicherweise gleichzeitig ändern können die <xref:System.Collections.BitArray> Objekt.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Auflistung mit Sperren der <xref:System.Collections.BitArray.SyncRoot%2A> während der gesamten Enumeration.  
  
 [!code-cpp[Classic BitArray Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic BitArray Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic BitArray Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic BitArray Example/CS/source2.cs#2)]
 [!code-vb[Classic BitArray Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic BitArray Example/VB/source2.vb#2)]  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.BitArray.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.BitArray.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.BitArray.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.BitArray.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public System.Collections.BitArray Xor (System.Collections.BitArray value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.BitArray Xor(class System.Collections.BitArray value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.BitArray.Xor(System.Collections.BitArray)" />
      <MemberSignature Language="VB.NET" Value="Public Function Xor (value As BitArray) As BitArray" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::BitArray ^ Xor(System::Collections::BitArray ^ value);" />
      <MemberSignature Language="F#" Value="member this.Xor : System.Collections.BitArray -&gt; System.Collections.BitArray" Usage="bitArray.Xor value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.BitArray</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Collections.BitArray" />
      </Parameters>
      <Docs>
        <param name="value">Das Array, mit dem die bitweise exklusive OR-Operation ausgeführt werden soll.</param>
        <summary>Führt die bitweise exklusive OR-Operation zwischen den Elementen des aktuellen <see cref="T:System.Collections.BitArray" />-Objekts für die entsprechenden Elemente im angegebenen Array aus. Das aktuelle <see cref="T:System.Collections.BitArray" />-Objekt wird dahingehend geändert, dass das Ergebnis der bitweisen exklusiven OR-Operation gespeichert wird.</summary>
        <returns>Ein Array, das das Ergebnis der bitweisen exklusiven OR-Operation enthält. Hierbei handelt es sich um einen Verweis auf das aktuelle <see cref="T:System.Collections.BitArray" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt die bitweise exklusive OR-Operation `true` ist genau ein Operand `true`, und gibt `false` Wenn beide Operanden denselben booleschen Wert haben.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.BitArray.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Ausführen der XOR-Operation zwischen zwei <xref:System.Collections.BitArray> Objekte.  
  
 [!code-cpp[Classic BitArray.Xor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic BitArray.Xor Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BitArray.Xor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic BitArray.Xor Example/CS/source.cs#1)]
 [!code-vb[Classic BitArray.Xor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic BitArray.Xor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> und das aktuelle <see cref="T:System.Collections.BitArray" /> enthalten nicht die gleiche Anzahl von Elementen.</exception>
      </Docs>
    </Member>
  </Members>
</Type>