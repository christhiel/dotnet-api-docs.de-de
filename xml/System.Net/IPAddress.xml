<Type Name="IPAddress" FullName="System.Net.IPAddress">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ded3e78bb400015dbcba3211273b67d9ed529a14" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36472070" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class IPAddress" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit IPAddress extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.IPAddress" />
  <TypeSignature Language="VB.NET" Value="Public Class IPAddress" />
  <TypeSignature Language="C++ CLI" Value="public ref class IPAddress" />
  <TypeSignature Language="F#" Value="type IPAddress = class" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Primitives</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides an Internet Protocol (IP) address.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress> Klasse enthält die Adresse eines Computers in einem IP-Netzwerk.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Abfragen ein Servers für die Familie Adressen abzurufen und die IP-Adressen unterstützt.  
  
 [!code-cpp[System.Net.IPAddress#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#1)]
 [!code-csharp[System.Net.IPAddress#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#1)]
 [!code-vb[System.Net.IPAddress#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : byte[] -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="address">The byte array value of the IP address.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress> wird erstellt, mit der <xref:System.Net.IPAddress.Address%2A> -Eigenschaftensatz auf `address`.  
  
 Wenn die Länge des `address` ist 4, <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> erstellt eine IPv4-Adresse; andernfalls wird eine IPv6-Adresse mit einem Bereich von 0 erstellt.  
  
 Die <xref:System.Byte> Array wird davon ausgegangen, dass in der netzwerkbyte-Reihenfolge mit dem höchstwertigen Byte zuerst in die Indexposition 0 sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> contains a bad IP address.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (long newAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 newAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (newAddress As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(long newAddress);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress newAddress" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="newAddress" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="newAddress">The long value of the IP address. For example, the value 0x2414188f in big-endian format would be the IP address "143.24.20.36".</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as an <see cref="T:System.Int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress> Instanz wird erstellt, mit der <xref:System.Net.IPAddress.Address%2A> -Eigenschaftensatz auf `newAddress`.  
  
 Die <xref:System.Int64> Wert wird davon ausgegangen, dass in der netzwerkbyte-Reihenfolge geordnet werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newAddress" /> &lt; 0 or  <paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : ReadOnlySpan&lt;byte&gt; -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[],System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte(), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address, long scopeid);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : byte[] * int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress (address, scopeid)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">The byte array value of the IP address.</param>
        <param name="scopeid">The long value of the scope identifier.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array and the specified scope identifier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor instanziiert eine IPv6-Adresse. Die `scopeid` im Falle einer verbindungslokale Adresse eine Netzwerkschnittstelle identifiziert. Der Bereich ist nur für verbindungslokale und standortlokale Adressen gültig.  
  
 Die <xref:System.Byte> Array wird davon ausgegangen, dass in der netzwerkbyte-Reihenfolge mit dem höchstwertigen Byte zuerst in die Indexposition 0 sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> contains a bad IP address.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="scopeid" /> &lt; 0 or  <paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address, long scopeid);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : ReadOnlySpan&lt;byte&gt; * int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress (address, scopeid)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <param name="scopeid">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public long Address { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.Address" />
      <MemberSignature Language="VB.NET" Value="Public Property Address As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Address { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Address : int64 with get, set" Usage="System.Net.IPAddress.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An Internet Protocol (IP) address.</summary>
        <value>Die long-Wert der IP-Adresse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist veraltet. Verwenden Sie <xref:System.Net.IPAddress.GetAddressBytes%2A>.  
  
 Zu konvertierende <xref:System.Net.IPAddress.Address%2A> Punktnotation, verwenden die <xref:System.Net.IPAddress.ToString%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.IPAddress.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the address family of the IP address.</summary>
        <value>Gibt <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> für IPv4- oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> für IPv6.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Finden Sie im Beispiel in der <xref:System.Net.IPAddress> klassenthema.  
  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Any : System.Net.IPAddress" Usage="System.Net.IPAddress.Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides an IP address that indicates that the server must listen for client activity on all network interfaces. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> -Methode verwendet die <xref:System.Net.IPAddress.Any> Feld an, dass eine <xref:System.Net.Sockets.Socket> Instanz muss Clientaktivität an allen Netzwerkschnittstellen.  
  
 Die <xref:System.Net.IPAddress.Any> Feld entspricht 0.0.0.0 in Punktnotation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Broadcast;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Broadcast" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Broadcast" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Broadcast As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Broadcast;" />
      <MemberSignature Language="F#" Value=" staticval mutable Broadcast : System.Net.IPAddress" Usage="System.Net.IPAddress.Broadcast" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides the IP broadcast address. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress.Broadcast> Feld entspricht 255.255.255.255 in Punktnotation.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Net.IPAddress.Broadcast> Adresse, an die Konsole.  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#2)]
 [!code-csharp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#2)]
 [!code-vb[IPAddress_Broadcast_Loopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="iPAddress.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">An <see cref="T:System.Net.IPAddress" /> instance to compare to the current instance.</param>
        <summary>Compares two IP addresses.</summary>
        <returns>
          <see langword="true" /> if the two addresses are equal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress.Equals%2A> Methode vergleicht den aktuellen <xref:System.Net.IPAddress> -Instanz mit der `comparand` Parameter und gibt `true` , wenn die beiden Instanzen die gleiche IP-Adresse enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAddressBytes">
      <MemberSignature Language="C#" Value="public byte[] GetAddressBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetAddressBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetAddressBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAddressBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetAddressBytes();" />
      <MemberSignature Language="F#" Value="member this.GetAddressBytes : unit -&gt; byte[]" Usage="iPAddress.GetAddressBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provides a copy of the <see cref="T:System.Net.IPAddress" /> as an array of bytes.</summary>
        <returns>A <see cref="T:System.Byte" /> array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Server im Byteformat IP-Adresse abrufen.  
  
 [!code-cpp[System.Net.IPAddress#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#2)]
 [!code-csharp[System.Net.IPAddress#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#2)]
 [!code-vb[System.Net.IPAddress#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="iPAddress.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a hash value for an IP address.</summary>
        <returns>An integer hash value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress.GetHashCode%2A> Methode gibt einen Hashcode für die IP-Adresse zurück. Dieser Wert kann als Schlüssel für Hashtabellen verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HostToNetworkOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts a value from host byte order to network byte order.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static short HostToNetworkOrder (short host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 HostToNetworkOrder(int16 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short HostToNetworkOrder(short host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int16 -&gt; int16" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="host">The number to convert, expressed in host byte order.</param>
        <summary>Converts a short value from host byte order to network byte order.</summary>
        <returns>A short value, expressed in network byte order.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unterschiedliche Computer verwenden unterschiedliche Konventionen für die Anordnung der Bytes in Ganzzahlwerten. Einige Computer platzieren zuerst das höchstwertige Byte (auch bekannt als big-Endian-Reihenfolge) und andere platzieren zuerst das unwichtigste Byte (bekannt als little-Endian-Reihenfolge). Zusammenarbeit mit Computern, die verschiedene Bytereihenfolge verwenden, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden in der netzwerkbyte-Reihenfolge gesendet, mit dem höchstwertigen Byte zuerst.  
  
 Die <xref:System.Net.IPAddress.HostToNetworkOrder%2A> Methode konvertiert Ganzzahlwerten, die auf dem Hostsystem aus der durch den Host, der vom Netzwerk verwendete Bytereihenfolge gespeichert sind.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static int HostToNetworkOrder (int host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 HostToNetworkOrder(int32 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int HostToNetworkOrder(int host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int -&gt; int" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">The number to convert, expressed in host byte order.</param>
        <summary>Converts an integer value from host byte order to network byte order.</summary>
        <returns>An integer value, expressed in network byte order.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unterschiedliche Computer verwenden unterschiedliche Konventionen für die Anordnung der Bytes in Ganzzahlwerten. Einige Computer platzieren zuerst das höchstwertige Byte (auch bekannt als big-Endian-Reihenfolge) und andere platzieren zuerst das unwichtigste Byte (bekannt als little-Endian-Reihenfolge). Zusammenarbeit mit Computern, die verschiedene Bytereihenfolge verwenden, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden in der netzwerkbyte-Reihenfolge gesendet, mit dem höchstwertigen Byte zuerst.  
  
 Die <xref:System.Net.IPAddress.HostToNetworkOrder%2A> Methode konvertiert Ganzzahlwerten, die auf dem Hostsystem aus der durch den Host, der vom Netzwerk verwendete Bytereihenfolge gespeichert sind.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static long HostToNetworkOrder (long host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 HostToNetworkOrder(int64 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long HostToNetworkOrder(long host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int64 -&gt; int64" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="host">The number to convert, expressed in host byte order.</param>
        <summary>Converts a long value from host byte order to network byte order.</summary>
        <returns>A long value, expressed in network byte order.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unterschiedliche Computer verwenden unterschiedliche Konventionen für die Anordnung der Bytes in Ganzzahlwerten. Einige Computer platzieren zuerst das höchstwertige Byte (auch bekannt als big-Endian-Reihenfolge) und andere platzieren zuerst das unwichtigste Byte (bekannt als little-Endian-Reihenfolge). Zusammenarbeit mit Computern, die verschiedene Bytereihenfolge verwenden, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden in der netzwerkbyte-Reihenfolge gesendet, mit dem höchstwertigen Byte zuerst.  
  
 Die <xref:System.Net.IPAddress.HostToNetworkOrder%2A> Methode konvertiert Ganzzahlwerten, die auf dem Hostsystem aus der durch den Host, der vom Netzwerk verwendete Bytereihenfolge gespeichert sind.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="IPv6Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6Any : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method uses the <see cref="F:System.Net.IPAddress.IPv6Any" /> field to indicate that a <see cref="T:System.Net.Sockets.Socket" /> must listen for client activity on all network interfaces.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress.IPv6Any> Feld entspricht 0:0:0:0:0:0:0:0 in Hexadezimalschreibweise oder:: in kompakter Notation.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Debugger zeigt den Wert des aktuellen des Hosts einer beliebigen Adresse im Standardformat komprimierte.  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#2)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#2)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Loopback;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6Loopback : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6Loopback" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides the IP loopback address. This property is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress.IPv6Loopback> Feld entspricht 0:0:0:0:0:0:0:1 in Hexadezimalschreibweise oder:: 1 in kompakter Notation.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert der Loopback-Adresse des Hosts im komprimierten Standardformat.  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6None;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6None : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides an IP address that indicates that no network interface should be used. This property is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> -Methode verwendet die <xref:System.Net.IPAddress.IPv6None> Feld an, dass eine <xref:System.Net.Sockets.Socket> Clientaktivität muss nicht abhören. Die <xref:System.Net.IPAddress.IPv6None> Feld entspricht 0:0:0:0:0:0:0:0 in Hexadezimalschreibweise oder:: 0 in kompakter Notation.  
  
   
  
## Examples  
 Im folgenden Codebeispiel zeigt den Wert des aktuellen Hosts des keine Adresse im Standardformat komprimierte.  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#3)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#3)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv4MappedToIPv6">
      <MemberSignature Language="C#" Value="public bool IsIPv4MappedToIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv4MappedToIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv4MappedToIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv4MappedToIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv4MappedToIPv6 : bool" Usage="System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets whether the IP address is an IPv4-mapped IPv6 address.</summary>
        <value>Gibt <see cref="T:System.Boolean" />zurück.  
  
 <see langword="true" /> Wenn die IP-Adresse eine IPv4-zugeordneten IPv6-Adresse ist. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dual-Stack-Sockets erfordern immer, IPv6-Adressen. Die Möglichkeit für die Interaktion mit einer IPv4-Adresse erfordert die Verwendung von IPv4-zugeordneten IPv6-Adresse-Format. Alle IPv4-Adressen müssen im Format IPv4-zugeordneten IPv6-Adresse dargestellt werden dadurch eine einzige IPv6-Anwendung für die Kommunikation mit einem IPv4-Knoten. Das IPv4-zugeordneten IPv6-Adresse-Format ermöglicht die IPv4-Adresse eine IPv4-Knoten als IPv6-Adresse dargestellt werden soll. Die IPv4-Adresse in das niederwertige 32 Bits der IPv6-Adresse codiert ist, und die höherwertigen-96-Bit halten die festen Präfix 0:0:0:0:0:FFFF. Das Format der IPv4-zugeordneten IPv6-Adresse ist in RFC 4291 genauer beschrieben angegeben. Weitere Informationen finden Sie unter [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6LinkLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6LinkLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6LinkLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6LinkLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6LinkLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6LinkLocal : bool" Usage="System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets whether the address is an IPv6 link local address.</summary>
        <value>
          <see langword="true" /> Wenn die IP-Adresse eine IPv6-Link lokale Adresse ist. andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Multicast">
      <MemberSignature Language="C#" Value="public bool IsIPv6Multicast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Multicast" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Multicast" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Multicast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Multicast { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6Multicast : bool" Usage="System.Net.IPAddress.IsIPv6Multicast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets whether the address is an IPv6 multicast global address.</summary>
        <value>
          <see langword="true" /> die IP-Adresse ist eine globale IPv6-Multicastadresse Adresse; andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6SiteLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6SiteLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6SiteLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6SiteLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6SiteLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6SiteLocal : bool" Usage="System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets whether the address is an IPv6 site local address.</summary>
        <value>
          <see langword="true" /> Wenn die IP-Adresse eine lokale IPv6-Website-Adresse ist. andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Teredo">
      <MemberSignature Language="C#" Value="public bool IsIPv6Teredo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Teredo" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Teredo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Teredo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Teredo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6Teredo : bool" Usage="System.Net.IPAddress.IsIPv6Teredo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets whether the address is an IPv6 Teredo address.</summary>
        <value>
          <see langword="true" /> Wenn die IP-Adresse eine IPv6-Teredo-Adresse ist. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Teredo-Adresse ist eine IPv6-Adresse mit dem Präfix 2001:: / 32. Teredo-Adressen können aufgelistet, die als eine IPv6-Adresse einer lokale Schnittstelle zugewiesen oder über die normale DNS-namensauflösung zurückgegeben werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.BeginGetUnicastAddresses(System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.EndGetUnicastAddresses(System.IAsyncResult)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.GetUnicastAddresses" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public static bool IsLoopback (System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLoopback(class System.Net.IPAddress address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.IsLoopback(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLoopback (address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLoopback(System::Net::IPAddress ^ address);" />
      <MemberSignature Language="F#" Value="static member IsLoopback : System.Net.IPAddress -&gt; bool" Usage="System.Net.IPAddress.IsLoopback address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="address">An IP address.</param>
        <summary>Indicates whether the specified IP address is the loopback address.</summary>
        <returns>
          <see langword="true" /> if <paramref name="address" /> is the loopback address; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress.IsLoopback%2A> Methode vergleicht `address` auf <xref:System.Net.IPAddress.Loopback> und gibt `true` , wenn die zwei IP-Adressen identisch sind.  
  
 Im Fall von IPv4, die die <xref:System.Net.IPAddress.IsLoopback%2A> -Methode zurückkehrt `true` für eine beliebige IP-Adresse des Formulars 127.X.Y.Z (wobei X, Y und Z im Bereich von 0 bis 255), nicht nur <xref:System.Net.IPAddress.Loopback> (127.0.0.1).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Net.IPAddress.IsLoopback%2A> Methode, um zu bestimmen, ob die angegebene Adresse einen Loopback-Adresse ist.  
  
 [!code-cpp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CPP/isloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CS/isloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/VB/isloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Loopback;" />
      <MemberSignature Language="F#" Value=" staticval mutable Loopback : System.Net.IPAddress" Usage="System.Net.IPAddress.Loopback" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides the IP loopback address. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress.Loopback> Feld entspricht 127.0.0.1 in Punktnotation.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Net.IPAddress.Loopback> Adresse, an die Konsole.  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#1)]
 [!code-csharp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#1)]
 [!code-vb[IPAddress_Broadcast_Loopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv4">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv4 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv4() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv4 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv4();" />
      <MemberSignature Language="F#" Value="member this.MapToIPv4 : unit -&gt; System.Net.IPAddress" Usage="iPAddress.MapToIPv4 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv4 address.</summary>
        <returns>Returns <see cref="T:System.Net.IPAddress" />.  An IPv4 address.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dual-Stack-Sockets erfordern immer, IPv6-Adressen. Die Möglichkeit für die Interaktion mit einer IPv4-Adresse erfordert die Verwendung von IPv4-zugeordneten IPv6-Adresse-Format. Alle IPv4-Adressen müssen im Format IPv4-zugeordneten IPv6-Adresse dargestellt werden dadurch eine einzige IPv6-Anwendung für die Kommunikation mit einem IPv4-Knoten. Das IPv4-zugeordneten IPv6-Adresse-Format ermöglicht die IPv4-Adresse eine IPv4-Knoten als IPv6-Adresse dargestellt werden soll. Die IPv4-Adresse in das niederwertige 32 Bits der IPv6-Adresse codiert ist, und die höherwertigen-96-Bit halten die festen Präfix 0:0:0:0:0:FFFF. Das Format der IPv4-zugeordneten IPv6-Adresse ist in RFC 4291 genauer beschrieben angegeben. Weitere Informationen finden Sie unter [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).  
  
 Wenn Sie verwenden möchten <xref:System.Net.IPAddress.MapToIPv4%2A> um eine IPv4-Adresse aus dem IPv6-Format in IPv4-Format zu konvertieren, zunächst müssen Sie sicherstellen, dass Sie eine IPv4-Adresse haben. Rufen Sie <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>, wodurch `true` ist die IP-Adresse ursprünglich IPv4, IPv6, geschrieben oder `false` andernfalls. Wenn <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> gibt `true`, verwenden Sie <xref:System.Net.IPAddress.MapToIPv4%2A> zur Umwandlung verwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv6">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv6 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv6() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv6 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv6();" />
      <MemberSignature Language="F#" Value="member this.MapToIPv6 : unit -&gt; System.Net.IPAddress" Usage="iPAddress.MapToIPv6 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv6 address.</summary>
        <returns>Returns <see cref="T:System.Net.IPAddress" />.  An IPv6 address.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dual-Stack-Sockets erfordern immer, IPv6-Adressen. Die Möglichkeit für die Interaktion mit einer IPv4-Adresse erfordert die Verwendung von IPv4-zugeordneten IPv6-Adresse-Format. Alle IPv4-Adressen müssen im Format IPv4-zugeordneten IPv6-Adresse dargestellt werden dadurch eine einzige IPv6-Anwendung für die Kommunikation mit einem IPv4-Knoten. Das IPv4-zugeordneten IPv6-Adresse-Format ermöglicht die IPv4-Adresse eine IPv4-Knoten als IPv6-Adresse dargestellt werden soll. Die IPv4-Adresse in das niederwertige 32 Bits der IPv6-Adresse codiert ist, und die höherwertigen-96-Bit halten die festen Präfix 0:0:0:0:0:FFFF. Das Format der IPv4-zugeordneten IPv6-Adresse ist in RFC 4291 genauer beschrieben angegeben. Weitere Informationen finden Sie unter [www.ietf.org/rfc/rfc4291.txt](http://go.microsoft.com/fwlink/?LinkID=92231).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="NetworkToHostOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts a number from network byte order to host byte order.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static short NetworkToHostOrder (short network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 NetworkToHostOrder(int16 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short NetworkToHostOrder(short network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int16 -&gt; int16" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="network">The number to convert, expressed in network byte order.</param>
        <summary>Converts a short value from network byte order to host byte order.</summary>
        <returns>A short value, expressed in host byte order.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unterschiedliche Computer verwenden unterschiedliche Konventionen für die Anordnung der Bytes in Ganzzahlwerten. Einige Computer platzieren zuerst das höchstwertige Byte (auch bekannt als big-Endian-Reihenfolge) und andere platzieren zuerst das unwichtigste Byte (bekannt als little-Endian-Reihenfolge). Zusammenarbeit mit Computern, die verschiedene Bytereihenfolge verwenden, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden in der netzwerkbyte-Reihenfolge gesendet, mit dem höchstwertigen Byte zuerst.  
  
 Die <xref:System.Net.IPAddress.NetworkToHostOrder%2A> Methode konvertiert Ganzzahlwerten, die auf dem Hostsystem aus der vom Netzwerk auf die Bytereihenfolge verwendet vom Host verwendete Bytereihenfolge gespeichert sind.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Net.IPAddress.NetworkToHostOrder%2A> Methode, um einem kurzen Wert aus der netzwerkbyte-Reihenfolge zu Host-Bytereihenfolge konvertieren.  
  
 [!code-cpp[IPAddress_NetworkToHost#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#1)]
 [!code-csharp[IPAddress_NetworkToHost#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#1)]
 [!code-vb[IPAddress_NetworkToHost#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static int NetworkToHostOrder (int network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NetworkToHostOrder(int32 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NetworkToHostOrder(int network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int -&gt; int" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="network">The number to convert, expressed in network byte order.</param>
        <summary>Converts an integer value from network byte order to host byte order.</summary>
        <returns>An integer value, expressed in host byte order.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unterschiedliche Computer verwenden unterschiedliche Konventionen für die Anordnung der Bytes in Ganzzahlwerten. Einige Computer platzieren zuerst das höchstwertige Byte (auch bekannt als big-Endian-Reihenfolge) und andere platzieren zuerst das unwichtigste Byte (bekannt als little-Endian-Reihenfolge). Zusammenarbeit mit Computern, die verschiedene Bytereihenfolge verwenden, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden in der netzwerkbyte-Reihenfolge gesendet, mit dem höchstwertigen Byte zuerst.  
  
 Die <xref:System.Net.IPAddress.NetworkToHostOrder%2A> Methode konvertiert Ganzzahlwerten, die auf dem Hostsystem aus der vom Netzwerk auf die Bytereihenfolge verwendet vom Host verwendete Bytereihenfolge gespeichert sind.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Net.IPAddress.NetworkToHostOrder%2A> Methode, um einen ganzzahligen Wert von netzwerkbyte-Reihenfolge in die Host-Bytereihenfolge konvertieren.  
  
 [!code-cpp[IPAddress_NetworkToHost#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#2)]
 [!code-csharp[IPAddress_NetworkToHost#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#2)]
 [!code-vb[IPAddress_NetworkToHost#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static long NetworkToHostOrder (long network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 NetworkToHostOrder(int64 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long NetworkToHostOrder(long network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int64 -&gt; int64" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="network">The number to convert, expressed in network byte order.</param>
        <summary>Converts a long value from network byte order to host byte order.</summary>
        <returns>A long value, expressed in host byte order.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unterschiedliche Computer verwenden unterschiedliche Konventionen für die Anordnung der Bytes in Ganzzahlwerten. Einige Computer platzieren zuerst das höchstwertige Byte (auch bekannt als big-Endian-Reihenfolge) und andere platzieren zuerst das unwichtigste Byte (bekannt als little-Endian-Reihenfolge). Zusammenarbeit mit Computern, die verschiedene Bytereihenfolge verwenden, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden in der netzwerkbyte-Reihenfolge gesendet, mit dem höchstwertigen Byte zuerst.  
  
 Die <xref:System.Net.IPAddress.NetworkToHostOrder%2A> Methode konvertiert Ganzzahlwerten, die auf dem Hostsystem aus der vom Netzwerk auf die Bytereihenfolge verwendet vom Host verwendete Bytereihenfolge gespeichert sind.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Net.IPAddress.NetworkToHostOrder%2A> Methode, um einen long-Wert von netzwerkbyte-Reihenfolge zu Host-Bytereihenfolge konvertieren.  
  
 [!code-cpp[IPAddress_NetworkToHost#3](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#3)]
 [!code-csharp[IPAddress_NetworkToHost#3](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#3)]
 [!code-vb[IPAddress_NetworkToHost#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ None;" />
      <MemberSignature Language="F#" Value=" staticval mutable None : System.Net.IPAddress" Usage="System.Net.IPAddress.None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides an IP address that indicates that no network interface should be used. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> -Methode verwendet die <xref:System.Net.IPAddress.None> Feld an, dass eine <xref:System.Net.Sockets.Socket> Clientaktivität muss nicht abhören. Die <xref:System.Net.IPAddress.None> Feld entspricht 255.255.255.255 in Punktnotation.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Net.IPAddress.None> Eigenschaft, um anzugeben, dass keine Netzwerkschnittstelle verwendet werden soll.  
  
 [!code-cpp[IPAddress_None#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_None/CPP/ipaddress_none.cpp#1)]
 [!code-csharp[IPAddress_None#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_None/CS/ipaddress_none.cs#1)]
 [!code-vb[IPAddress_None#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_None/VB/ipaddress_none.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As ReadOnlySpan(Of Char)) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; -&gt; System.Net.IPAddress" Usage="System.Net.IPAddress.Parse ipString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (string ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(string ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As String) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(System::String ^ ipString);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Net.IPAddress" Usage="System.Net.IPAddress.Parse ipString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ipString">A string that contains an IP address in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</param>
        <summary>Converts an IP address string to an <see cref="T:System.Net.IPAddress" /> instance.</summary>
        <returns>An <see cref="T:System.Net.IPAddress" /> instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statische <xref:System.Net.IPAddress.Parse%2A> Methode erstellt eine <xref:System.Net.IPAddress> -Instanz anhand einer IP-Adresse in Punktnotation für IPv4 und in Hexadezimalschreibweise für IPv6.  
  
 Die Anzahl der Teile (jedes Teil wird durch einen Punkt getrennt) im `ipString` bestimmt, wie die IP-Adresse erstellt wird. Eine Adresse ein Teil ist direkt im Adressraum Netzwerks gespeichert. Eine Adresse mit zwei Teilen, praktisch für die Angabe einer Adresse Klasse A setzt das führende Teil in das erste Byte und der nachstehende Teil in der am weitesten rechts drei Bytes der Netzwerkadresse an. Eine dreiteilige Adresse praktisch für die Angabe einer Adresse Klasse B setzt den ersten Teil in das erste Byte, der zweite Teil im zweiten Byte und dem letzten Abschnitt in der zwei Byte ganz rechts die Netzwerkadresse an. Zum Beispiel:  
  
|Anzahl der Teile und Beispiel `ipString`|IPv4-Adresse für die IP-Adresse|  
|--------------------------------------------|--------------------------------|  
|1 -- "65535"|0.0.255.255|  
|2 -- "20.2"|20.0.0.2|  
|2 -- "20.65535"|20.0.255.255|  
|3 -- "128.1.2"|128.1.0.2|  
  
   
  
## Examples  
 Der folgende Code konvertiert eine Zeichenfolge, die eine IP-Adresse in Punktnotation für IPv4- oder in Hexadezimalschreibweise für IPv6 in eine Instanz von enthält die <xref:System.Net.IPAddress> Klasse. Anschließend wird die überladene <xref:System.Net.IPAddress.ToString%2A> Methode, um die Adresse in der Standardschreibweise anzuzeigen.  
  
 [!code-cpp[System.Net.IPAddress.Parse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CPP/parse.cpp#1)]
 [!code-csharp[System.Net.IPAddress.Parse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CS/parse.cs#1)]
 [!code-vb[System.Net.IPAddress.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.Parse/VB/parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ipString" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="ipString" /> is not a valid IP address.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeId">
      <MemberSignature Language="C#" Value="public long ScopeId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ScopeId" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.ScopeId" />
      <MemberSignature Language="VB.NET" Value="Public Property ScopeId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ScopeId { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ScopeId : int64 with get, set" Usage="System.Net.IPAddress.ScopeId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the IPv6 address scope identifier.</summary>
        <value>Eine lange ganze Zahl, die den Bereich der Adresse angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Bedeutung der <xref:System.Net.IPAddress.ScopeId%2A> ändert sich je nach Kontext, in dem er verwendet wird.  
  
-   Verbindungslokale Adresse. Auf einem Host mit mehreren Schnittstellen, die mit separaten Links verbunden sind kann die gleiche verbindungslokale Adresse mehrere Schnittstellen zugewiesen werden. Um diese Mehrdeutigkeit zu vermeiden, wird ein Bereichsbezeichner verwendet, an die Schnittstelle, über der Nachrichten ausgetauscht werden.  
  
> [!NOTE]
>  Verbindungslokalen Adressen, die durch das Format Prefix (FP) FE80 angegebene, werden von Knoten verwendet, bei der Kommunikation mit benachbarte Knoten auf derselben Verbindung.  
  
-   Standortlokale Adressen. Ein Host kann mit mehreren Standorten verbunden werden. In diesem Fall wird ein Bereichsbezeichner verwendet, um anzugeben, für die Kommunikation mit einen bestimmten Standort.  
  
> [!NOTE]
>  Standortlokale Adressen, die durch die FEC0 Format Prefix (FP) identifiziert werden von Knoten verwendet, bei der Kommunikation auf private Intranets.  
  
 Die Notation, die verwendet wird, an die `ScopeId` ist mit der Adresse `Address%ScopeId`. Beispiel: `FE80::5EFE:192.168.41.30%2.`  
  
   
  
## Examples  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <see langword="AddressFamily" /> = <see langword="InterNetwork" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="scopeId" /> &lt; 0  \- or -  -   <paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="iPAddress.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts an Internet address to its standard notation.</summary>
        <returns>A string that contains the IP address in either IPv4 dotted-quad or in IPv6 colon-hexadecimal notation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress.ToString%2A> -Methode konvertiert die IP-Adresse, die in gespeichert ist die <xref:System.Net.IPAddress.Address%2A> Eigenschaft, um IPv4 gepunktet Quad- oder IPv6 bei der hexadezimalen Schreibweise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> and the address is bad.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryFormat(System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryFormat(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  -&gt; bool" Usage="iPAddress.TryFormat (destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.ReadOnlySpan{System.Char},System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As ReadOnlySpan(Of Char), ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Net.IPAddress.TryParse (ipString, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="address" Type="System.Net.IPAddress&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.String,System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As String, ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Net.IPAddress.TryParse (ipString, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
        <Parameter Name="address" Type="System.Net.IPAddress&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ipString">The string to validate.</param>
        <param name="address">The <see cref="T:System.Net.IPAddress" /> version of the string.</param>
        <summary>Determines whether a string is a valid IP address.</summary>
        <returns>
          <see langword="true" /> if <paramref name="ipString" /> was able to be parsed as an IP address; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass diese Methode als gültigen einen IpString Wert akzeptiert, die als analysiert werden kann ein <xref:System.Int64>, und klicken Sie dann, Int64 behandelt, als eine IP-Adresse im Netzwerk Bytereihenfolge, ähnlich wie bei der long-Wert, der <xref:System.Net.IPAddress.%23ctor%2A> Konstruktor verfügt. Dies bedeutet, dass diese Methode "true", wenn der Int64-Wert rückkonvertiert werden kann, gibt auch wenn es sich um eine Adresse darstellt, die nicht auf eine gültige IP-Adresse ist. Z. B. wenn IpString "1" ist, gibt diese Methode "true", obwohl "1" (oder 0.0.0.1) ist nicht auf eine gültige IP-Adresse ein, und Sie diese Methode erwarten können "false" zurückgibt. Beheben diesen Fehler wird die vorhandene apps unterbrochen werden, damit das aktuelle Verhalten nicht geändert werden. Code kann dieses Verhalten vermeiden, indem Sie sicherstellen, dass sie nur diese Methode verwendet, um IP-Adressen in punktierter Dezimalschreibweise zu analysieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryWriteBytes(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteBytes(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  -&gt; bool" Usage="iPAddress.TryWriteBytes (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>