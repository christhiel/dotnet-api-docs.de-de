<Type Name="Extensions" FullName="System.Xml.XPath.Extensions">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a3f783e188261854d0c471aa40cc9edbb59d5841" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30720804" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Extensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Extensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XPath.Extensions" />
  <TypeSignature Language="VB.NET" Value="Public Module Extensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class Extensions abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Diese Klasse enthält die LINQ to XML-Erweiterungsmethoden zum Auswerten von XPath-Ausdrücken.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt einige Leistungseinbußen für die Verwendung dieser Methoden. Mithilfe von [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] Abfragen, führt zu einer besseren Leistung.  
  
 Obwohl die Reihenfolge der zurückgegebenen Auflistungen in XPath-Sprache 1.0-Empfehlung für XML nicht angegeben ist, gibt diese Erweiterungsmethode Knoten in Dokumentreihenfolge zurück.  
  
 Beachten Sie, dass die Knoten in Dokumentreihenfolge zurückgegeben werden, selbst wenn Sie eine rückwärtsgerichtete Achse, z. B. verwenden `preceding-sibling` oder `ancestor-or-self`.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateNavigator">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen <see cref="T:System.Xml.XPath.XPathNavigator" /> für einen <see cref="T:System.Xml.Linq.XNode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die XML-Struktur kann nicht bearbeitet werden, mithilfe der <xref:System.Xml.XPath.XPathNavigator> , die von dieser Methode zurückgegeben wird. Die <xref:System.Xml.XPath.XPathNavigator.CanEdit%2A>-Eigenschaft gibt `false` zurück.  
  
 Sie können nicht erstellt werden ein <xref:System.Xml.XPath.XPathNavigator> für eine <xref:System.Xml.Linq.XDocumentType> Knoten. Dokumenttypen XPath-Datenmodell nicht teilnehmen.  
  
 Namespace-Deklarationen werden von links nach rechts gemeldet. Im Gegensatz dazu werden bei <xref:System.Xml.XmlDocument> Namespaces werden von rechts nach links gemeldet. Dies ist die konforme Verhalten, da Namespacedeklarationen im XPath-Datenmodell nicht sortiert werden.  
  
 Die Methode <xref:System.Xml.XPath.XPathNavigator.MoveToId%2A> wird nicht unterstützt für Navigatoren, die von dieser Methode zurückgegeben werden.  
  
 Sie können diese Methode zum Ausführen einer XSLT-Transformations verwenden. Sie können eine XML-Struktur erstellen, erstellen Sie ein <xref:System.Xml.XPath.XPathNavigator> aus der XML-Struktur erstellen Sie ein neues Dokument erstellen und eine <xref:System.Xml.XmlWriter> , der in das neue Dokument schreibt. Anschließend können Sie die XSLT-Transformation aufrufen und den <xref:System.Xml.XPath.XPathNavigator> sowie den <xref:System.Xml.XmlWriter> an die Transformation übergeben. Nach erfolgreichem Abschluss der Transformation wird die neue XML-Struktur mit den Ergebnissen der Transformation aufgefüllt.  
  
 Zum Ausführen einer XSLT-Transformations verwenden Sie entweder eine <xref:System.Xml.XmlReader> oder ein <xref:System.Xml.XPath.XPathNavigator>. Beide Ansätze sind unterschiedlichen Leistungsmerkmalen. Manche Transformationen werden schneller ausgeführt, bei Verwendung eine <xref:System.Xml.XmlReader>, und anderen werden schneller ausgeführt, bei Verwendung einer <xref:System.Xml.XPath.XPathNavigator>. Wenn die Leistung eine wichtige Überlegung ist, wird empfohlen, dass Sie experimentieren mit jeder Ansatz, um zu bestimmen, die in Ihre Situation eine bessere Leistung wird.  
  
```csharp  
  
            string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1><xsl:value-of select='Child1'/></C1>  
            <C2><xsl:value-of select='Child2'/></C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
  
            Dim xslMarkup As XDocument = <?xml version='1.0'?>  
                             <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
                                 <xsl:template match='/Parent'>  
                                     <Root>  
                                         <C1><xsl:value-of select='Child1'/></C1>  
                                         <C2><xsl:value-of select='Child2'/></C2>  
                                     </Root>  
                                 </xsl:template>  
                             </xsl:stylesheet>  
  
Dim xmlTree As XDocument = <?xml version='1.0'?>  
                           <Parent>  
                               <Child1>Child1 data</Child1>  
                               <Child2>Child2 data</Child2>  
                           </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```xml  
  
            <Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public static System.Xml.XPath.XPathNavigator CreateNavigator (this System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.CreateNavigator(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateNavigator (node As XNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::Linq::XNode ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
      </Parameters>
      <Docs>
        <param name="node">Ein <see cref="T:System.Xml.Linq.XNode" />, der XPath-Abfragen verarbeiten kann.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XPath.XPathNavigator" /> für einen <see cref="T:System.Xml.Linq.XNode" />.</summary>
        <returns>Ein <see cref="T:System.Xml.XPath.XPathNavigator" />, der XPath-Abfragen verarbeiten kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die XML-Struktur kann nicht bearbeitet werden, mithilfe der <xref:System.Xml.XPath.XPathNavigator> , die von dieser Methode zurückgegeben wird. Die <xref:System.Xml.XPath.XPathNavigator.CanEdit%2A>-Eigenschaft gibt `false` zurück.  
  
 Sie können nicht erstellt werden ein <xref:System.Xml.XPath.XPathNavigator> für eine <xref:System.Xml.Linq.XDocumentType> Knoten. Dokumenttypen XPath-Datenmodell nicht teilnehmen.  
  
 Namespace-Deklarationen werden von links nach rechts gemeldet. Im Gegensatz dazu werden bei <xref:System.Xml.XmlDocument> Namespaces werden von rechts nach links gemeldet. Dies ist die konforme Verhalten, da Namespacedeklarationen im XPath-Datenmodell nicht sortiert werden.  
  
 Die Methode <xref:System.Xml.XPath.XPathNavigator.MoveToId%2A> wird nicht unterstützt für Navigatoren, die von dieser Methode zurückgegeben werden.  
  
 Sie können diese Methode zum Ausführen einer XSLT-Transformations verwenden. Sie können eine XML-Struktur erstellen, erstellen Sie ein <xref:System.Xml.XPath.XPathNavigator> aus der XML-Struktur erstellen Sie ein neues Dokument erstellen und eine <xref:System.Xml.XmlWriter> , der in das neue Dokument schreibt. Anschließend können Sie die XSLT-Transformation übergeben von Aufrufen der <xref:System.Xml.XPath.XPathNavigator> und <xref:System.Xml.XmlWriter> für die Transformation. Nach erfolgreichem Abschluss der Transformation wird die neue XML-Struktur mit den Ergebnissen der Transformation aufgefüllt.  
  
 Zum Ausführen einer XSLT-Transformations verwenden Sie entweder eine <xref:System.Xml.XmlReader> oder ein <xref:System.Xml.XPath.XPathNavigator>. Beide Ansätze sind unterschiedlichen Leistungsmerkmalen. Manche Transformationen werden schneller ausgeführt, bei Verwendung eine <xref:System.Xml.XmlReader>, und anderen werden schneller ausgeführt, bei Verwendung einer <xref:System.Xml.XPath.XPathNavigator>. Wenn die Leistung eine wichtige Überlegung ist, wird empfohlen, dass Sie experimentieren mit jeder Ansatz, um zu bestimmen, die in Ihre Situation eine bessere Leistung wird.  
  
   
  
## Examples  
  
```csharp  
  
                string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1><xsl:value-of select='Child1'/></C1>  
            <C2><xsl:value-of select='Child2'/></C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
  
                Dim xslMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
        <xsl:template match='/Parent'>  
            <Root>  
                <C1><xsl:value-of select='Child1'/></C1>  
                <C2><xsl:value-of select='Child2'/></C2>  
            </Root>  
        </xsl:template>  
    </xsl:stylesheet>  
  
Dim xmlTree As XDocument = _  
    <?xml version='1.0'?>  
    <Parent>  
        <Child1>Child1 data</Child1>  
        <Child2>Child2 data</Child2>  
    </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```xml  
  
                <Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public static System.Xml.XPath.XPathNavigator CreateNavigator (this System.Xml.Linq.XNode node, System.Xml.XmlNameTable nameTable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.Linq.XNode node, class System.Xml.XmlNameTable nameTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.CreateNavigator(System.Xml.Linq.XNode,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateNavigator (node As XNode, nameTable As XmlNameTable) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::Linq::XNode ^ node, System::Xml::XmlNameTable ^ nameTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="nameTable" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="node">Ein <see cref="T:System.Xml.Linq.XNode" />, der eine XPath-Abfrage verarbeiten kann.</param>
        <param name="nameTable">Eine <see cref="T:System.Xml.XmlNameTable" />, die vom <see cref="T:System.Xml.XPath.XPathNavigator" /> verwendet werden soll.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XPath.XPathNavigator" /> für einen <see cref="T:System.Xml.Linq.XNode" />. Die <see cref="T:System.Xml.XmlNameTable" /> ermöglicht eine effizientere Verarbeitung von XPath-Ausdrücken.</summary>
        <returns>Ein <see cref="T:System.Xml.XPath.XPathNavigator" />, der XPath-Abfragen verarbeiten kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können nicht bearbeitet, die XML-Struktur mit den <xref:System.Xml.XPath.XPathNavigator> , die von dieser Methode zurückgegeben wird. Die <xref:System.Xml.XPath.XPathNavigator.CanEdit%2A>-Eigenschaft gibt `false` zurück.  
  
 Sie können nicht erstellt werden ein <xref:System.Xml.XPath.XPathNavigator> für eine <xref:System.Xml.Linq.XDocumentType> Knoten. Dokumenttypen XPath-Datenmodell nicht teilnehmen.  
  
 Namespace-Deklarationen werden von links nach rechts gemeldet. Im Gegensatz dazu werden bei <xref:System.Xml.XmlDocument> Namespaces werden von rechts nach links gemeldet. Dies ist die konforme Verhalten, da Namespacedeklarationen im XPath-Datenmodell nicht sortiert werden.  
  
 Die Methode <xref:System.Xml.XPath.XPathNavigator.MoveToId%2A> wird nicht unterstützt für Navigatoren, die von dieser Methode zurückgegeben werden.  
  
 Bei Verwendung einer <xref:System.Xml.XmlNameTable> mit dieser Methode zum Erstellen der <xref:System.Xml.XPath.XPathNavigator>, erhalten Sie eine bessere Leistung beim Auswerten von XPath-Ausdrücken.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathEvaluate">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wertet einen XPath-Ausdruck aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl die Reihenfolge der zurückgegebenen Auflistungen in XPath-Sprache 1.0-Empfehlung für XML nicht angegeben ist, gibt diese Erweiterungsmethode Knoten in Dokumentreihenfolge zurück.  
  
 Beachten Sie, dass die Knoten in Dokumentreihenfolge zurückgegeben werden, selbst wenn Sie eine rückwärtsgerichtete Achse, z. B. verwenden `preceding-sibling` oder `ancestor-or-self`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathEvaluate">
      <MemberSignature Language="C#" Value="public static object XPathEvaluate (this System.Xml.Linq.XNode node, string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object XPathEvaluate(class System.Xml.Linq.XNode node, string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathEvaluate(System.Xml.Linq.XNode,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathEvaluate (node As XNode, expression As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Object ^ XPathEvaluate(System::Xml::Linq::XNode ^ node, System::String ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Xml.Linq.XNode" />, in dem der XPath-Ausdruck ausgewertet wird.</param>
        <param name="expression">Ein <see cref="T:System.String" />, der einen XPath-Ausdruck enthält.</param>
        <summary>Wertet einen XPath-Ausdruck aus.</summary>
        <returns>Ein Objekt, das einen <see langword="bool" />, einen <see langword="double" />, einen <see langword="string" /> oder einen <see cref="T:System.Collections.Generic.IEnumerable`1" /> enthalten kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Auflistung eine Enumeration von Elementen oder Attributen ist, können Sie mithilfe der `Cast` Operator, um eine Auflistung abzurufen <xref:System.Xml.Linq.XElement> oder <xref:System.Xml.Linq.XAttribute>.  
  
 Obwohl die Reihenfolge der zurückgegebenen Auflistungen in XPath-Sprache 1.0-Empfehlung für XML nicht angegeben ist, gibt diese Erweiterungsmethode Knoten in Dokumentreihenfolge zurück.  
  
 Beachten Sie, dass die Knoten in Dokumentreihenfolge zurückgegeben werden, selbst wenn Sie eine rückwärtsgerichtete Achse, z. B. verwenden `preceding-sibling` oder `ancestor-or-self`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine kleine XML-Struktur mit einem Attribut und dann verwendet die <xref:System.Xml.XPath.Extensions.XPathEvaluate%2A> Methode, um das Attribut abzurufen.  
  
```csharp  
  
                String xml = "<root a='value'/>";  
XDocument d = XDocument.Parse(xml);  
IEnumerable att = (IEnumerable)d.XPathEvaluate("/root/@a");  
Console.WriteLine(att.Cast<XAttribute>().FirstOrDefault());  
```  
  
```vb  
  
                Dim d As XDocument = _  
    <?xml version='1.0'?>  
    <root a='value'/>  
Dim att As IEnumerable = CType(d.XPathEvaluate("/root/@a"), IEnumerable)  
Console.WriteLine(att.Cast(Of XAttribute)().FirstOrDefault())  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
a="value"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XPathEvaluate">
      <MemberSignature Language="C#" Value="public static object XPathEvaluate (this System.Xml.Linq.XNode node, string expression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object XPathEvaluate(class System.Xml.Linq.XNode node, string expression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathEvaluate(System.Xml.Linq.XNode,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathEvaluate (node As XNode, expression As String, resolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Object ^ XPathEvaluate(System::Xml::Linq::XNode ^ node, System::String ^ expression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Xml.Linq.XNode" />, in dem der XPath-Ausdruck ausgewertet wird.</param>
        <param name="expression">Ein <see cref="T:System.String" />, der einen XPath-Ausdruck enthält.</param>
        <param name="resolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" /> für die Namespacepräfixe im XPath-Ausdruck.</param>
        <summary>Wertet einen XPath-Ausdruck aus und löst Namespacepräfixe mit dem angegebenen <see cref="T:System.Xml.IXmlNamespaceResolver" /> auf.</summary>
        <returns>Ein Objekt, das das Ergebnis aus der Auswertung des Ausdrucks enthält. Das Objekt kann ein <see langword="bool" />, ein <see langword="double" />, ein <see langword="string" /> oder ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> sein.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, zum Auswerten von XPath-Ausdrücken, die Namespacepräfixe enthalten.  
  
 Obwohl die Reihenfolge der zurückgegebenen Auflistungen in XPath-Sprache 1.0-Empfehlung für XML nicht angegeben ist, gibt diese Erweiterungsmethode Knoten in Dokumentreihenfolge zurück.  
  
 Beachten Sie, dass die Knoten in Dokumentreihenfolge zurückgegeben werden, selbst wenn Sie eine rückwärtsgerichtete Achse, z. B. verwenden `preceding-sibling` oder `ancestor-or-self`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine XML-Struktur, die einen Namespace enthält. Zum Lesen des XML-Dokuments kommt dabei ein <xref:System.Xml.XmlReader> zum Einsatz. Anschließend werden eine <xref:System.Xml.XmlNameTable> aus dem <xref:System.Xml.XmlReader> und ein <xref:System.Xml.XmlNamespaceManager> aus der <xref:System.Xml.XmlNameTable> abgerufen. Er verwendet die <xref:System.Xml.XmlNamespaceManager> bei der Auswahl eines Elements.  
  
```csharp  
  
                string markup =  
@"<aw:Root xmlns:aw='http://www.adventure-works.com'>  
    <aw:Child1 aw:Att='attdata'>child one data 1</aw:Child1>  
</aw:Root>";  
XmlReader reader = XmlReader.Create(new StringReader(markup));  
XElement root = XElement.Load(reader);  
XmlNameTable nameTable = reader.NameTable;  
XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nameTable);  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com");  
IEnumerable atts = (IEnumerable)root.XPathEvaluate("./aw:Child1/@aw:Att", namespaceManager);  
IEnumerable<XAttribute> attList = atts.Cast<XAttribute>();  
XAttribute att = attList.First();  
Console.WriteLine(att);  
```  
  
```vb  
  
                Dim markup As XElement = _  
    <aw:Root xmlns:aw='http://www.adventure-works.com'>  
        <aw:Child1 aw:Att='attdata'>child one data 1</aw:Child1>  
    </aw:Root>  
Dim reader As XmlReader = markup.CreateReader  
Dim nameTable As XmlNameTable = reader.NameTable  
Dim namespaceManager As XmlNamespaceManager = New XmlNamespaceManager(nameTable)  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com")  
Dim atts As IEnumerable = CType(markup.XPathEvaluate("./aw:Child1/@aw:Att", namespaceManager), IEnumerable)  
Dim attList As IEnumerable(Of XAttribute) = atts.Cast(Of XAttribute)()  
Dim att As XAttribute = attList.First()  
Console.WriteLine(att)  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
aw:Att="attdata"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathSelectElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wählt mithilfe eines XPath-Ausdrucks ein <see cref="T:System.Xml.Linq.XElement" /> aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathSelectElement">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement XPathSelectElement (this System.Xml.Linq.XNode node, string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement XPathSelectElement(class System.Xml.Linq.XNode node, string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElement(System.Xml.Linq.XNode,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElement (node As XNode, expression As String) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Linq::XElement ^ XPathSelectElement(System::Xml::Linq::XNode ^ node, System::String ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Xml.Linq.XNode" />, in dem der XPath-Ausdruck ausgewertet wird.</param>
        <param name="expression">Ein <see cref="T:System.String" />, der einen XPath-Ausdruck enthält.</param>
        <summary>Wählt mithilfe eines XPath-Ausdrucks ein <see cref="T:System.Xml.Linq.XElement" /> aus.</summary>
        <returns>Ein <see cref="T:System.Xml.Linq.XElement" /> oder NULL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine kleine XML-Struktur und verwendet <xref:System.Xml.XPath.Extensions.XPathSelectElement%2A> um ein einzelnes Element auszuwählen.  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
XElement el = root.XPathSelectElement("./Child4");  
Console.WriteLine(el);  
```  
  
```vb  
  
                Dim root As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <Child3>3</Child3>  
        <Child4>4</Child4>  
        <Child5>5</Child5>  
        <Child6>6</Child6>  
    </Root>  
Dim el As XElement = root.XPathSelectElement("./Child4")  
Console.WriteLine(el)  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<Child4>4</Child4>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XPathSelectElement">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement XPathSelectElement (this System.Xml.Linq.XNode node, string expression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement XPathSelectElement(class System.Xml.Linq.XNode node, string expression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElement(System.Xml.Linq.XNode,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElement (node As XNode, expression As String, resolver As IXmlNamespaceResolver) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Linq::XElement ^ XPathSelectElement(System::Xml::Linq::XNode ^ node, System::String ^ expression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Xml.Linq.XNode" />, in dem der XPath-Ausdruck ausgewertet wird.</param>
        <param name="expression">Ein <see cref="T:System.String" />, der einen XPath-Ausdruck enthält.</param>
        <param name="resolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" /> für die Namespacepräfixe im XPath-Ausdruck.</param>
        <summary>Wählt mithilfe eines XPath-Ausdrucks ein <see cref="T:System.Xml.Linq.XElement" /> aus und löst Namespacepräfixe mit dem angegebenen <see cref="T:System.Xml.IXmlNamespaceResolver" /> auf.</summary>
        <returns>Ein <see cref="T:System.Xml.Linq.XElement" /> oder NULL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, zum Auswerten von XPath-Ausdrücken, die Namespacepräfixe enthalten.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine XML-Struktur, die einen Namespace enthält. Zum Lesen des XML-Dokuments kommt dabei ein <xref:System.Xml.XmlReader> zum Einsatz. Anschließend werden eine <xref:System.Xml.XmlNameTable> aus dem <xref:System.Xml.XmlReader> und ein <xref:System.Xml.XmlNamespaceManager> aus der <xref:System.Xml.XmlNameTable> abgerufen. Er verwendet die <xref:System.Xml.XmlNamespaceManager> bei der Auswahl eines Elements.  
  
```csharp  
  
                string markup = @"  
<aw:Root xmlns:aw='http://www.adventure-works.com'>  
    <aw:Child1>child one data</aw:Child1>  
    <aw:Child2>child two data</aw:Child2>  
</aw:Root>";  
XmlReader reader = XmlReader.Create(new StringReader(markup));  
XElement root = XElement.Load(reader);  
XmlNameTable nameTable = reader.NameTable;  
XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nameTable);  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com");  
XElement child1 = root.XPathSelectElement("./aw:Child1", namespaceManager);  
Console.WriteLine(child1);  
```  
  
```vb  
  
                Dim markup As XElement = _  
    <aw:Root xmlns:aw='http://www.adventure-works.com'>  
        <aw:Child1>child one data</aw:Child1>  
        <aw:Child2>child two data</aw:Child2>  
    </aw:Root>  
Dim reader As XmlReader = markup.CreateReader  
Dim nameTable As XmlNameTable = reader.NameTable  
Dim namespaceManager As XmlNamespaceManager = New XmlNamespaceManager(nameTable)  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com")  
Dim child1 As XElement = markup.XPathSelectElement("./aw:Child1", namespaceManager)  
Console.WriteLine(child1)  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data</aw:Child1>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathSelectElements">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wählt mithilfe eines XPath-Ausdrucks eine Auflistung von Elementen aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl die Reihenfolge der zurückgegebenen Auflistungen in XPath-Sprache 1.0-Empfehlung für XML nicht angegeben ist, gibt diese Erweiterungsmethode Knoten in Dokumentreihenfolge zurück.  
  
 Beachten Sie, dass die Knoten in Dokumentreihenfolge zurückgegeben werden, selbst wenn Sie eine rückwärtsgerichtete Achse, z. B. verwenden `preceding-sibling` oder `ancestor-or-self`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathSelectElements">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; XPathSelectElements (this System.Xml.Linq.XNode node, string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; XPathSelectElements(class System.Xml.Linq.XNode node, string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElements(System.Xml.Linq.XNode,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElements (node As XNode, expression As String) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ XPathSelectElements(System::Xml::Linq::XNode ^ node, System::String ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Xml.Linq.XNode" />, in dem der XPath-Ausdruck ausgewertet wird.</param>
        <param name="expression">Ein <see cref="T:System.String" />, der einen XPath-Ausdruck enthält.</param>
        <summary>Wählt mithilfe eines XPath-Ausdrucks eine Auflistung von Elementen aus.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> vom Typ <see cref="T:System.Xml.Linq.XElement" />, die die ausgewählten Elemente enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl die Reihenfolge der zurückgegebenen Auflistungen in XPath-Sprache 1.0-Empfehlung für XML nicht angegeben ist, gibt diese Erweiterungsmethode Knoten in Dokumentreihenfolge zurück.  
  
 Beachten Sie, dass die Knoten in Dokumentreihenfolge zurückgegeben werden, selbst wenn Sie eine rückwärtsgerichtete Achse, z. B. verwenden `preceding-sibling` oder `ancestor-or-self`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine kleine XML-Struktur und verwendet zum Auswählen eines Satzes von Elementen <xref:System.Xml.XPath.Extensions.XPathSelectElements%2A>.  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child1", 2),  
    new XElement("Child1", 3),  
    new XElement("Child2", 4),  
    new XElement("Child2", 5),  
    new XElement("Child2", 6)  
);  
IEnumerable<XElement> list = root.XPathSelectElements("./Child2");  
foreach (XElement el in list)  
    Console.WriteLine(el);  
```  
  
```vb  
  
                Dim root As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child1>2</Child1>  
        <Child1>3</Child1>  
        <Child2>4</Child2>  
        <Child2>5</Child2>  
        <Child2>6</Child2>  
    </Root>  
Dim list As IEnumerable(Of XElement) = root.XPathSelectElements("./Child2")  
For Each el As XElement In list  
    Console.WriteLine(el)  
Next  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<Child2>4</Child2>  
<Child2>5</Child2>  
<Child2>6</Child2>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XPathSelectElements">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; XPathSelectElements (this System.Xml.Linq.XNode node, string expression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; XPathSelectElements(class System.Xml.Linq.XNode node, string expression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElements(System.Xml.Linq.XNode,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElements (node As XNode, expression As String, resolver As IXmlNamespaceResolver) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ XPathSelectElements(System::Xml::Linq::XNode ^ node, System::String ^ expression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Xml.Linq.XNode" />, in dem der XPath-Ausdruck ausgewertet wird.</param>
        <param name="expression">Ein <see cref="T:System.String" />, der einen XPath-Ausdruck enthält.</param>
        <param name="resolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" /> für die Namespacepräfixe im XPath-Ausdruck.</param>
        <summary>Wählt mithilfe eines XPath-Ausdrucks eine Auflistung von Elementen aus und löst Namespacepräfixe mit dem angegebenen <see cref="T:System.Xml.IXmlNamespaceResolver" /> auf.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> vom Typ <see cref="T:System.Xml.Linq.XElement" />, die die ausgewählten Elemente enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, zum Auswerten von XPath-Ausdrücken, die Namespacepräfixe enthalten.  
  
 Obwohl die Reihenfolge der zurückgegebenen Auflistungen in XPath-Sprache 1.0-Empfehlung für XML nicht angegeben ist, gibt diese Erweiterungsmethode Knoten in Dokumentreihenfolge zurück.  
  
 Beachten Sie, dass die Knoten in Dokumentreihenfolge zurückgegeben werden, selbst wenn Sie eine rückwärtsgerichtete Achse, z. B. verwenden `preceding-sibling` oder `ancestor-or-self`.  
  
   
  
## Examples  
 Dieses Beispiel erstellt eine XML-Struktur, die einen Namespace enthält. Zum Lesen des XML-Dokuments kommt dabei ein <xref:System.Xml.XmlReader> zum Einsatz. Anschließend werden eine <xref:System.Xml.XmlNameTable> aus dem <xref:System.Xml.XmlReader> und ein <xref:System.Xml.XmlNamespaceManager> aus der <xref:System.Xml.XmlNameTable> abgerufen. Er verwendet die <xref:System.Xml.XmlNamespaceManager> , wenn die Liste der Elemente auswählen.  
  
```csharp  
  
                string markup = @"  
<aw:Root xmlns:aw='http://www.adventure-works.com'>  
    <aw:Child1>child one data 1</aw:Child1>  
    <aw:Child1>child one data 2</aw:Child1>  
    <aw:Child1>child one data 3</aw:Child1>  
    <aw:Child2>child two data 4</aw:Child2>  
    <aw:Child2>child two data 5</aw:Child2>  
    <aw:Child2>child two data 6</aw:Child2>  
</aw:Root>";  
XmlReader reader = XmlReader.Create(new StringReader(markup));  
XElement root = XElement.Load(reader);  
XmlNameTable nameTable = reader.NameTable;  
XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nameTable);  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com");  
IEnumerable<XElement> elements = root.XPathSelectElements("./aw:Child1", namespaceManager);  
foreach (XElement el in elements)  
    Console.WriteLine(el);  
```  
  
```vb  
  
                Dim markup As XElement = _  
<aw:Root xmlns:aw="http://www.adventure-works.com">  
    <aw:Child1>child one data 1</aw:Child1>  
    <aw:Child1>child one data 2</aw:Child1>  
    <aw:Child1>child one data 3</aw:Child1>  
    <aw:Child2>child two data 4</aw:Child2>  
    <aw:Child2>child two data 5</aw:Child2>  
    <aw:Child2>child two data 6</aw:Child2>  
</aw:Root>  
Dim reader As XmlReader = markup.CreateReader  
Dim nameTable As XmlNameTable = reader.NameTable  
Dim namespaceManager As XmlNamespaceManager = New XmlNamespaceManager(nameTable)  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com")  
Dim elements As IEnumerable(Of XElement) = markup.XPathSelectElements("./aw:Child1", namespaceManager)  
For Each el As XElement In elements  
    Console.WriteLine(el)  
Next  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data 1</aw:Child1>  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data 2</aw:Child1>  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data 3</aw:Child1>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>