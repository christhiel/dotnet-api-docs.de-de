<Type Name="ManipulationStartingEventArgs" FullName="System.Windows.Input.ManipulationStartingEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c60b6a2041ac7eae42976352f607961787413725" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39991664" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ManipulationStartingEventArgs : System.Windows.Input.InputEventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ManipulationStartingEventArgs extends System.Windows.Input.InputEventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.ManipulationStartingEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ManipulationStartingEventArgs&#xA;Inherits InputEventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class ManipulationStartingEventArgs sealed : System::Windows::Input::InputEventArgs" />
  <TypeSignature Language="F#" Value="type ManipulationStartingEventArgs = class&#xA;    inherit InputEventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Input.InputEventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Daten für das <see cref="E:System.Windows.UIElement.ManipulationStarting" />-Ereignis bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.ManipulationStartingEventArgs> ermöglichen es Ihnen, die das Verhalten einer Bearbeitung anzugeben.  Verwenden der <xref:System.Windows.Input.ManipulationStartingEventArgs> die folgenden Schritte ausführen:  
  
-   Gibt an, dass die Position relativ zu einem Element, durch Festlegen sein soll der <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A> Eigenschaft.  
  
-   Gibt an, ob die Bearbeitung mit einem Finger sind aktiviert, indem die <xref:System.Windows.Input.ManipulationStartingEventArgs.IsSingleTouchEnabled%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Angeben, welche Typen von Bearbeitung aktiviert sind, durch Festlegen der <xref:System.Windows.Input.ManipulationStartingEventArgs.Mode%2A?displayProperty=nameWithType> Eigenschaft, um eine <xref:System.Windows.Input.ManipulationModes> Enumeration.  
  
-   Geben Sie den Mittelpunkt einer Rotation einem Finger durch Festlegen der <xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Die Bearbeitung abbrechen, indem die <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A?displayProperty=nameWithType> Eigenschaft `true`.  
  
 Weitere Informationen zu Manipulationen, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  Ein Beispiel für eine Anwendung, die auf Manipulationen reagiert, finden Sie unter [Exemplarische Vorgehensweise: der ersten Fingereingabeanwendung erstellen](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public bool Cancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Cancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.ManipulationStartingEventArgs.Cancel" />
      <MemberSignature Language="VB.NET" Value="Public Function Cancel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Cancel();" />
      <MemberSignature Language="F#" Value="member this.Cancel : unit -&gt; bool" Usage="manipulationStartingEventArgs.Cancel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht die Manipulation ab und stuft Fingereingaben zu Mausereignissen herauf.</summary>
        <returns>
          <see langword="true" />, wenn die Fingereingaben erfolgreich zu Mausereignissen erweitert wurden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Methode erfolgreich ist, der Standardwert <xref:System.Windows.Input.TouchDevice> sendet vorherigen touch down-Ereignissen als Ereignisse bei gedrückter Maustaste, und zukünftige Manipulationsereignisse treten nicht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected override void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.ManipulationStartingEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="manipulationStartingEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">To be added.</param>
        <param name="genericTarget">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleTouchEnabled">
      <MemberSignature Language="C#" Value="public bool IsSingleTouchEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleTouchEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ManipulationStartingEventArgs.IsSingleTouchEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsSingleTouchEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSingleTouchEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleTouchEnabled : bool with get, set" Usage="System.Windows.Input.ManipulationStartingEventArgs.IsSingleTouchEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob eine Manipulation mit einem Finger gestartet werden kann.</summary>
        <value>
          <see langword="true" />: eine Manipulation kann mit einem Finger gestartet werden; andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Manipulationen, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  Ein Beispiel für eine Anwendung, die auf Manipulationen reagiert, finden Sie unter [Exemplarische Vorgehensweise: der ersten Fingereingabeanwendung erstellen](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationContainer">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement ManipulationContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement ManipulationContainer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer" />
      <MemberSignature Language="VB.NET" Value="Public Property ManipulationContainer As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ ManipulationContainer { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ManipulationContainer : System.Windows.IInputElement with get, set" Usage="System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Container ab, zu dem alle Manipulationsereignisse und Berechnungen relativ sind, oder legt ihn fest.</summary>
        <value>Der Container, zu dem alle Manipulationsereignisse und Berechnungen relativ sind. Der Standardwert ist das Element, bei dem das Ereignis aufgetreten ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können angeben, dass die Position relativ zu einem anderen Element, durch Festlegen sein soll der <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A> Eigenschaft. Beispielsweise können Sie die Manipulationspositionen bezogen auf das übergeordnete Element des Elements vornehmen, die die Manipulation-Ereignisse empfängt. Die <xref:System.Windows.UIElement.ManipulationStarting> -Ereignishandler ist der einzige Ort, in dem Sie festlegen können, die <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>.  
  
 Weitere Informationen zu Manipulationen, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  Ein Beispiel für eine Anwendung, die auf Manipulationen reagiert, finden Sie unter [Exemplarische Vorgehensweise: der ersten Fingereingabeanwendung erstellen](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Manipulators">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.IManipulator&gt; Manipulators { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.IManipulator&gt; Manipulators" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ManipulationStartingEventArgs.Manipulators" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Manipulators As IEnumerable(Of IManipulator)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::IManipulator ^&gt; ^ Manipulators { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::IManipulator ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Manipulators : seq&lt;System.Windows.Input.IManipulator&gt;" Usage="System.Windows.Input.ManipulationStartingEventArgs.Manipulators" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.IManipulator&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Objekten ab, die die Fingereingabekontakte für die Manipulation darstellt.</summary>
        <value>Eine Auflistung von Objekten, die die Fingereingabekontakte für die Manipulation darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Mode">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ManipulationModes Mode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Input.ManipulationModes Mode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ManipulationStartingEventArgs.Mode" />
      <MemberSignature Language="VB.NET" Value="Public Property Mode As ManipulationModes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ManipulationModes Mode { System::Windows::Input::ManipulationModes get(); void set(System::Windows::Input::ManipulationModes value); };" />
      <MemberSignature Language="F#" Value="member this.Mode : System.Windows.Input.ManipulationModes with get, set" Usage="System.Windows.Input.ManipulationStartingEventArgs.Mode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ManipulationModes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, welche Typen von Manipulationen möglich sind.</summary>
        <value>Einer der Enumerationswerte. Der Standardwert ist <see cref="F:System.Windows.Input.ManipulationModes.All" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Manipulationen, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  Ein Beispiel für eine Anwendung, die auf Manipulationen reagiert, finden Sie unter [Exemplarische Vorgehensweise: der ersten Fingereingabeanwendung erstellen](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eigenschaft wird auf einen anderen Wert als einen oder mehrere der <see cref="T:System.Windows.Input.ManipulationModes" />-Enumerationswerte festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pivot">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ManipulationPivot Pivot { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ManipulationPivot Pivot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ManipulationStartingEventArgs.Pivot" />
      <MemberSignature Language="VB.NET" Value="Public Property Pivot As ManipulationPivot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ManipulationPivot ^ Pivot { System::Windows::Input::ManipulationPivot ^ get(); void set(System::Windows::Input::ManipulationPivot ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Pivot : System.Windows.Input.ManipulationPivot with get, set" Usage="System.Windows.Input.ManipulationStartingEventArgs.Pivot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ManipulationPivot</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, das das Pivot für eine Einpunktmanipulation beschreibt, oder legt es fest.</summary>
        <value>Ein Objekt, das das Pivot für eine Einpunktmanipulation beschreibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Festlegen der <xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A> -Eigenschaft, die Bearbeitung enthält Drehung Daten, wenn der Benutzer einen Finger während der Bearbeitung verwendet.  Dies ist, um reale Situationen zu simulieren, in dem Sie einen Finger zum Drehen eines Objekts, z. B. ein Blatt Papier für eine Tabelle verwenden können.  Wenn die <xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A> ist `null`, der Benutzer muss zwei Finger verwendet, um die dazu führen, dass bei der Drehung.  
  
 Weitere Informationen zu Manipulationen, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  Ein Beispiel für eine Anwendung, die auf Manipulationen reagiert, finden Sie unter [Exemplarische Vorgehensweise: der ersten Fingereingabeanwendung erstellen](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einen Ereignishandler für die <xref:System.Windows.UIElement.ManipulationStarting> Ereignis- und legt die <xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A?displayProperty=nameWithType> Eigenschaft. Um dieses Beispiel zu testen, führen Sie die Schritte in [Exemplarische Vorgehensweise: der ersten Fingereingabeanwendung erstellen](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md) und Ersetzen Sie den Code in Schritt 4 durch den folgenden Code.  
  
 [!code-csharp[BasicManipulation#ManipulationPivot](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/reportboundaryfeedbackexample.xaml.cs#manipulationpivot)]
 [!code-vb[BasicManipulation#ManipulationPivot](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/reportboundaryfeedbackexample.xaml.vb#manipulationpivot)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetManipulationParameter">
      <MemberSignature Language="C#" Value="public void SetManipulationParameter (System.Windows.Input.Manipulations.ManipulationParameters2D parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetManipulationParameter(class System.Windows.Input.Manipulations.ManipulationParameters2D parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.ManipulationStartingEventArgs.SetManipulationParameter(System.Windows.Input.Manipulations.ManipulationParameters2D)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetManipulationParameter (parameter As ManipulationParameters2D)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetManipulationParameter(System::Windows::Input::Manipulations::ManipulationParameters2D ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.SetManipulationParameter : System.Windows.Input.Manipulations.ManipulationParameters2D -&gt; unit" Usage="manipulationStartingEventArgs.SetManipulationParameter parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Windows.Input.Manipulations.ManipulationParameters2D" />
      </Parameters>
      <Docs>
        <param name="parameter">Der Parameter, der hinzugefügt werden soll.</param>
        <summary>Fügt der aktuellen Manipulation des angegebenen Elements Parameter hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie in der Regel müssen nicht diese Methode aufrufen.  Verwenden Sie die Eigenschaften auf der <xref:System.Windows.Input.ManipulationStartingEventArgs> stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>