<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5d16038f88fec2c25538ccb923d037ef8e8246bb" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53229414" /></Metadata><TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Der Typ der Elemente in der Liste.</typeparam>
    <summary>Stellt eine stark typisierte Liste von Objekten dar, auf die über einen Index zugegriffen werden kann. Stellt Methoden zum Durchsuchen, Sortieren und Bearbeiten von Listen bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> Klasse ist die generische Entsprechung, der die <xref:System.Collections.ArrayList> Klasse. Implementiert die <xref:System.Collections.Generic.IList%601> generische Schnittstelle unter Verwendung eines Arrays, dessen dynamisch als vergrößert wird, erforderlich.  
  
 Sie können Elemente zum Hinzufügen einer <xref:System.Collections.Generic.List%601> mithilfe der <xref:System.Collections.Generic.List%601.Add%2A> oder <xref:System.Collections.Generic.List%601.AddRange%2A> Methoden.  
  
 Die <xref:System.Collections.Generic.List%601> Klasse verwendet werden, sowohl einen Gleichheitsvergleich als auch einen reihenfolgenvergleich.  
  
-   Methoden, z. B. <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, und <xref:System.Collections.Generic.Dictionary%602.Remove%2A> verwenden eine gleichheitsvergleichsfunktion für die Listenelemente. Der Standardgleichheitsvergleich für den Typ `T` wird wie folgt bestimmt. Wenn Typ `T` implementiert die <xref:System.IEquatable%601> generische Schnittstelle, dann ist der Gleichheitsvergleich die <xref:System.IEquatable%601.Equals%28%600%29> -Methode der Schnittstelle; andernfalls ist die der Standardgleichheitsvergleich <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.  
  
-   Methoden, z. B. <xref:System.Collections.Generic.List%601.BinarySearch%2A> und <xref:System.Collections.Generic.List%601.Sort%2A> verwenden einen reihenfolgenvergleich für die Listenelemente. Der Standardvergleich für den Typ `T` wird wie folgt bestimmt.  Wenn Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle, und klicken Sie dann auf die standardmäßige Vergleichsfunktion ist die <xref:System.IComparable%601.CompareTo%28%600%29> -Methode dieser Schnittstelle; andernfalls, wenn Typ `T` implementiert die nicht generische <xref:System.IComparable> -Schnittstelle, und klicken Sie dann auf die Standardeinstellung Vergleich der <xref:System.IComparable.CompareTo%28System.Object%29> -Methode dieser Schnittstelle. Wenn Typ `T` weder-Schnittstelle implementiert, gibt es keinen Standardvergleich, und ein Vergleich oder ein Vergleichsdelegat muss explizit angegeben werden.  
  
 Die <xref:System.Collections.Generic.List%601> ist nicht unbedingt sortiert werden.  Sie sortieren, müssen die <xref:System.Collections.Generic.List%601> vor dem Ausführen von Vorgängen (z. B. <xref:System.Collections.Generic.List%601.BinarySearch%2A>), erfordern die <xref:System.Collections.Generic.List%601> sortiert werden soll.  
  
 Elemente in dieser Auflistung können über einen Ganzzahlenindex zugegriffen werden.  Indizes in dieser Auflistung sind nullbasiert.  
  
 Für sehr große <xref:System.Collections.Generic.List%601> Objekte aufweist, können Sie die maximale Kapazität 2 Milliarden von Elementen auf einem 64-Bit-System erhöhen, durch Festlegen der `enabled` Attribut des Konfigurationselements, `true` in der Runtime-Umgebung.  
  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültiger Wert für den Verweis und doppelte Elemente lässt.  
  
 Für eine unveränderliche Version des der <xref:System.Collections.Generic.List%601> Klasse, finden Sie unter <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Bei der Entscheidung, ob Sie verwenden die <xref:System.Collections.Generic.List%601> oder <xref:System.Collections.ArrayList> -Klasse, die jeweils eine ähnliche Funktionalität, beachten Sie, dass die <xref:System.Collections.Generic.List%601> Klasse bietet eine bessere Leistung in den meisten Fällen und typsicher. Wenn ein Verweistyp, für den Typ verwendet wird `T` von der <xref:System.Collections.Generic.List%601> -Klasse, die das Verhalten der beiden Klassen ist identisch. Aber wenn ein Werttyp, für den Typ verwendet wird `T`, Implementierung und Boxing Probleme berücksichtigt werden müssen.  
  
 Wenn für den Typ ein Werttyps verwendet wird `T`, generiert der Compiler eine Implementierung der <xref:System.Collections.Generic.List%601> -Klasse speziell für dieses Werttyps. Das bedeutet, dass ein Listenelement der einem <xref:System.Collections.Generic.List%601> Objekt muss nicht geschachtelt werden, bevor das Element verwendet werden kann, und der Speicher gespeichert, nicht boxing Listenelemente ist größer als der Arbeitsspeicher verwendet, um die Implementierung der Klasse zu generieren, nach etwa 500 Listenelemente erstellt werden.  
  
 Stellen Sie sicher den Werttyp, der zum Typ `T` implementiert die <xref:System.IEquatable%601> generische Schnittstelle. Wenn nicht der Fall, Methoden, z. B. <xref:System.Collections.Generic.List%601.Contains%2A> aufrufen, müssen die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> -Methode, die das Listenelement der betroffenen Felder. Wenn der Typ implementiert die <xref:System.IComparable> Schnittstelle, und Sie besitzen, den Quellcode, implementieren Sie zusätzlich die <xref:System.IComparable%601> generische Schnittstelle, um zu verhindern, dass die <xref:System.Collections.Generic.List%601.BinarySearch%2A> und <xref:System.Collections.Generic.List%601.Sort%2A> Methoden Listenelemente schachteln. Wenn Sie nicht über den Quellcode besitzen, übergeben Sie ein <xref:System.Collections.Generic.IComparer%601> -Objekt an die <xref:System.Collections.Generic.List%601.BinarySearch%2A> und <xref:System.Collections.Generic.List%601.Sort%2A> Methoden  
  
 Es ist von Vorteil, verwenden Sie die Typ-spezifische Implementierung von der <xref:System.Collections.Generic.List%601> Klasse anstelle der <xref:System.Collections.ArrayList> Klasse oder eine Auflistung von stark typisierten Wrapper selbst schreiben. Der Grund ist die Implementierung müssen .NET Framework bereits für Sie ausführt und die common Language Runtime Microsoft intermediate Language-Code und Metadaten, die Ihre Implementierung nicht freigeben.  
  
## <a name="f-considerations"></a>F#Überlegungen zur  
 Die <xref:System.Collections.Generic.List%601> Klasse dient nur selten in F# Code.  Stattdessen [listet](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), die unveränderlichen, einfach verknüpften Listen, sind in der Regel bevorzugte sind. Ein F# Liste stellt eine geordnete, unveränderliche Reihe von Werten und wird für die Verwendung in funktionale-Entwicklung unterstützt. Bei der Verwendung von F#, <xref:System.Collections.Generic.List%601> Klasse in der Regel verweist auf die [ResizeArray\<' t >](https://msdn.microsoft.com/library/ee353447.aspx) -typabkürzung vermeiden Namenskonflikte mit F# werden aufgelistet  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie hinzufügen, entfernen, und fügen Sie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Das folgende Beispiel zeigt verschiedene Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generische Klasse vom Typzeichenfolge. (Ein Beispiel für eine <xref:System.Collections.Generic.List%601> komplexen Typen finden Sie unter den <xref:System.Collections.Generic.List%601.Contains%2A> Methode.)  
  
 Der Standardkonstruktor wird verwendet, um eine Liste von Zeichenfolgen mit der angegebenen Kapazität erstellen. Die <xref:System.Collections.Generic.List%601.Capacity%2A> -Eigenschaft wird angezeigt, und klicken Sie dann die <xref:System.Collections.Generic.List%601.Add%2A> Methode wird verwendet, um mehrere Elemente hinzuzufügen. Die Elemente aufgeführt, und die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft angezeigt wird in diesem Fall zusammen mit den <xref:System.Collections.Generic.List%601.Count%2A> -Eigenschaft, um anzugeben, dass die Kapazität nach Bedarf erhöht wurde.  
  
 Die <xref:System.Collections.Generic.List%601.Contains%2A> Methode dient zum Testen auf das Vorhandensein eines Elements in der Liste der <xref:System.Collections.Generic.List%601.Insert%2A> Methode dient zum Einfügen eines neuen Elements in der Mitte der Liste aus, und der Inhalt der Liste erneut angezeigt werden.  
  
 Der Standardwert <xref:System.Collections.Generic.List%601.Item%2A> -Eigenschaft (Indexer in c#) Dient zum Abrufen eines Elements, das <xref:System.Collections.Generic.List%601.Remove%2A> Methode wird verwendet, um die erste Instanz des zuvor hinzugefügten doppelten Elements entfernt werden soll, und der Inhalt wird erneut angezeigt. Die <xref:System.Collections.Generic.List%601.Remove%2A> Methode wird immer der erste gefundene Instanz entfernt.  
  
 Die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode wird verwendet, um die Kapazität entsprechend der Anzahl die zu reduzieren und die <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften werden angezeigt. Wenn der freie Kapazität kleiner als 10 Prozent der Gesamtkapazität hätte, würde die Größe die Liste nicht geändert wurde.  
  
 Zum Schluss die <xref:System.Collections.Generic.List%601.Clear%2A> Methode dient zum Entfernen aller Elemente aus der Liste aus, und die <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften werden angezeigt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Es ist sicherer, für mehrere Lesevorgänge Ausführen einer <see cref="T:System.Collections.Generic.List`1" />, aber es können Probleme auftreten, wenn die Auflistung geändert wird, während es gelesen wird. Um Threadsicherheit zu gewährleisten, Sperren Sie die Auflistung während eines Lesevorgangs, oder Schreiben Sie beim. Damit kann eine Sammlung von mehreren Threads zum Lesen und Schreiben zugegriffen werden, müssen Sie eine eigene Synchronisierung implementieren. Sammlungen mit integrierten Synchronisierung, finden Sie unter den Klassen in der <see cref="N:System.Collections.Concurrent" /> Namespace. Eine Alternative grundsätzlich threadsicher, finden Sie unter den <see cref="T:System.Collections.Immutable.ImmutableList`1" /> Klasse.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Iteratoren (C# und Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse, die die Standardanfangskapazität aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.List%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.List%601> enthalten kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Generic.List%601>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung mithilfe geschätzt werden kann, die <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> Konstruktor und die anfängliche Kapazität angeben entfällt die Notwendigkeit, eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen, die zum Ausführen der <xref:System.Collections.Generic.List%601>.  
  
 Die Kapazität kann verringert werden, durch den Aufruf der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode oder durch Festlegen der <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft explizit. Verringern der Kapazität Arbeitsspeicher zuordnet, und kopiert alle Elemente in der <xref:System.Collections.Generic.List%601>.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Standardkonstruktor der <xref:System.Collections.Generic.List%601> generische Klasse. Der Standardkonstruktor erstellt eine Liste mit der Standardkapazität ein, wie durch Anzeigen der <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft.  
  
 Im Beispiel hinzufügt, fügt ein und entfernt die Elemente, die angezeigt wird, wie die Kapazität ändert, da diese Methoden verwendet werden.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, deren Elemente in die neue Liste kopiert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse, die aus der angegebenen Auflistung kopierte Elemente enthält und eine ausreichende Kapazität für die Anzahl der kopierten Elemente aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente kopiert werden, auf die <xref:System.Collections.Generic.List%601> in der gleichen Reihenfolge, die sie vom Enumerator der Auflistung gelesen werden.  
  
 Dieser Konstruktor ist eine O (*n*)-Vorgang, in denen *n* ist die Anzahl der Elemente im `collection`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.%23ctor%2A> Konstruktor und die verschiedenen Methoden der <xref:System.Collections.Generic.List%601> -Klasse, die für Bereiche verwendet. Ein Array von Zeichenfolgen erstellt und an den Konstruktor übergeben, Auffüllen der Liste mit den Elementen des Arrays. Die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird dann angezeigt, um anzugeben, dass die anfängliche Kapazität genau erforderlich ist, um den Eingabeelementen enthalten.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die Anzahl von Elementen, die anfänglich in der neuen Liste gespeichert werden können.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse, die die angegebene Anfangskapazität aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.List%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.List%601> enthalten kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Generic.List%601>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben müssen nicht mehr eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen, die zum Ausführen der <xref:System.Collections.Generic.List%601>.  
  
 Die Kapazität kann verringert werden, durch den Aufruf der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode oder durch Festlegen der <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft explizit. Verringern der Kapazität Arbeitsspeicher zuordnet, und kopiert alle Elemente in der <xref:System.Collections.Generic.List%601>.  
  
 Dieser Konstruktor ist eine O (*n*)-Vorgang, in denen *n* ist `capacity`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> Konstruktor. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen mit einer Kapazität von 4, wird erstellt, da die endgültige Größe der Liste der bekannt ist, genau 4. Die Liste wird mit vier Zeichenfolgen aufgefüllt und eine schreibgeschützte Kopie erstellt, mit der <xref:System.Collections.Generic.List%601.AsReadOnly%2A> Methode.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das Objekt, das am Ende der <see cref="T:System.Collections.Generic.List`1" /> hinzugefügt werden soll. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt am Ende der <see cref="T:System.Collections.Generic.List`1" /> ein Objekt hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültiger Wert für den Verweis und doppelte Elemente lässt.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> bereits entspricht <xref:System.Collections.Generic.List%601.Capacity%2A>, wird die Kapazität von der <xref:System.Collections.Generic.List%601> wird erhöht, die automatisch erneut zugewiesen werden, das interne Array, und die vorhandenen Elemente in das neue Array kopiert werden, bevor das neue Element hinzugefügt wird.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> ist kleiner als <xref:System.Collections.Generic.List%601.Capacity%2A>, diese Methode ist ein o(1)-Vorgang. Wenn die Kapazität für das neue Element erhöht werden muss, wird diese Methode eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie hinzufügen, entfernen, und fügen Sie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Das folgende Beispiel zeigt verschiedene Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generische Klasse erstellen, einschließlich der <xref:System.Collections.Generic.List%601.Add%2A> Methode. Der Standardkonstruktor wird verwendet, um eine Liste von Zeichenfolgen mit einer Kapazität von 0 zu erstellen. Die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird angezeigt, und klicken Sie dann die <xref:System.Collections.Generic.List%601.Add%2A> Methode wird verwendet, um mehrere Elemente hinzuzufügen. Die Elemente aufgeführt, und die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft angezeigt wird in diesem Fall zusammen mit den <xref:System.Collections.Generic.List%601.Count%2A> -Eigenschaft, um anzugeben, dass die Kapazität nach Bedarf erhöht wurde.  
  
 Andere Eigenschaften und Methoden werden verwendet, um suchen, einfügen und Entfernen von Elementen aus der Liste aus, und schließlich auf die Liste zu löschen.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, deren Elemente am Ende der <see cref="T:System.Collections.Generic.List`1" /> hinzugefügt werden sollen. Die Auflistung an sich kann nicht <see langword="null" /> sein, sie kann jedoch Elemente enthalten, die <see langword="null" /> sind, wenn Typ <paramref name="T" /> einen Referenztyp darstellt.</param>
        <summary>Fügt die Elemente der angegebenen Auflistung am Ende von <see cref="T:System.Collections.Generic.List`1" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Elemente in der Auflistung wird beibehalten, der <xref:System.Collections.Generic.List%601>.  
  
 Wenn die neue <xref:System.Collections.Generic.List%601.Count%2A> (die aktuelle <xref:System.Collections.Generic.List%601.Count%2A> plus die Größe der Auflistung) wird größer sein als <xref:System.Collections.Generic.List%601.Capacity%2A>, die der Kapazität der <xref:System.Collections.Generic.List%601> wird erhöht, die automatisch erneut zugewiesen werden, das interne Array zur Aufnahme der neuen Elemente, und die vorhandene Elemente werden in das neue Array kopiert, bevor die neuen Elemente hinzugefügt werden.  
  
 Wenn die <xref:System.Collections.Generic.List%601> die neuen Elemente aufnehmen kann, ohne zu erhöhen die <xref:System.Collections.Generic.List%601.Capacity%2A>, diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist die Anzahl der Elemente, die hinzugefügt werden. Wenn die Kapazität erhöht werden, damit die neuen Elemente aufnehmen muss, wird diese Methode eine O (*n* + *m*)-Vorgang, in denen *n* ist die Anzahl von Elementen hinzuzufügende und *m* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.AddRange%2A> -Methode und verschiedene weitere Methoden, die von der <xref:System.Collections.Generic.List%601> -Klasse, die für Bereiche verwendet. Ein Array von Zeichenfolgen erstellt und an den Konstruktor übergeben, Auffüllen der Liste mit den Elementen des Arrays. Die <xref:System.Collections.Generic.List%601.AddRange%2A> -Methode aufgerufen wird, mit der Liste als Argument. Das Ergebnis ist, dass das aktuelle Element der Liste am Ende der Liste, duplizieren alle Elemente hinzugefügt werden.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen schreibgeschützten <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />-Wrapper für die aktuelle Auflistung zurück.</summary>
        <returns>Ein Objekt, das als schreibgeschützter Wrapper des aktuellen <see cref="T:System.Collections.Generic.List`1" />-Objekts fungiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu verhindern, dass alle Änderungen an der <xref:System.Collections.Generic.List%601> Objekt, das sie nur über diesen Wrapper verfügbar zu machen. Ein <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> Objekt macht Methoden, die die Auflistung geändert werden. Aber wenn Änderungen, auf die zugrunde liegende vorgenommen werden <xref:System.Collections.Generic.List%601> Objekt ist, wird die schreibgeschützte Auflistung die Änderungen wider.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.AsReadOnly%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen mit einer Kapazität von 4, wird erstellt, da die endgültige Größe der Liste der bekannt ist, genau 4. Die Liste wird mit vier Zeichenfolgen aufgefüllt und die <xref:System.Collections.Generic.List%601.AsReadOnly%2A> Methode dient zum Abrufen einer nur-Lese- <xref:System.Collections.Generic.IList%601> Implementierung der generischen Schnittstelle, die die ursprüngliche Liste umschließt.  
  
 Ein Element von der ursprünglichen Liste wird festgelegt, dass "Coelophysis" mit der <xref:System.Collections.Generic.List%601.Item%2A> -Eigenschaft (Indexer in c#), und die Inhalte der schreibgeschützten Liste erneut um zu zeigen, dass es nur ein Wrapper für die ursprüngliche Liste ist angezeigt werden.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verwendet einen binären Suchalgorithmus für die Suche nach einem bestimmten Element bzw. einen Teil dieses Elements in der sortierten <see cref="T:System.Collections.Generic.List`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Durchsucht mithilfe des Standardcomparers die gesamte sortierte <see cref="T:System.Collections.Generic.List`1" /> nach einem Element und gibt den nullbasierten Index des Elements zurück.</summary>
        <returns>Der nullbasierte Index von <paramref name="item" /> in der sortierten <see cref="T:System.Collections.Generic.List`1" />, sofern <paramref name="item" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="item" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> für Typ `T` bestimmt die Reihenfolge der Listenelemente. Die <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> -Eigenschaft überprüft, ob der Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle und verwendet Sie, dass diese Implementierung, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable> Schnittstelle.  Wenn Typ `T` implementiert nicht die beiden Schnittstellen, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> löst eine <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Collections.Generic.List%601> muss bereits sortiert werden, entsprechend die Vergleichs-Implementierung; das Ergebnis ist, andernfalls falsch.  
  
 Vergleichen von `null` mit jeder Verweis ist zulässig und löst keine Ausnahme aus, bei Verwendung der <xref:System.IComparable%601> generische Schnittstelle. Beim Sortieren von `null` gilt als kleiner als jedes andere Objekt.  
  
 Wenn die <xref:System.Collections.Generic.List%601> enthält mehr als ein Element mit dem gleichen Wert, gibt die Methode nur einen vorkommen und eine vorkommen, nicht notwendigerweise das erste Element zurückgeben kann.  
  
 Wenn die <xref:System.Collections.Generic.List%601> enthält nicht den angegebenen Wert die Methode gibt eine negative ganze Zahl zurück. Sie können die bitweisen komplementären Vorgangs (~) auf diese negative ganze Zahl, um den Index des ersten Elements zu erhalten, die größer als der Wert für die Suche anwenden. Beim Einfügen des Werts in der <xref:System.Collections.Generic.List%601>, diesen Index als die Einfügemarke verwendet werden soll, um die Sortierreihenfolge zu verwalten.  
  
 Diese Methode ist eine O (Log *n*)-Vorgang, in denen *n* ist die Anzahl der Elemente im Bereich.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Sort> -methodenüberladung, und die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> -methodenüberladung. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit vier Zeichenfolgen, in keiner bestimmten Reihenfolge aufgefüllt. Die Liste wird angezeigt, sortiert und erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> methodenüberladung wird dann verwendet, um die für zwei Zeichenfolgen zu suchen, die nicht in der Liste enthalten sind und die <xref:System.Collections.Generic.List%601.Insert%2A> Methode verwendet, um sie einzufügen. Der Rückgabewert von der <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Methode ist in jedem Fall negativ, da die Zeichenfolgen nicht in der Liste enthalten sind. Dem bitweisen Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) dieses negative Zahl wird der Index des ersten Elements in der Liste, die größer als die zu suchende Zeichenfolge und Einfügen von an dieser Stelle ist beibehalten der Sortierreihenfolge die Reihenfolge. Die zweite Zeichenfolge für die Suche ist größer als ein Element in der Liste, daher ist die Position der Einfügemarke am Ende der Liste.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann keine Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> finden.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder -  
 <see langword="null" /> zur Verwendung des Standardcomparers <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Durchsucht mithilfe des angegebenen Comparers die gesamte sortierte <see cref="T:System.Collections.Generic.List`1" /> nach einem Element und gibt den nullbasierten Index des Elements zurück.</summary>
        <returns>Der nullbasierte Index von <paramref name="item" /> in der sortierten <see cref="T:System.Collections.Generic.List`1" />, sofern <paramref name="item" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="item" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich wird bestimmt, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer> -Instanz wie der Vergleich, der Suche nach Groß-/Kleinschreibung von Zeichenfolgen durchführen.  
  
 Wenn `comparer` angegeben ist, wird die Elemente der <xref:System.Collections.Generic.List%601> verglichen werden, auf den angegebenen Wert unter Verwendung des angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung.  
  
 Wenn `comparer` ist `null`, die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle und verwendet Sie, dass diese Implementierung, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable> Schnittstelle.  Wenn Typ `T` implementiert nicht die beiden Schnittstellen, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> löst <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Collections.Generic.List%601> muss bereits sortiert werden, entsprechend die Vergleichs-Implementierung; das Ergebnis ist, andernfalls falsch.  
  
 Vergleichen von `null` mit jeder Verweis ist zulässig und löst keine Ausnahme aus, bei Verwendung der <xref:System.IComparable%601> generische Schnittstelle. Beim Sortieren von `null` gilt als kleiner als jedes andere Objekt.  
  
 Wenn die <xref:System.Collections.Generic.List%601> enthält mehr als ein Element mit dem gleichen Wert, gibt die Methode nur einen vorkommen und eine vorkommen, nicht notwendigerweise das erste Element zurückgeben kann.  
  
 Wenn die <xref:System.Collections.Generic.List%601> enthält nicht den angegebenen Wert die Methode gibt eine negative ganze Zahl zurück. Sie können die bitweisen komplementären Vorgangs (~) auf diese negative ganze Zahl, um den Index des ersten Elements zu erhalten, die größer als der Wert für die Suche anwenden. Beim Einfügen des Werts in der <xref:System.Collections.Generic.List%601>, diesen Index als die Einfügemarke verwendet werden soll, um die Sortierreihenfolge zu verwalten.  
  
 Diese Methode ist eine O (Log *n*)-Vorgang, in denen *n* ist die Anzahl der Elemente im Bereich.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> -methodenüberladung, und die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> -methodenüberladung.  
  
 Im Beispiel wird einen alternativen Vergleich für DinoCompare implementiert-Zeichenfolgen definiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich funktioniert wie folgt aus: Zunächst werden die zu vergleichenden Objekte für getestet `null`, und als kleiner als ein Wert ungleich Null ein null-Verweis behandelt wird. Zweitens: die Länge der Zeichenfolge verglichen werden und größer sein als die längere Zeichenfolge angesehen wird. Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit vier Zeichenfolgen, in keiner bestimmten Reihenfolge aufgefüllt. Die Liste ist, mit dem alternativen Vergleich sortiert und angezeigten erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> methodenüberladung wird dann verwendet, um die für mehrere Zeichenfolgen zu suchen, die nicht in der Liste der alternativen Vergleich anwenden. Die <xref:System.Collections.Generic.List%601.Insert%2A> Methode verwendet, um die Zeichenfolgen einzufügen. Diese beiden Methoden befinden sich in der Funktion, die mit dem Namen `SearchAndInsert`, zusammen mit Code, das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) der die negative Zahl, die vom <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> und verwenden sie als Index für Einfügen der neuen Zeichenfolge an.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann keine Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> finden.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des zu durchsuchenden Bereichs.</param>
        <param name="count">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="item">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, wenn der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> verwendet werden soll.</param>
        <summary>Durchsucht mithilfe des angegebenen Vergleichs einen Bereich von Elementen in der sortierten <see cref="T:System.Collections.Generic.List`1" /> nach einem Element und gibt den nullbasierten Index des Elements zurück.</summary>
        <returns>Der nullbasierte Index von <paramref name="item" /> in der sortierten <see cref="T:System.Collections.Generic.List`1" />, sofern <paramref name="item" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="item" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich wird bestimmt, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer> -Instanz wie der Vergleich, der Suche nach Groß-/Kleinschreibung von Zeichenfolgen durchführen.  
  
 Wenn `comparer` angegeben ist, wird die Elemente der <xref:System.Collections.Generic.List%601> verglichen werden, auf den angegebenen Wert unter Verwendung des angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung.  
  
 Wenn `comparer` ist `null`, die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle und verwendet Sie, dass diese Implementierung, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable> Schnittstelle.  Wenn Typ `T` implementiert nicht die beiden Schnittstellen, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> löst <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Collections.Generic.List%601> muss bereits sortiert werden, entsprechend die Vergleichs-Implementierung; das Ergebnis ist, andernfalls falsch.  
  
 Vergleichen von `null` mit jeder Verweis ist zulässig und löst keine Ausnahme aus, bei Verwendung der <xref:System.IComparable%601> generische Schnittstelle. Beim Sortieren von `null` gilt als kleiner als jedes andere Objekt.  
  
 Wenn die <xref:System.Collections.Generic.List%601> enthält mehr als ein Element mit dem gleichen Wert, gibt die Methode nur einen vorkommen und eine vorkommen, nicht notwendigerweise das erste Element zurückgeben kann.  
  
 Wenn die <xref:System.Collections.Generic.List%601> enthält nicht den angegebenen Wert die Methode gibt eine negative ganze Zahl zurück. Sie können die bitweisen komplementären Vorgangs (~) auf diese negative ganze Zahl, um den Index des ersten Elements zu erhalten, die größer als der Wert für die Suche anwenden. Beim Einfügen des Werts in der <xref:System.Collections.Generic.List%601>, diesen Index als die Einfügemarke verwendet werden soll, um die Sortierreihenfolge zu verwalten.  
  
 Diese Methode ist eine O (Log *n*)-Vorgang, in denen *n* ist die Anzahl der Elemente im Bereich.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> -methodenüberladung, und die <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> -methodenüberladung.  
  
 Im Beispiel wird einen alternativen Vergleich für DinoCompare implementiert-Zeichenfolgen definiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich funktioniert wie folgt aus: Zunächst werden die zu vergleichenden Objekte für getestet `null`, und als kleiner als ein Wert ungleich Null ein null-Verweis behandelt wird. Zweitens: die Länge der Zeichenfolge verglichen werden und größer sein als die längere Zeichenfolge angesehen wird. Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit den Namen der fünf pflanzenfressenden Dinosaurier und drei zur Dinosaurier aufgefüllt. In jedem der beiden Gruppen sind die Namen nicht in der Sortierreihenfolge vor. Die Liste wird angezeigt, die Gruppe der Pflanzenfresser wird mit dem alternativen Vergleich sortiert und die Liste wird erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> methodenüberladung wird dann verwendet, um die "Brachiosaurus" nur die Gruppe der Pflanzenfresser gesucht. Die Zeichenfolge nicht gefunden wird, und das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) der die negative Zahl zurückgegeben, die von der <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Methode dient als Index für das Einfügen der neuen Zeichenfolge.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann keine Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> finden.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl der Elemente ab, die die interne Datenstruktur ohne Änderung der Größe aufnehmen kann, oder legt diese Anzahl fest.</summary>
        <value>Die Anzahl der Elemente, die <see cref="T:System.Collections.Generic.List`1" /> enthalten kann, bevor eine Größenanpassung erforderlich ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.List%601> können speichern, bevor eine größenanpassung erforderlich ist, ist dagegen <xref:System.Collections.Generic.List%601.Count%2A> ist die Anzahl der Elemente, die in der <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> ist immer größer als oder gleich <xref:System.Collections.Generic.List%601.Count%2A>. Wenn <xref:System.Collections.Generic.List%601.Count%2A> überschreitet <xref:System.Collections.Generic.List%601.Capacity%2A> beim Hinzufügen von Elementen, die Kapazität erhöht wird, durch das Neuzuordnen von internen Arrays automatisch vor dem Kopieren der alten und die neuen Elemente hinzugefügt.  
  
 Wenn die Kapazität wesentlich größer als die Anzahl ist und den vom verwendeten Arbeitsspeicher zu reduzieren möchten die <xref:System.Collections.Generic.List%601>, können Sie die Kapazität verringern, durch den Aufruf der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode oder durch Festlegen der <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft explizit auf einen niedrigeren Wert. Wenn der Wert des <xref:System.Collections.Generic.List%601.Capacity%2A> explizit das interne Array wird auch zur Aufnahme die angegebene Kapazität neu zugeordnet und kopiert alle Elemente festgelegt ist.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang. Festlegen der Eigenschaft ist eine O (*n*)-Vorgang, in denen *n* ist die neue Kapazität.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Überprüfen der Kapazität und die Anzahl der einem <xref:System.Collections.Generic.List%601> enthält ein einfaches Geschäftsobjekt und veranschaulicht die Verwendung der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode, um zusätzliche Kapazität zu entfernen.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft an mehreren Punkten im Lebenszyklus einer Liste. Der Standardkonstruktor wird verwendet, um eine Liste von Zeichenfolgen mit einer Kapazität von 0 (null) zu erstellen und die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird angezeigt, um dies zu demonstrieren. Nach der <xref:System.Collections.Generic.List%601.Add%2A> Methode wurde verwendet, um mehrere Elemente hinzuzufügen, die Elemente aufgeführt, und klicken Sie dann die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft angezeigt wird in diesem Fall zusammen mit den <xref:System.Collections.Generic.List%601.Count%2A> -Eigenschaft, um anzugeben, dass die Kapazität nach Bedarf erhöht wurde.  
  
 Die <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird erneut angezeigt, nachdem die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode wird verwendet, um die Kapazität entsprechend der Anzahl die zu reduzieren. Zum Schluss die <xref:System.Collections.Generic.List%601.Clear%2A> Methode dient zum Entfernen aller Elemente aus der Liste aus, und die <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften werden erneut angezeigt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.Generic.List`1.Capacity" /> ist auf einen Wert festgelegt, der kleiner als <see cref="P:System.Collections.Generic.List`1.Count" /> ist.</exception>
        <exception cref="T:System.OutOfMemoryException">Im System ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> auf 0 (null) festgelegt ist und Verweise auf andere Objekte von Elementen in der Auflistung werden ebenfalls freigegeben.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> bleibt unverändert. Zurücksetzen die Kapazität des der <xref:System.Collections.Generic.List%601>, rufen Sie die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode bzw. einer Gruppe die <xref:System.Collections.Generic.List%601.Capacity%2A> -Eigenschaft direkt. Verringern der Kapazität Arbeitsspeicher zuordnet, und kopiert alle Elemente in der <xref:System.Collections.Generic.List%601>. Beim Verkürzen einer leeren <xref:System.Collections.Generic.List%601> definiert die Kapazität der <xref:System.Collections.Generic.List%601> auf die Standardkapazität.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Clear%2A> -Methode und verschiedene andere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generische Klasse. Die <xref:System.Collections.Generic.List%601.Clear%2A> Methode am Ende des Programms verwendet, um alle Elemente aus der Liste zu entfernen und die <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> anschließend werden Eigenschaften angezeigt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Bestimmt, ob sich ein Element in <see cref="T:System.Collections.Generic.List`1" /> befindet.</summary>
        <returns><see langword="true" />, wenn das <paramref name="item" /> in der <see cref="T:System.Collections.Generic.List`1" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt mithilfe des Standardgleichheitsvergleichs, Gleichheit, gemäß der Implementierung des Objekts die <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> -Methode für `T` (den Typ der Werte in der Liste).  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Contains%2A> und <xref:System.Collections.Generic.List%601.Exists%2A> Methoden für eine <xref:System.Collections.Generic.List%601> , enthält ein einfaches Geschäftsobjekt, das implementiert <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Das folgende Beispiel enthält eine Liste von komplexen Objekten des Typs `Cube`. Die `Cube` -Klasse implementiert die <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> Methode so, dass zwei Cubes als gleich betrachtet werden, wenn die Dimensionen identisch sind. In diesem Beispiel die <xref:System.Collections.Generic.List%601.Contains%2A> Methodenrückgabe `true`, da ein Cube, der die angegebenen Abmessungen hat bereits in der Auflistung vorhanden ist.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Der Typ der Elemente des Zielarrays.</typeparam>
        <param name="converter">Ein <see cref="T:System.Converter`2" />-Delegat, der jedes Element von einem Typ in einen anderen Typ konvertiert.</param>
        <summary>Konvertiert die Elemente in der aktuellen <see cref="T:System.Collections.Generic.List`1" /> in einen anderen Typ und gibt eine Liste der konvertierten Elemente zurück.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.List`1" /> des Zieltyps, die die konvertierten Elemente aus der aktuellen <see cref="T:System.Collections.Generic.List`1" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Converter%602> ist ein Delegat für eine Methode, ein Objekt in den Zieltyp konvertiert.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Converter%602> Delegaten und die konvertierten Elemente werden gespeichert, in der neuen <xref:System.Collections.Generic.List%601>.  
  
 Die aktuelle <xref:System.Collections.Generic.List%601> bleibt unverändert.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine Methode namens `PointFToPoint` , konvertiert ein <xref:System.Drawing.PointF> -Struktur in eine <xref:System.Drawing.Point> Struktur. Im Beispiel wird dann erstellt eine <xref:System.Collections.Generic.List%601> von <xref:System.Drawing.PointF> strukturiert ist, erstellt eine `Converter\<PointF, Point>` delegieren (`Converter(Of PointF, Point)` in Visual Basic) zur Darstellung der `PointFToPoint` -Methode, und übergibt den Delegaten an die <xref:System.Collections.Generic.List%601.ConvertAll%2A> Methode. Die <xref:System.Collections.Generic.List%601.ConvertAll%2A> Methode übergibt jedes Element der Liste der Eingabe der `PointFToPoint` Methode und legt die konvertierten Elemente in eine neue Liste von <xref:System.Drawing.Point> Strukturen. Beide Listen werden angezeigt.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="converter" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert <see cref="T:System.Collections.Generic.List`1" /> oder einen Teil davon in ein Array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.List`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <summary>Kopiert die gesamte <see cref="T:System.Collections.Generic.List`1" /> in ein kompatibles eindimensionales Array, wobei am Anfang des Zielarrays begonnen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType> die Elemente kopiert.  
  
 Die Elemente kopiert werden, auf die <xref:System.Array> in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.CopyTo%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit 5 Zeichenfolgen gefüllt ist. Es wird ein leeres Zeichenfolgenarray von 15 Elementen erstellt, und die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> Überladung wird verwendet, um alle Elemente der Liste auf das Array, beginnend auf das erste Element des Arrays zu kopieren. Die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Überladung wird verwendet, um alle Elemente der Liste, um das Array, beginnend am Index des Arrays 6 (leer, wodurch Index 5) kopieren. Zum Schluss die <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um 3 Elemente aus der Liste ab, mit dem Index 2 kopieren, um das Array, beginnend am Array index 12 (wodurch Index 11 leer). Der Inhalt des Arrays werden dann angezeigt.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.List`1" /> ist größer als die Anzahl von Elementen, die das Ziel-<paramref name="array" /> enthalten kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.List`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die gesamte <see cref="T:System.Collections.Generic.List`1" /> in ein kompatibles eindimensionales Array, beginnend am angegebenen Index des Zielarrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType> die Elemente kopiert.  
  
 Die Elemente kopiert werden, auf die <xref:System.Array> in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.CopyTo%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit 5 Zeichenfolgen gefüllt ist. Es wird ein leeres Zeichenfolgenarray von 15 Elementen erstellt, und die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> Überladung wird verwendet, um alle Elemente der Liste auf das Array, beginnend auf das erste Element des Arrays zu kopieren. Die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Überladung wird verwendet, um alle Elemente der Liste, um das Array, beginnend am Index des Arrays 6 (leer, wodurch Index 5) kopieren. Zum Schluss die <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um 3 Elemente aus der Liste ab, mit dem Index 2 kopieren, um das Array, beginnend am Array index 12 (wodurch Index 11 leer). Der Inhalt des Arrays werden dann angezeigt.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.List`1" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index in der Quell-<see cref="T:System.Collections.Generic.List`1" />, ab dem mit dem Kopieren begonnen wird.</param>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.List`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <param name="count">Die Anzahl der zu kopierenden Elemente.</param>
        <summary>Kopiert einen Bereich von Elementen aus der <see cref="T:System.Collections.Generic.List`1" /> in ein kompatibles eindimensionales Array, beginnend ab dem angegebenen Index im Zielarray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType> die Elemente kopiert.  
  
 Die Elemente kopiert werden, auf die <xref:System.Array> in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.CopyTo%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit 5 Zeichenfolgen gefüllt ist. Es wird ein leeres Zeichenfolgenarray von 15 Elementen erstellt, und die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> Überladung wird verwendet, um alle Elemente der Liste auf das Array, beginnend auf das erste Element des Arrays zu kopieren. Die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Überladung wird verwendet, um alle Elemente der Liste, um das Array, beginnend am Index des Arrays 6 (leer, wodurch Index 5) kopieren. Zum Schluss die <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um 3 Elemente aus der Liste ab, mit dem Index 2 kopieren, um das Array, beginnend am Array index 12 (wodurch Index 11 leer). Der Inhalt des Arrays werden dann angezeigt.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="arrayIndex" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> ist gleich oder größer als die <see cref="P:System.Collections.Generic.List`1.Count" /> der Quell-<see cref="T:System.Collections.Generic.List`1" />.  
  
- oder -  
Die Anzahl der Elemente vom <paramref name="index" /> bis zum Ende der Quell-<see cref="T:System.Collections.Generic.List`1" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Collections.Generic.List`1" /> enthalten sind.</summary>
        <value>Die Anzahl der Elemente, die in <see cref="T:System.Collections.Generic.List`1" /> enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> die Anzahl der Elemente, die die <xref:System.Collections.Generic.List%601> speichern können, bevor eine größenanpassung erforderlich ist. <xref:System.Collections.Generic.List%601.Count%2A> ist die Anzahl der Elemente, die in der <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> ist immer größer als oder gleich <xref:System.Collections.Generic.List%601.Count%2A>. Wenn <xref:System.Collections.Generic.List%601.Count%2A> überschreitet <xref:System.Collections.Generic.List%601.Capacity%2A> beim Hinzufügen von Elementen, die Kapazität erhöht wird, durch das Neuzuordnen von internen Arrays automatisch vor dem Kopieren der alten und die neuen Elemente hinzugefügt.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Überprüfen der Kapazität und die Anzahl der einem <xref:System.Collections.Generic.List%601> enthält ein einfaches Geschäftsobjekt und veranschaulicht die Verwendung der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode, um zusätzliche Kapazität zu entfernen.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Das folgende Beispiel zeigt den Wert des der <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaft an verschiedenen Punkten im Lebenszyklus einer Liste. Nachdem die Liste erstellt und gefüllt wurde und seine Elemente angezeigt, die <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften werden angezeigt. Diese Eigenschaften werden erneut angezeigt, nachdem die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode wurde aufgerufen, und erneut, nachdem der Inhalt der Liste gelöscht.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Bestimmt, ob die <see cref="T:System.Collections.Generic.List`1" /> Elemente enthält, die mit den vom angegebenen Prädikat definierten Bedingungen übereinstimmen.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Collections.Generic.List`1" /> ein oder mehr Elemente enthält, die die durch das angegebene Prädikat definierten Bedingungen erfüllen; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Predicate%601> Delegaten und Verarbeitung wird angehalten, wenn eine Übereinstimmung gefunden wird.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Contains%2A> und <xref:System.Collections.Generic.List%601.Exists%2A> Methoden für eine <xref:System.Collections.Generic.List%601> , enthält ein einfaches Geschäftsobjekt, das implementiert <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Exists%2A> -Methode und mehrere andere Methoden, mit denen die <xref:System.Predicate%601> generischen Delegaten.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt, mit 8 Godzilla-Namen, von denen zwei (an Position 1 und 5) "Saurus" enden. Das Beispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, die einen Zeichenfolgenparameter akzeptiert und gibt einen booleschen Wert, der angibt, ob die Eingabezeichenfolge in "Saurus" endet.  
  
 Die <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, und <xref:System.Collections.Generic.List%601.FindAll%2A> Methoden werden verwendet, um die Liste der mit der Suche, durchsuchen und dann die <xref:System.Collections.Generic.List%601.RemoveAll%2A> Methode wird verwendet, um alle Einträge mit "Saurus" entfernt.  
  
 Zum Schluss die <xref:System.Collections.Generic.List%601.Exists%2A> Methode wird aufgerufen. Sie durchläuft die Liste von Anfang an und übergibt an jedes Element der `EndsWithSaurus` Methode. Die Suche beendet, und der Rückgabe der Methode `true` Wenn die `EndsWithSaurus` Methodenrückgabe `true` für jedes Element. Die <xref:System.Collections.Generic.List%601.Exists%2A> Methodenrückgabe `false` da aller entsprechenden Elemente entfernt wurden.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen den richtigen Delegaten aus dem Kontext ableiten und erstellen ihn automatisch.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das erste Vorkommen im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Das erste Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Predicate%601> Delegaten Zukunft die <xref:System.Collections.Generic.List%601>, beginnend mit dem ersten Element und endend mit dem letzten Element.  Die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.  
  
> [!IMPORTANT]
>  Bei der Suche in einer Liste mit Werttypen stellen Sie sicher, dass der Standardwert für den Typ der Search-Prädikat nicht erfüllt. Andernfalls besteht keine Möglichkeit, eine standardmäßige Wert gibt an, dass keine Übereinstimmung gefunden wurde und ein Listenelement, das ausgeführt wird, damit der Standardwert für den Typ unterscheiden. Wenn der Standardwert der Suchprädikat erfüllt, verwenden Sie die <xref:System.Collections.Generic.List%601.FindIndex%2A> Methode stattdessen.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Find%2A> Methode für eine <xref:System.Collections.Generic.List%601> , die ein einfaches komplexeres Objekt enthält.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Das folgende Beispiel zeigt die Find-Methoden für die <xref:System.Collections.Generic.List%601> Klasse. Das Beispiel für die <xref:System.Collections.Generic.List%601> -Klasse enthält `book` Objekte der Klasse `Book`, mit den Daten aus der [XML-Beispieldatei: Bücher (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList` -Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) die Werte aus der XML-Code auf Eigenschaftswerte eines analysiert die `book` Objekte.  
  
 Die folgende Tabelle beschreibt die Beispiele für die Find-Methoden.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht nach einem Buch mithilfe einer ID die `IDToFind` Prädikat Delegaten.<br /><br /> C#-Beispiel wird einen anonymen Delegat verwendet.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen, die alle Bücher, deren `Genre` -Eigenschaft ist "Computer" mithilfe der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, die ein Veröffentlichungsdatum vor 2001, mit der `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel wird einen anonymen Delegat verwendet.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buch mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buch mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des ersten Computer Buch in der zweiten Hälfte der Auflistung, mit der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des letzten Buch für Computer in der zweiten Hälfte der Auflistung, mit der `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Ruft alle Elemente ab, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.List`1" /> mit allen Elementen, die ggf. die durch das angegebene Prädikat definierten Bedingungen erfüllen, andernfalls eine leere <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Predicate%601> Delegaten, und die Elemente, die die Bedingungen werden gespeichert, in der zurückgegebenen <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Find-Methoden für die <xref:System.Collections.Generic.List%601> Klasse. Das Beispiel für die <xref:System.Collections.Generic.List%601> -Klasse enthält `book` Objekte der Klasse `Book`, mit den Daten aus der [XML-Beispieldatei: Bücher (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList` -Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) die Werte aus der XML-Code auf Eigenschaftswerte eines analysiert die `book` Objekte.  
  
 Die folgende Tabelle beschreibt die Beispiele für die Find-Methoden.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht nach einem Buch mithilfe einer ID die `IDToFind` Prädikat Delegaten.<br /><br /> C#-Beispiel wird einen anonymen Delegat verwendet.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen, die alle Bücher, deren `Genre` -Eigenschaft ist "Computer" mithilfe der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, die ein Veröffentlichungsdatum vor 2001, mit der `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel wird einen anonymen Delegat verwendet.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buch mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buch mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des ersten Computer Buch in der zweiten Hälfte der Auflistung, mit der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des letzten Buch für Computer in der zweiten Hälfte der Auflistung, mit der `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch ein angegebenes Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens in der <see cref="T:System.Collections.Generic.List`1" /> oder einem Teil davon zurück. Diese Methode gibt -1 zurück, wenn kein Element gefunden wird, das den Bedingungen entspricht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> vorwärts beginnend ab dem ersten Element und endet mit dem letzten Element gesucht wird.  
  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Predicate%601> delegieren. Der Delegat besitzt die Signatur:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `Employee` Klasse mit zwei Feldern `Name` und `Id`. Sie definiert auch eine `EmployeeSearch` Klasse mit einer einzelnen Methode, `StartsWith`, der angibt, ob die `Employee.Name` Feld beginnt mit einer angegebenen Teilzeichenfolge, die an die `EmployeeSearch` Klassenkonstruktor. Beachten Sie die Signatur dieser Methode  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 mit der Signatur des Delegaten, der übergeben werden kann, entspricht die <xref:System.Collections.Generic.List%601.FindIndex%2A> Methode. Das Beispiel instanziiert ein `List<Employee>` Objekt, bietet eine Reihe von `Employee` Objekten, und klicken Sie dann Aufrufe der <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> Methode zum Durchsuchen der gesamten Auflistung, für die erste zum ersten Mal zweimal `Employee` Objekt, dessen `Name` Feld beginnt mit "J" und das zweite Mal für die erste `Employee` Objekt, dessen `Name` Feld beginnt mit "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der vom angegebenen Index bis zum letzten Element reicht.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> Rollforward ab durchsucht `startIndex` beginnt und mit dem letzten Element.  
  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Predicate%601> delegieren. Der Delegat besitzt die Signatur:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist die Anzahl von Elementen aus `startIndex` bis zum Ende der <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `Employee` Klasse mit zwei Feldern `Name` und `Id`. Sie definiert auch eine `EmployeeSearch` Klasse mit einer einzelnen Methode, `StartsWith`, der angibt, ob die `Employee.Name` Feld beginnt mit einer angegebenen Teilzeichenfolge, die an die `EmployeeSearch` Klassenkonstruktor. Beachten Sie die Signatur dieser Methode  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 mit der Signatur des Delegaten, der übergeben werden kann, entspricht die <xref:System.Collections.Generic.List%601.FindIndex%2A> Methode. Das Beispiel instanziiert ein `List<Employee>` Objekt, bietet eine Reihe von `Employee` Objekten, und klicken Sie dann Aufrufe der <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> Methode zweimal, um der Auflistung, beginnend mit des fünften Elements (d. h. das Element am Index 4) zu suchen. Erstmals ausführen, sucht es nach der ersten `Employee` Objekt, dessen `Name` Feld beginnt mit "J", bei der zweiten Anwendung sucht nach der ersten `Employee` Objekt, dessen `Name` Feld beginnt mit "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen umfasst.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> Rollforward ab durchsucht `startIndex` und endet um `startIndex` plus `count` minus 1, wenn `count` ist größer als 0.  
  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Predicate%601> delegieren. Der Delegat besitzt die Signatur:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `Employee` Klasse mit zwei Feldern `Name` und `Id`. Sie definiert auch eine `EmployeeSearch` Klasse mit einer einzelnen Methode, `StartsWith`, der angibt, ob die `Employee.Name` Feld beginnt mit einer angegebenen Teilzeichenfolge, die an die `EmployeeSearch` Klassenkonstruktor. Beachten Sie die Signatur dieser Methode  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 mit der Signatur des Delegaten, der übergeben werden kann, entspricht die <xref:System.Collections.Generic.List%601.FindIndex%2A> Methode. Das Beispiel instanziiert ein `List<Employee>` Objekt, bietet eine Reihe von `Employee` Objekten, und klicken Sie dann Aufrufe der <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> Methode zweimal, um die gesamte Auflistung suchen (d. h. die Elemente von Index 0 in Index <xref:System.Collections.Generic.List%601.Count%2A> - 1). Erstmals ausführen, sucht es nach der ersten `Employee` Objekt, dessen `Name` Feld beginnt mit "J", bei der zweiten Anwendung sucht nach der ersten `Employee` Objekt, dessen `Name` Feld beginnt mit "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für die <see cref="T:System.Collections.Generic.List`1" />.  
  
- oder -  
 <paramref name="count" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das letzte Vorkommen im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Das letzte Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben der <xref:System.Predicate%601> Delegaten zurück navigieren, der <xref:System.Collections.Generic.List%601>, mit dem letzten Element beginnend und endend mit dem ersten Element.  Die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.  
  
> [!IMPORTANT]
>  Bei der Suche in einer Liste mit Werttypen stellen Sie sicher, dass der Standardwert für den Typ der Search-Prädikat nicht erfüllt. Andernfalls besteht keine Möglichkeit, eine standardmäßige Wert gibt an, dass keine Übereinstimmung gefunden wurde und ein Listenelement, das ausgeführt wird, damit der Standardwert für den Typ unterscheiden. Wenn der Standardwert der Suchprädikat erfüllt, verwenden Sie die <xref:System.Collections.Generic.List%601.FindLastIndex%2A> Methode stattdessen.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Find-Methoden für die <xref:System.Collections.Generic.List%601> Klasse. Das Beispiel für die <xref:System.Collections.Generic.List%601> -Klasse enthält `book` Objekte der Klasse `Book`, mit den Daten aus der [XML-Beispieldatei: Bücher (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList` -Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) die Werte aus der XML-Code auf Eigenschaftswerte eines analysiert die `book` Objekte.  
  
 Die folgende Tabelle beschreibt die Beispiele für die Find-Methoden.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht nach einem Buch mithilfe einer ID die `IDToFind` Prädikat Delegaten.<br /><br /> C#-Beispiel wird einen anonymen Delegat verwendet.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen, die alle Bücher, deren `Genre` -Eigenschaft ist "Computer" mithilfe der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, die ein Veröffentlichungsdatum vor 2001, mit der `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel wird einen anonymen Delegat verwendet.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buch mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buch mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des ersten Computer Buch in der zweiten Hälfte der Auflistung, mit der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des letzten Buch für Computer in der zweiten Hälfte der Auflistung, mit der `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch ein angegebenes Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens in der <see cref="T:System.Collections.Generic.List`1" /> oder einem Teil davon zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> rückwärts beginnend ab dem letzten Element und endend mit dem ersten Element gesucht wird.  
  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Predicate%601> delegieren.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Find-Methoden für die <xref:System.Collections.Generic.List%601> Klasse. Das Beispiel für die <xref:System.Collections.Generic.List%601> -Klasse enthält `book` Objekte der Klasse `Book`, mit den Daten aus der [XML-Beispieldatei: Bücher (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList` -Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) die Werte aus der XML-Code auf Eigenschaftswerte eines analysiert die `book` Objekte.  
  
 Die folgende Tabelle beschreibt die Beispiele für die Find-Methoden.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht nach einem Buch mithilfe einer ID die `IDToFind` Prädikat Delegaten.<br /><br /> C#-Beispiel wird einen anonymen Delegat verwendet.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen, die alle Bücher, deren `Genre` -Eigenschaft ist "Computer" mithilfe der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, die ein Veröffentlichungsdatum vor 2001, mit der `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel wird einen anonymen Delegat verwendet.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buch mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buch mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des ersten Computer Buch in der zweiten Hälfte der Auflistung, mit der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des letzten Buch für Computer in der zweiten Hälfte der Auflistung, mit der `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der vom ersten Element bis zum angegeben Index reicht.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> wird rückwärts gesuchten beginnt am `startIndex` bis auf das erste Element.  
  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Predicate%601> delegieren.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem *n* ist die Anzahl der Elemente vom Anfang der <xref:System.Collections.Generic.List%601> zu `startIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der die angegebene Anzahl von Elementen umfasst und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> wird rückwärts gesuchten beginnt am `startIndex` und endet um `startIndex` minus `count` plus 1, wenn `count` ist größer als 0.  
  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Predicate%601> delegieren.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Find-Methoden für die <xref:System.Collections.Generic.List%601> Klasse. Das Beispiel für die <xref:System.Collections.Generic.List%601> -Klasse enthält `book` Objekte der Klasse `Book`, mit den Daten aus der [XML-Beispieldatei: Bücher (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList` -Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) die Werte aus der XML-Code auf Eigenschaftswerte eines analysiert die `book` Objekte.  
  
 Die folgende Tabelle beschreibt die Beispiele für die Find-Methoden.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht nach einem Buch mithilfe einer ID die `IDToFind` Prädikat Delegaten.<br /><br /> C#-Beispiel wird einen anonymen Delegat verwendet.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen, die alle Bücher, deren `Genre` -Eigenschaft ist "Computer" mithilfe der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, die ein Veröffentlichungsdatum vor 2001, mit der `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel wird einen anonymen Delegat verwendet.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buch mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buch mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des ersten Computer Buch in der zweiten Hälfte der Auflistung, mit der `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht dem Index des letzten Buch für Computer in der zweiten Hälfte der Auflistung, mit der `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für die <see cref="T:System.Collections.Generic.List`1" />.  
  
- oder -  
 <paramref name="count" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">Der <see cref="T:System.Action`1" />-Delegat, der für jedes Element von <see cref="T:System.Collections.Generic.List`1" /> ausgeführt werden soll.</param>
        <summary>Führt die angegebene Aktion für jedes Element der <see cref="T:System.Collections.Generic.List`1" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Action%601> ein Delegaten an eine Methode, die eine Aktion, für das Objekt ausführt übergeben wird.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Action%601> delegieren.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Ändern der zugrunde liegenden Auflistung im Hauptteil der <xref:System.Action%601> Delegat wird nicht unterstützt und verursacht nicht definiertes Verhalten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung von der <xref:System.Action%601> Delegat zum Drucken des Inhalts von einem <xref:System.Collections.Generic.List%601> Objekt. In diesem Beispiel die `Print` Methode wird verwendet, um den Inhalt der Liste der in der Konsole anzeigen.  
  
> [!NOTE]
>  Zusätzlich zum Anzeigen des Inhalts mit der `Print` -Methode, die C#-Beispiel veranschaulicht die Verwendung der Anzeige der Ergebnisse an die Konsole.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Element in der Auflistung wurde geändert.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die <see cref="T:System.Collections.Generic.List`1" /> durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.List`1.Enumerator" /> für die <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der c#-Sprache (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist die <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> Eigenschaft ist nicht definiert. Aus diesem Grund müssen Sie Aufrufen der <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> Methode, um den Enumerator auf das erste Element der Auflistung vor dem Lesen des Werts von <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 Die <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> Eigenschaft gibt das gleiche Objekt bis <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> legt <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn der Auflistung, z. B. das Hinzufügen Änderungen, ändern oder Löschen von Elementen, wenn der Enumerator unwiederbringlich ist ungültig, und der nächste Aufruf von <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> oder <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> löst eine <xref:System.InvalidOperationException>.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte <see cref="T:System.Collections.Generic.List`1" />-Index, an dem der Bereich beginnt.</param>
        <param name="count">Die Anzahl der Elemente im Bereich.</param>
        <summary>Erstellt eine flache Kopie eines Bereichs von Elementen in der Quell-<see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Eine flache Kopie eines Bereichs von Elementen in der Quell-<see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine flache Kopie des eine Auflistung von Verweistypen oder eine Teilmenge dieser Auflistung enthält nur die Verweise auf die Elemente der Auflistung. Die Objekte selbst werden nicht kopiert. Die Verweise in der neuen Liste zeigen auf die gleichen Objekte wie die Verweise in der ursprünglichen Liste.  
  
 Eine flache Kopie des eine Auflistung von Werttypen oder eine Teilmenge dieser Auflistung enthält die Elemente der Auflistung. Wenn die Elemente der Auflistung Verweise auf andere Objekte enthalten, werden diese Objekte jedoch nicht kopiert. Die Verweise in die Elemente der neuen Sammlung zeigen Sie auf die gleichen Objekte wie die Verweise in die Elemente der ursprünglichen Auflistung.  
  
 Im Gegensatz dazu wird eine tiefe Kopie einer Auflistung kopiert die Elemente, und alles, was durch die Elemente direkt oder indirekt verwiesen.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.GetRange%2A> -Methode und andere Methoden der <xref:System.Collections.Generic.List%601> -Klasse, die für Bereiche verwendet. Am Ende des Beispiels die <xref:System.Collections.Generic.List%601.GetRange%2A> Methode wird verwendet, um die drei Elemente aus der Liste aus, ab Position 2 des Index abzurufen. Die <xref:System.Collections.Generic.List%601.ToArray%2A> Methode wird aufgerufen, für das resultierende <xref:System.Collections.Generic.List%601>, erstellen ein Array von drei Elementen. Die Elemente des Arrays werden angezeigt.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den nullbasierten Index des ersten Vorkommens eines Werts in der <see cref="T:System.Collections.Generic.List`1" /> bzw. in einem Abschnitt davon zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des ersten Vorkommens innerhalb der gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des ggf. ersten Vorkommens von <paramref name="item" /> in der gesamten <see cref="T:System.Collections.Generic.List`1" />, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> vorwärts beginnend ab dem ersten Element und endet mit dem letzten Element gesucht wird.  
  
 Diese Methode bestimmt mithilfe des Standardgleichheitsvergleichs Gleichheit <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.IndexOf%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen wird erstellt, mit einem Eintrag, der an der Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> -methodenüberladung, durchsucht die Liste ab und sucht das erste Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> -methodenüberladung wird verwendet, um die Suche nach der Liste ab, mit der Indexposition 3 und am Ende der Liste fortfahren und das zweite Vorkommen der Zeichenfolge sucht. Zum Schluss die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um einen Bereich von zwei Einträge, beginnend an der Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Suche. 0 (null) ist in einer leeren Liste gültig.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der sich vom angegebenen Index bis zum letzten Element erstreckt.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in <see cref="T:System.Collections.Generic.List`1" />, der sich von <paramref name="index" /> bis zum letzten Element erstreckt, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> Rollforward ab durchsucht `index` beginnt und mit dem letzten Element.  
  
 Diese Methode bestimmt mithilfe des Standardgleichheitsvergleichs Gleichheit <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist die Anzahl von Elementen aus `index` bis zum Ende der <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.IndexOf%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen wird erstellt, mit einem Eintrag, der an der Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> -methodenüberladung, durchsucht die Liste ab und sucht das erste Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> -methodenüberladung wird verwendet, um die Suche nach der Liste ab, mit der Indexposition 3 und am Ende der Liste fortfahren und das zweite Vorkommen der Zeichenfolge sucht. Zum Schluss die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um einen Bereich von zwei Einträge, beginnend an der Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Suche. 0 (null) ist in einer leeren Liste gültig.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen enthält.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in <see cref="T:System.Collections.Generic.List`1" />, der am <paramref name="index" /> beginnt und eine Anzahl von Elementen <paramref name="count" /> enthält, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> Rollforward ab durchsucht `index` und endet um `index` plus `count` minus 1, wenn `count` ist größer als 0.  
  
 Diese Methode bestimmt mithilfe des Standardgleichheitsvergleichs Gleichheit <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.IndexOf%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen wird erstellt, mit einem Eintrag, der an der Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> -methodenüberladung, durchsucht die Liste ab und sucht das erste Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> -methodenüberladung wird verwendet, um die Suche nach der Liste ab, mit der Indexposition 3 und am Ende der Liste fortfahren und das zweite Vorkommen der Zeichenfolge sucht. Zum Schluss die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um einen Bereich von zwei Einträge, beginnend an der Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
- oder -  
 <paramref name="count" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <paramref name="item" /> eingefügt werden soll.</param>
        <param name="item">Das einzufügende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.Generic.List`1" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültiger Wert für den Verweis und doppelte Elemente lässt.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> bereits entspricht <xref:System.Collections.Generic.List%601.Capacity%2A>, wird die Kapazität von der <xref:System.Collections.Generic.List%601> wird erhöht, die automatisch erneut zugewiesen werden, das interne Array, und die vorhandenen Elemente in das neue Array kopiert werden, bevor das neue Element hinzugefügt wird.  
  
 Wenn `index` gleich <xref:System.Collections.Generic.List%601.Count%2A>, `item` wird am Ende hinzugefügt <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie hinzufügen, entfernen, und fügen Sie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Insert%2A> -Methode, zusammen mit verschiedenen anderen Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generische Klasse. Nachdem die Liste erstellt wurde, werden Elemente hinzugefügt. Die <xref:System.Collections.Generic.List%601.Insert%2A> Methode wird verwendet, um ein Element in der Mitte der Liste einfügen. Das Element eingefügt ist ein Duplikat, das mit einem späteren Zeitpunkt entfernt wird die <xref:System.Collections.Generic.List%601.Remove%2A> Methode.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="index" /> ist größer als <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem neue Elemente eingefügt werden sollen.</param>
        <param name="collection">Die Sammlung, deren Elemente in die <see cref="T:System.Collections.Generic.List`1" /> eingefügt werden sollen. Die Auflistung an sich kann nicht <see langword="null" /> sein, sie kann jedoch Elemente enthalten, die <see langword="null" /> sind, wenn Typ <paramref name="T" /> einen Referenztyp darstellt.</param>
        <summary>Fügt die Elemente einer Auflistung am angegebenen Index in die <see cref="T:System.Collections.Generic.List`1" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültiger Wert für den Verweis und doppelte Elemente lässt.  
  
 Wenn die neue <xref:System.Collections.Generic.List%601.Count%2A> (die aktuelle <xref:System.Collections.Generic.List%601.Count%2A> plus die Größe der Auflistung) wird größer sein als <xref:System.Collections.Generic.List%601.Capacity%2A>, die der Kapazität der <xref:System.Collections.Generic.List%601> wird erhöht, die automatisch erneut zugewiesen werden, das interne Array zur Aufnahme der neuen Elemente, und die vorhandene Elemente werden in das neue Array kopiert, bevor die neuen Elemente hinzugefügt werden.  
  
 Wenn `index` gleich <xref:System.Collections.Generic.List%601.Count%2A>, die Elemente werden hinzugefügt, bis zum Ende des <xref:System.Collections.Generic.List%601>.  
  
 Die Reihenfolge der Elemente in der Auflistung wird beibehalten, der <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode ist eine O (*n* * *m*)-Vorgang, in denen *n* ist die Anzahl der Elemente, die hinzugefügt werden und *m* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt <xref:System.Collections.Generic.List%601.InsertRange%2A> -Methode und verschiedene weitere Methoden, die von der <xref:System.Collections.Generic.List%601> -Klasse, die für Bereiche verwendet. Nachdem die Liste erstellt und aufgefüllt, die mit den Namen der mehrere beruhigend Werk Essen Dinosaurier, wurde die <xref:System.Collections.Generic.List%601.InsertRange%2A> Methode wird verwendet, um ein Array von drei ertragreiche Fleisch Essen Dinosaurier in der Liste ab, an der Indexposition 3 einzufügen.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="index" /> ist größer als <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des Elements, das abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft das Element am angegebenen Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültiger Wert für den Verweis und doppelte Elemente lässt.  
  
 Diese Eigenschaft ermöglicht den Zugriff auf ein bestimmtes Element in der Auflistung mithilfe folgender Syntax: `myCollection[index]`.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang. Festlegen der Eigenschaft ist auch ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das Beispiel in diesem Abschnitt wird veranschaulicht, die <xref:System.Collections.Generic.List%601.Item%2A> -Eigenschaft (Indexer in c#) und verschiedene andere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generische Klasse. Nachdem die Liste wurde erstellt und aufgefüllt, mit der <xref:System.Collections.Generic.List%601.Add%2A> -Methode, ein Element wird abgerufen und angezeigt, mit der <xref:System.Collections.Generic.List%601.Item%2A> Eigenschaft. (Ein Beispiel für die Verwendung der <xref:System.Collections.Generic.List%601.Item%2A> -Eigenschaft zum Festlegen des Werts eines Listenelements finden Sie unter <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, c# und in C++ haben Sie die Syntax für den Zugriff auf die <xref:System.Collections.Generic.List%601.Item%2A> Eigenschaft ohne Verwendung seines Namens. Stattdessen die Zeichenfolgenvariable mit dem <xref:System.Collections.Generic.List%601> wird verwendet, als handele es sich um ein Array.  
  
 Die Programmiersprache c# verwendet das Schlüsselwort der Indexer definieren die <xref:System.Collections.Generic.List%601.Item%2A> Eigenschaft. Visual Basic implementiert <xref:System.Collections.Generic.List%601.Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den nullbasierten Index des letzten Vorkommens eines Werts in der <see cref="T:System.Collections.Generic.List`1" /> bzw. in einem Abschnitt davon zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des letzten Vorkommens innerhalb der gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="item" /> in der gesamten <see cref="T:System.Collections.Generic.List`1" />; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> rückwärts beginnend ab dem letzten Element und endend mit dem ersten Element gesucht wird.  
  
 Diese Methode bestimmt mithilfe des Standardgleichheitsvergleichs Gleichheit <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.LastIndexOf%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen wird erstellt, mit einem Eintrag, der an der Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> -methodenüberladung, durchsucht die gesamte Liste vom Ende und das zweite Vorkommen der Zeichenfolge sucht. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> Überladung wird verwendet, um das Durchsuchen der Liste rückwärts, beginnend mit der Indexposition 3 aus, und Sie den Vorgang fortsetzen an den Anfang der Liste aus, damit sie das erste Vorkommen der Zeichenfolge in der Liste findet. Zum Schluss die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um einen Bereich von vier Einträge, beginnend an Position 4 des Index, und Erweitern von Rückwärts suchen (d. h. er durchsucht die Elemente an Stellen, 4, 3, 2 und 1); diese Suche gibt-1 zurück, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der sich vom angegebenen Index bis zum letzten Element erstreckt.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" />, der sich vom ersten Element bis <paramref name="index" /> erstreckt, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> wird rückwärts gesuchten beginnt am `index` bis auf das erste Element.  
  
 Diese Methode bestimmt mithilfe des Standardgleichheitsvergleichs Gleichheit <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in dem *n* ist die Anzahl der Elemente vom Anfang der <xref:System.Collections.Generic.List%601> zu `index`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.LastIndexOf%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen wird erstellt, mit einem Eintrag, der an der Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> -methodenüberladung, durchsucht die gesamte Liste vom Ende und das zweite Vorkommen der Zeichenfolge sucht. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> Überladung wird verwendet, um das Durchsuchen der Liste rückwärts, beginnend mit der Indexposition 3 aus, und Sie den Vorgang fortsetzen an den Anfang der Liste aus, damit sie das erste Vorkommen der Zeichenfolge in der Liste findet. Zum Schluss die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um einen Bereich von vier Einträge, beginnend an Position 4 des Index, und Erweitern von Rückwärts suchen (d. h. er durchsucht die Elemente an Stellen, 4, 3, 2 und 1); diese Suche gibt-1 zurück, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" />, der <paramref name="count" /> Anzahl von Elementen enthält und am <paramref name="index" /> endet, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> wird rückwärts gesuchten beginnt am `index` und endet um `index` minus `count` plus 1, wenn `count` ist größer als 0.  
  
 Diese Methode bestimmt mithilfe des Standardgleichheitsvergleichs Gleichheit <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei Überladungen, der die <xref:System.Collections.Generic.List%601.LastIndexOf%2A> Methode. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen wird erstellt, mit einem Eintrag, der an der Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> -methodenüberladung, durchsucht die gesamte Liste vom Ende und das zweite Vorkommen der Zeichenfolge sucht. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> Überladung wird verwendet, um das Durchsuchen der Liste rückwärts, beginnend mit der Indexposition 3 aus, und Sie den Vorgang fortsetzen an den Anfang der Liste aus, damit sie das erste Vorkommen der Zeichenfolge in der Liste findet. Zum Schluss die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um einen Bereich von 4 Einträge, beginnend an Position 4 des Index aus, und erweitern Rückwärts suchen (d. h. er durchsucht die Elemente an Stellen, 4, 3, 2 und 1); diese Suche gibt-1 zurück, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
- oder -  
 <paramref name="count" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das aus der <see cref="T:System.Collections.Generic.List`1" /> zu entfernende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Entfernt das erste Vorkommen eines angegebenen Objekts aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns><see langword="true" />, wenn das <paramref name="item" /> erfolgreich entfernt wurde; andernfalls <see langword="false" />.  Diese Methode gibt auch dann <see langword="false" /> zurück, wenn das <paramref name="item" /> nicht in der <see cref="T:System.Collections.Generic.List`1" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Typ `T` implementiert die <xref:System.IEquatable%601> generische Schnittstelle, die der Gleichheitsvergleich ist die <xref:System.IEquatable%601.Equals%2A> -Methode der Schnittstelle; andernfalls ist die der Standardgleichheitsvergleich <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie hinzufügen, entfernen, und fügen Sie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Das folgende Beispiel zeigt <xref:System.Collections.Generic.List%601.Remove%2A> Methode. Verschiedene Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generische Klasse hinzufügen, einfügen und suchen Sie in der Liste verwendet werden. Nach diesen Operationen enthält die Liste bereits vorhanden. Die <xref:System.Collections.Generic.List%601.Remove%2A> Methode wird verwendet, um die erste Instanz des doppelten Elements entfernt werden soll, und der Inhalt wird angezeigt. Die <xref:System.Collections.Generic.List%601.Remove%2A> Methode wird immer der erste gefundene Instanz entfernt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, die entfernt werden sollen.</param>
        <summary>Entfernt alle Elemente, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</summary>
        <returns>Die Anzahl der aus der <see cref="T:System.Collections.Generic.List`1" /> entfernten Elemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Predicate%601> Delegaten und die Elemente, die die Bedingungen werden entfernt, von der <xref:System.Collections.Generic.List%601>.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.RemoveAll%2A> -Methode und mehrere andere Methoden, mit denen die <xref:System.Predicate%601> generischen Delegaten.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt, mit 8 Godzilla-Namen, von denen zwei (an Position 1 und 5) "Saurus" enden. Das Beispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, die einen Zeichenfolgenparameter akzeptiert und gibt einen booleschen Wert, der angibt, ob die Eingabezeichenfolge in "Saurus" endet.  
  
 Die <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, und <xref:System.Collections.Generic.List%601.FindAll%2A> Methoden werden verwendet, um die Liste der mit der Suche zu durchsuchen.  
  
 Die <xref:System.Collections.Generic.List%601.RemoveAll%2A> Methode wird verwendet, um alle Einträge mit "Saurus" entfernt. Sie durchläuft die Liste von Anfang an und übergibt an jedes Element der `EndsWithSaurus` Methode. Das Element wird entfernt, wenn die `EndsWithSaurus` Methodenrückgabe `true`.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen den richtigen Delegaten aus dem Kontext abgeleitet, und es automatisch erstellen.  
  
 Zum Schluss die <xref:System.Collections.Generic.List%601.Exists%2A> Methode stellt sicher, dass keine Zeichenfolgen in der Liste, die mit "Saurus" enden.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des zu entfernenden Elements.</param>
        <summary>Entfernt das Element am angegebenen Index aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufruf <xref:System.Collections.Generic.List%601.RemoveAt%2A> um ein Element zu entfernen, die verbleibenden Elemente in der Liste werden neu nummeriert, um das entfernte Element zu ersetzen. Wenn Sie das Element am Index 3 entfernen, wird z. B. das Element am Index 4 an Position 3 verschoben. Darüber hinaus die Anzahl der Elemente in der Liste (dargestellt durch die <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaft) wird um 1 verringert.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie hinzufügen, entfernen, und fügen Sie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des zu entfernenden Bereichs von Elementen.</param>
        <param name="count">Die Anzahl der zu entfernenden Elemente.</param>
        <summary>Entfernt einen Bereich von Elementen aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden entfernt und die Elemente, die für die folgenden Elemente in der <xref:System.Collections.Generic.List%601> die Indizes reduziert, indem `count`.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.RemoveRange%2A> -Methode und verschiedene weitere Methoden, die von der <xref:System.Collections.Generic.List%601> -Klasse, die für Bereiche verwendet. Nachdem die Liste wurde erstellt und geändert, die <xref:System.Collections.Generic.List%601.RemoveRange%2A> Methode wird verwendet, um die zwei Elemente aus der Liste ab, an der Indexposition 2 entfernt.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kehrt die Reihenfolge der Elemente in der <see cref="T:System.Collections.Generic.List`1" /> bzw. in einem Teil davon um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kehrt die Reihenfolge der Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Reverse%2A?displayProperty=nameWithType> um die Reihenfolge der Elemente umzukehren.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht beide Überladungen der <xref:System.Collections.Generic.List%601.Reverse%2A> Methode. Das Beispiel erstellt eine <xref:System.Collections.Generic.List%601> von Zeichenfolgen und sechs Zeichenfolgen hinzugefügt. Die <xref:System.Collections.Generic.List%601.Reverse> Überladung wird verwendet, um der Liste der umgekehrte und klicken Sie dann die <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> Überladung wird verwendet, um die Mitte der Liste, beginnend mit 1 Element, und umfasst vier Elemente umzukehren.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des Bereichs, in dem die Reihenfolge umgekehrt werden soll.</param>
        <param name="count">Die Anzahl der Elemente im Bereich, in dem die Reihenfolge umgekehrt werden soll.</param>
        <summary>Kehrt die Reihenfolge der Elemente im angegebenen Bereich um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Reverse%2A?displayProperty=nameWithType> um die Reihenfolge der Elemente umzukehren.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht beide Überladungen der <xref:System.Collections.Generic.List%601.Reverse%2A> Methode. Das Beispiel erstellt eine <xref:System.Collections.Generic.List%601> von Zeichenfolgen und sechs Zeichenfolgen hinzugefügt. Die <xref:System.Collections.Generic.List%601.Reverse> Überladung wird verwendet, um der Liste der umgekehrte und klicken Sie dann die <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> Überladung wird verwendet, um die Mitte der Liste, beginnend mit 1 Element, und umfasst vier Elemente umzukehren.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente oder einen Teil der Elemente in <see cref="T:System.Collections.Generic.List`1" />, entweder über die angegebene oder eine Standardimplementierung von <see cref="T:System.Collections.Generic.IComparer`1" /> oder über einen bereitgestellten <see cref="T:System.Comparison`1" />-Delegat zum Vergleichen von Listenelementen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sortiert die Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> mithilfe des Standardcomparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> für Typ `T` bestimmt die Reihenfolge der Listenelemente. Die <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> -Eigenschaft überprüft, ob der Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle und verwendet Sie, dass diese Implementierung, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable> Schnittstelle.  Wenn Typ `T` implementiert nicht die beiden Schnittstellen, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> löst eine <xref:System.InvalidOperationException>.  
  
 Diese Methode verwendet die <xref:System.Array.Sort%2A?displayProperty=nameWithType> -Methode, die die Beobachtung der inneren Abläufe Sortierung wie folgt angewendet:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird eine Einfügung Sortieralgorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 Protokolle *n*, wobei *n* ist der Bereich des Eingabearrays, es wird ein Heapsort-Algorithmus verwendet.  
  
-   Andernfalls wird einen Quicksort-Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Diese Methode ist im Durchschnitt eine O (*n* Log *n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>; im schlimmsten Fall ist es eine O (*n* <sup>2</sup>) Vorgang.  
  
   
  
## Examples  
 Das folgende Beispiel fügt einige Objektnamen ein `List<String>` -Objekt, zeigt die Liste ohne Reihenfolge aufruft der <xref:System.Collections.Generic.List%601.Sort%2A> -Methode, und zeigt dann die sortierte Liste.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 Der folgende Code zeigt die <xref:System.Collections.Generic.List%601.Sort> und <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> Überladungen der Methode für ein einfaches Geschäftsobjekt. Aufrufen der <xref:System.Collections.Generic.List%601.Sort> Methode führt die Verwendung der Standardvergleich für den Typ Teil, und die <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> Methode mit einer anonymen Methode implementiert wird.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Sort> -methodenüberladung, und die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> -methodenüberladung. Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit vier Zeichenfolgen, in keiner bestimmten Reihenfolge aufgefüllt. Die Liste wird angezeigt, sortiert und erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> methodenüberladung wird dann verwendet, um die für zwei Zeichenfolgen zu suchen, die nicht in der Liste enthalten sind und die <xref:System.Collections.Generic.List%601.Insert%2A> Methode verwendet, um sie einzufügen. Der Rückgabewert von der <xref:System.Collections.Generic.List%601.BinarySearch%2A> Methode ist in jedem Fall negativ, da die Zeichenfolgen nicht in der Liste enthalten sind. Dem bitweisen Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) dieses negative Zahl wird der Index des ersten Elements in der Liste, die größer als die zu suchende Zeichenfolge und Einfügen von an dieser Stelle ist beibehalten der Sortierreihenfolge die Reihenfolge. Die zweite Zeichenfolge für die Suche ist größer als ein Element in der Liste, daher ist die Position der Einfügemarke am Ende der Liste.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann keine Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> finden.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, wenn der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> verwendet werden soll.</param>
        <summary>Sortiert die Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> mithilfe des angegebenen Comparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` angegeben ist, wird die Elemente der <xref:System.Collections.Generic.List%601> sortiert sind, mit dem angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung.  
  
 Wenn `comparer` ist `null`, die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle und verwendet Sie, dass diese Implementierung, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable> Schnittstelle.  Wenn Typ `T` implementiert nicht die beiden Schnittstellen, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> löst eine <xref:System.InvalidOperationException>.  
  
 Diese Methode verwendet die <xref:System.Array.Sort%2A?displayProperty=nameWithType> -Methode, die die Beobachtung der inneren Abläufe Sortierung wie folgt angewendet:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird eine Einfügung Sortieralgorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 Protokolle *n*, wobei *n* ist der Bereich des Eingabearrays, es wird ein Heapsort-Algorithmus verwendet.  
  
-   Andernfalls wird einen Quicksort-Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Diese Methode ist im Durchschnitt eine O (*n* Log *n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>; im schlimmsten Fall ist es eine O (*n* <sup>2</sup>) Vorgang.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> -methodenüberladung, und die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> -methodenüberladung.  
  
 Im Beispiel wird einen alternativen Vergleich für DinoCompare implementiert-Zeichenfolgen definiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich funktioniert wie folgt aus: Zunächst werden die zu vergleichenden Objekte für getestet `null`, und als kleiner als ein Wert ungleich Null ein null-Verweis behandelt wird. Zweitens: die Länge der Zeichenfolge verglichen werden und größer sein als die längere Zeichenfolge angesehen wird. Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit vier Zeichenfolgen, in keiner bestimmten Reihenfolge aufgefüllt. Die Liste ist, mit dem alternativen Vergleich sortiert und angezeigten erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> methodenüberladung wird dann verwendet, um die für mehrere Zeichenfolgen zu suchen, die nicht in der Liste der alternativen Vergleich anwenden. Die <xref:System.Collections.Generic.List%601.Insert%2A> Methode verwendet, um die Zeichenfolgen einzufügen. Diese beiden Methoden befinden sich in der Funktion, die mit dem Namen `SearchAndInsert`, zusammen mit Code, das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) der die negative Zahl, die vom <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> und verwenden sie als Index für Einfügen der neuen Zeichenfolge an.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> nicht finden.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">Die <see cref="T:System.Comparison`1" />, die beim Vergleich von Elementen verwendet werden soll.</param>
        <summary>Sortiert die Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> mithilfe des angegebenen <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparison` angegeben ist, wird die Elemente der <xref:System.Collections.Generic.List%601> mithilfe der durch den Delegaten dargestellte Methode sortiert sind.  
  
 Wenn `comparison` ist `null`, <xref:System.ArgumentNullException> ausgelöst.  
  
 Diese Methode verwendet <xref:System.Array.Sort%2A?displayProperty=nameWithType>, die die Beobachtung der inneren Abläufe Sortierreihenfolge wie folgt angewendet:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, verwendet einen Sortieralgorithmus einfügen  
  
-   Überschreitet die Anzahl der Partitionen 2 Protokolle *n*, wobei *n* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird einen Quicksort-Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Diese Methode ist im Durchschnitt eine O (*n* Log *n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>; im schlimmsten Fall ist es eine O (*n* <sup>2</sup>) Vorgang.  
  
   
  
## Examples  
 Der folgende Code zeigt die <xref:System.Collections.Generic.List%601.Sort%2A> und <xref:System.Collections.Generic.List%601.Sort%2A> Überladungen der Methode für ein einfaches Geschäftsobjekt. Aufrufen der <xref:System.Collections.Generic.List%601.Sort%2A> Methode führt die Verwendung der Standardvergleich für den Typ Teil, und die <xref:System.Collections.Generic.List%601.Sort%2A> Methode ist mit einer anonymen Methode implementiert.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> -methodenüberladung.  
  
 Das Beispiel definiert eine alternative Vergleichsmethode für Zeichenfolgen wird mit dem Namen `CompareDinosByLength`. Diese Methode funktioniert wie folgt aus: Zunächst werden die zu vergleichenden Objekte für getestet `null`, und als kleiner als ein Wert ungleich Null ein null-Verweis behandelt wird. Zweitens: die Länge der Zeichenfolge verglichen werden und größer sein als die längere Zeichenfolge angesehen wird. Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit vier Zeichenfolgen, in keiner bestimmten Reihenfolge aufgefüllt. Die Liste enthält auch eine leere Zeichenfolge und ein null-Verweis. Die Liste wird angezeigt, sortiert, mit einem <xref:System.Comparison%601> generischen Delegaten darstellt der `CompareDinosByLength` -Methode, und erneut angezeigt.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparison" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparison" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparison" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des zu sortierenden Bereichs.</param>
        <param name="count">Die Länge des zu sortierenden Bereichs.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, wenn der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> mithilfe des angegebenen Vergleichs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` angegeben ist, wird die Elemente der <xref:System.Collections.Generic.List%601> sortiert sind, mit dem angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung.  
  
 Wenn `comparer` ist `null`, die standardmäßige Vergleichsfunktion <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable%601> generische Schnittstelle und verwendet Sie, dass diese Implementierung, sofern verfügbar.  Wenn dies nicht der Fall ist, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` implementiert die <xref:System.IComparable> Schnittstelle.  Wenn Typ `T` implementiert nicht die beiden Schnittstellen, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> löst eine <xref:System.InvalidOperationException>.  
  
 Diese Methode verwendet <xref:System.Array.Sort%2A?displayProperty=nameWithType>, die die Beobachtung der inneren Abläufe Sortierreihenfolge wie folgt angewendet:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, verwendet einen Sortieralgorithmus einfügen  
  
-   Überschreitet die Anzahl der Partitionen 2 Protokolle *n*, wobei *n* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird einen Quicksort-Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Diese Methode ist im Durchschnitt eine O (*n* Log *n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>; im schlimmsten Fall ist es eine O (*n* <sup>2</sup>) Vorgang.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> -methodenüberladung, und die <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> -methodenüberladung.  
  
 Im Beispiel wird einen alternativen Vergleich für DinoCompare implementiert-Zeichenfolgen definiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich funktioniert wie folgt aus: Zunächst werden die zu vergleichenden Objekte für getestet `null`, und als kleiner als ein Wert ungleich Null ein null-Verweis behandelt wird. Zweitens: die Länge der Zeichenfolge verglichen werden und größer sein als die längere Zeichenfolge angesehen wird. Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt und mit den Namen der fünf pflanzenfressenden Dinosaurier und drei zur Dinosaurier aufgefüllt. In jedem der beiden Gruppen sind die Namen nicht in der Sortierreihenfolge vor. Die Liste wird angezeigt, die Gruppe der Pflanzenfresser wird mit dem alternativen Vergleich sortiert und die Liste wird erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> methodenüberladung wird dann verwendet, um die "Brachiosaurus" nur die Gruppe der Pflanzenfresser gesucht. Die Zeichenfolge nicht gefunden wird, und das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) der die negative Zahl zurückgegeben, die von der <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Methode dient als Index für das Einfügen der neuen Zeichenfolge.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in der <see cref="T:System.Collections.Generic.List`1" /> an.  
  
- oder -  
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> nicht finden.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der verhindert, dass die Auflistung zu ändern; Wenn die zugrunde liegende Auflistung Änderungen vorgenommen werden, spiegelt die schreibgeschützte Auflistung aus diesem Grund diese Änderungen wider.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerator`1" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der c#-Sprache (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist die <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Eigenschaft ist nicht definiert. Aus diesem Grund müssen Sie Aufrufen der <xref:System.Collections.IEnumerator.MoveNext%2A> Methode, um den Enumerator auf das erste Element der Auflistung vor dem Lesen des Werts von <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 Die <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Eigenschaft gibt das gleiche Objekt bis <xref:System.Collections.IEnumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.Generic.IEnumerator%601.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn der Auflistung, z. B. das Hinzufügen Änderungen, ändern oder Löschen von Elementen, wenn der Enumerator unwiederbringlich ist ungültig, und der nächste Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> löst eine <xref:System.InvalidOperationException>.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.ICollection" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.ICollection" /> in ein <see cref="T:System.Array" />, beginnend bei einem bestimmten <see cref="T:System.Array" />-Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ der Quelle <xref:System.Collections.ICollection> kann nicht automatisch in den Typ des Ziels umgewandelt werden `array`, die nicht generischen Implementierungen der <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> auslösen <xref:System.InvalidCastException>, während die Implementierungen die generischen auslösen <xref:System.ArgumentException>.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="array" /> verwendet keine nullbasierte Indizierung.  
  
- oder -  
Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.ICollection" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />s.  
  
- oder -  
Der Typ der Quell-<see cref="T:System.Collections.ICollection" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist.</summary>
        <value><see langword="true" />, wenn der Zugriff auf das <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  In dem seltenen Fall, in dem Enumeration mit Schreibzugriffe konkurriert, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt zu sperren, bevor Sie den Zugriff auf die Auflistung.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.  In der Standardimplementierung der <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer die aktuelle Instanz zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt zu sperren, bevor Sie den Zugriff auf die Auflistung. Der folgende Code zeigt die Verwendung der <xref:System.Collections.ICollection.SyncRoot%2A> -Eigenschaft für c#, C++ und Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der c#-Sprache (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist die <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft ist nicht definiert. Aus diesem Grund müssen Sie Aufrufen der <xref:System.Collections.IEnumerator.MoveNext%2A> Methode, um den Enumerator auf das erste Element der Auflistung vor dem Lesen des Werts von <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Die <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft dasselbe Objekt zurück, bis entweder <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn der Auflistung, z. B. das Hinzufügen Änderungen, ändern oder Löschen von Elementen, wenn der Enumerator unwiederbringlich ist ungültig, und der nächste Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> löst eine <xref:System.InvalidOperationException>.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das <see cref="T:System.Object" />, das in <see cref="T:System.Collections.IList" /> eingefügt werden soll.</param>
        <summary>Fügt der <see cref="T:System.Collections.IList" /> ein Element hinzu.</summary>
        <returns>Die Position, an der das neue Element eingefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> ist kleiner als <xref:System.Collections.Generic.List%601.Capacity%2A>, diese Methode ist ein o(1)-Vorgang. Wenn die Kapazität für das neue Element erhöht werden muss, wird diese Methode eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das <see cref="T:System.Object" />, das in der <see cref="T:System.Collections.IList" /> gesucht werden soll.</param>
        <summary>Ermittelt, ob die <see cref="T:System.Collections.IList" /> einen bestimmten Wert enthält.</summary>
        <returns><see langword="true" />, wenn das <paramref name="item" /> in der <see cref="T:System.Collections.IList" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt mithilfe des Standardgleichheitsvergleichs Gleichheit <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.IList" /> zu suchende Objekt.</param>
        <summary>Bestimmt den Index eines bestimmten Elements in der <see cref="T:System.Collections.IList" />.</summary>
        <returns>Der Index von <paramref name="item" />, wenn das Element in der Liste gefunden wird, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt mithilfe des Standardgleichheitsvergleichs Gleichheit <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <paramref name="item" /> eingefügt werden soll.</param>
        <param name="item">Das in die <see cref="T:System.Collections.IList" /> einzufügende Objekt.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.IList" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `index` gleich der Anzahl der Elemente in <xref:System.Collections.IList> ist, wird `item` am Ende angefügt.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.IList" /> eine feste Größe aufweist.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Collections.IList" /> eine feste Größe aufweist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Auflistung mit fester Größe lässt das Hinzufügen oder Entfernen von Elementen nach dem Erstellen der Auflistung nicht zu. Vorhandene Elemente können jedoch geändert werden.  
  
 Eine Auflistung mit fester Größe ist einfach eine Sammlung mit einem Wrapper, der verhindert wird, hinzufügen und Entfernen von Elementen. Wenn Änderungen, um die zugrunde liegende Auflistung vorgenommen werden, z. B. zum Hinzufügen oder Entfernen von Elementen, gibt die Auflistung mit fester Größe aus diesem Grund, diese Änderungen wieder.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.IList" /> schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Collections.IList" /> schreibgeschützt ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der verhindert, dass die Auflistung zu ändern; Wenn die zugrunde liegende Auflistung Änderungen vorgenommen werden, spiegelt die schreibgeschützte Auflistung aus diesem Grund diese Änderungen wider.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des Elements, das abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft das Element am angegebenen Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die C#-Sprache verwendet die [dies](~/docs/csharp/language-reference/keywords/this.md) -Schlüsselwort zum Definieren der Indexer der <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> Eigenschaft. Visual Basic implementiert <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang. Festlegen der Eigenschaft ist auch ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">Die Eigenschaft wird festgelegt, und der <paramref name="value" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das aus der <see cref="T:System.Collections.IList" /> zu entfernende Objekt.</param>
        <summary>Entfernt das erste Vorkommen eines angegebenen Objekts aus der <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt mithilfe des Standardgleichheitsvergleichs Gleichheit <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.Generic.List`1" /> in ein neues Array.</summary>
        <returns>Ein Array, das Kopien der Elemente aus <see cref="T:System.Collections.Generic.List`1" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente kopiert werden, mithilfe von <xref:System.Array.Copy%2A?displayProperty=nameWithType>, d.h. ein O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.ToArray%2A> -Methode und andere Methoden der <xref:System.Collections.Generic.List%601> -Klasse, die für Bereiche verwendet. Am Ende des Beispiels die <xref:System.Collections.Generic.List%601.GetRange%2A> Methode wird verwendet, um die drei Elemente aus der Liste aus, ab Position 2 des Index abzurufen. Die <xref:System.Collections.Generic.List%601.ToArray%2A> Methode wird aufgerufen, für das resultierende <xref:System.Collections.Generic.List%601>, erstellen ein Array von drei Elementen. Die Elemente des Arrays werden angezeigt.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die Kapazität auf die Anzahl der tatsächlich in der <see cref="T:System.Collections.Generic.List`1" /> befindlichen Elemente fest, sofern diese Anzahl unter dem Schwellenwert liegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um eine Auflistung der Aufwand minimiert werden, wenn keine neuen Elemente der Auflistung hinzugefügt werden. Die Kosten erneut zugewiesen werden, und das Kopieren einer großen <xref:System.Collections.Generic.List%601> jedoch sehr aufwändig sein kann also die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode führt keine Aktion, wenn die Liste mit mehr als 90 Prozent der Kapazität ist. Dadurch wird vermieden, er für einen relativ kleinen zu großen neuzuordnung Kosten verursacht.  
  
> [!NOTE]
>  Der aktuelle Schwellenwert von 90 Prozent, möglicherweise in zukünftigen Versionen ändern.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Zurücksetzen einer <xref:System.Collections.Generic.List%601> aufrufen, um den Anfangszustand, die <xref:System.Collections.Generic.List%601.Clear%2A> Methode vor dem Aufruf der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode. Beim Verkürzen einer leeren <xref:System.Collections.Generic.List%601> definiert die Kapazität der <xref:System.Collections.Generic.List%601> auf die Standardkapazität.  
  
 Die Kapazität kann auch festgelegt werden mithilfe der <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Überprüfen der Kapazität und die Anzahl der einem <xref:System.Collections.Generic.List%601> enthält ein einfaches Geschäftsobjekt und veranschaulicht die Verwendung der <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode, um zusätzliche Kapazität zu entfernen.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode. Verschiedene Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> Klasse hinzufügen, einfügen und Entfernen von Elementen aus einer Liste von Zeichenfolgen verwendet werden. Die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode wird verwendet, um die Kapazität entsprechend der Anzahl die zu reduzieren und die <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften werden angezeigt. Wenn der freie Kapazität kleiner als 10 Prozent der Gesamtkapazität hätte, würde die Größe die Liste nicht geändert wurde. Abschließend werden der Inhalt der Liste gelöscht.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen definiert, auf die die Elemente geprüft werden sollen.</param>
        <summary>Bestimmt, ob jedes Element in der <see cref="T:System.Collections.Generic.List`1" /> die vom angegebenen Prädikat definierten Bedingungen erfüllt.</summary>
        <returns><see langword="true" />, wenn jedes Element in der <see cref="T:System.Collections.Generic.List`1" /> die vom angegebenen Prädikat definierten Bedingungen erfüllt; andernfalls <see langword="false" />. Wenn die Liste über keine Elemente verfügt, ist der Rückgabewert <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente des aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an übergeben die <xref:System.Predicate%601> Delegaten und Verarbeitung wird beendet, wenn der Delegat zurückgegeben `false` für jedes Element. Die Elemente werden nacheinander verarbeitet, und alle Aufrufe werden in einem einzelnen Thread ausgeführt.  
  
 Diese Methode ist eine O (*n*)-Vorgang, in denen *n* ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Collections.Generic.List%601.TrueForAll%2A> -Methode und mehrere andere Methoden, mit denen <xref:System.Predicate%601> generischen Delegaten.  
  
 Ein <xref:System.Collections.Generic.List%601> von Zeichenfolgen erstellt, mit 8 Godzilla-Namen, von denen zwei (an Position 1 und 5) "Saurus" enden. Das Beispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, die einen Zeichenfolgenparameter akzeptiert und gibt einen booleschen Wert, der angibt, ob die Eingabezeichenfolge in "Saurus" endet.  
  
 Die <xref:System.Collections.Generic.List%601.TrueForAll%2A> Methode durchläuft die Liste von Anfang an und übergibt an jedes Element der `EndsWithSaurus` Methode. Die Suche beendet, wenn die `EndsWithSaurus` Methodenrückgabe `false`.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen den richtigen Delegaten aus dem Kontext ableiten und erstellen ihn automatisch.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>