<Type Name="SortedSet&lt;T&gt;" FullName="System.Collections.Generic.SortedSet&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3cdb462bde471b5c5b569b7db945c5d52cfd608a" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51323884" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SortedSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Collections.ICollection, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.SortedSet`1" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedSet(Of T)&#xA;Implements ICollection, ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable, ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class SortedSet : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Collections::ICollection, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type SortedSet&lt;'T&gt; = class&#xA;    interface ISet&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.SortedSetDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Der Typ der Elemente in der Gruppe.</typeparam>
    <summary>Stellt eine Auflistung von Objekten dar, deren Sortierreihenfolge beibehalten wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Collections.Generic.SortedSet%601> Objekt sortierten Reihenfolge verwaltet, ohne die Leistung beeinträchtigen, wie Elemente eingefügt und gelöscht werden. Doppelte Elemente sind nicht zulässig. Ändern der Sortierung-Werte von vorhandenen Elementen wird nicht unterstützt und kann zu unerwartetem Verhalten führen.  
  
 Für eine Thread-sichere Alternative zur <xref:System.Collections.Generic.SortedSet%601>, finden Sie unter <xref:System.Collections.Immutable.ImmutableSortedSet%601>  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Collections.Generic.SortedSet%601> -Klasse, die mit dem Konstruktor erstellt wird, erwartet eine <xref:System.Collections.Generic.IComparer%601> als Parameter. Dieses Vergleichs (`ByFileExtension`) wird verwendet, um das Sortieren einer Liste von Dateinamen durch ihre Erweiterungen.  
  
 Dieses Beispiel zeigt, wie Sie erstellen eine sortierte Sammlung von Dateinamen, unerwünschte Elemente entfernen, einen Bereich von Elementen anzeigen und vergleichen den Satz mit einem anderen sortierten Satz.  
  
 [!code-csharp[System.Collections.Generic.SortedSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.sortedset/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.SortedSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.sortedset/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Immutable.ImmutableSortedSet`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.SortedSet`1" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist ein `O(1)` Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.SortedSet`1" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedSet (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedSet(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedSet&lt;'T&gt; : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; System.Collections.Generic.SortedSet&lt;'T&gt;" Usage="new System.Collections.Generic.SortedSet&lt;'T&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Der zum Vergleichen von Objekten zu verwendende Standardvergleich.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.SortedSet`1" />-Klasse, die den angegebenen Vergleich verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` implementiert nicht <xref:System.IComparable%601>, Sie müssen angeben, ein <xref:System.Collections.Generic.IComparer%601> zu verwendende Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen Vergleich (`ByFileExtension`), wird verwendet, um eine sortierte Gruppe zu erstellen, mit dem Namen sortiert vom zugehörigen Erweiterungen. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedSet%601> Klasse.  
  
 [!code-csharp[System.Collections.Generic.SortedSet#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.sortedset/cs/program.cs#2)]
 [!code-vb[System.Collections.Generic.SortedSet#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.sortedset/vb/program.vb#2)]  
[!code-csharp[System.Collections.Generic.SortedSet#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.sortedset/cs/program.cs#9)]
[!code-vb[System.Collections.Generic.SortedSet#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.sortedset/vb/program.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedSet&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.SortedSet&lt;'T&gt;" Usage="new System.Collections.Generic.SortedSet&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die zu kopierende zählbare Auflistung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.SortedSet`1" />-Klasse, die Elemente enthält, die aus einer angegebenen zählbaren Auflistung kopiert wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Doppelte Elemente in der zählbaren Auflistung werden nicht kopiert, in der neuen Instanz von der <xref:System.Collections.Generic.SortedSet%601> -Klasse, und keine Ausnahmen ausgelöst werden.  
  
 Dieser Konstruktor ist ein `O(n log n)` -Vorgang, in denen `n` ist die Anzahl der Elemente in der `collection` Parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedSet&lt;'T&gt; : seq&lt;'T&gt; * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; System.Collections.Generic.SortedSet&lt;'T&gt;" Usage="new System.Collections.Generic.SortedSet&lt;'T&gt; (collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die zu kopierende zählbare Auflistung.</param>
        <param name="comparer">Der zum Vergleichen von Objekten zu verwendende Standardvergleich.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.SortedSet`1" />-Klasse, die aus einer angegebenen zählbaren Auflistung kopierte Elemente enthält und einen angegebenen Vergleich verwendet.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SortedSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SortedSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedSet&lt;'T&gt; : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Generic.SortedSet&lt;'T&gt;" Usage="new System.Collections.Generic.SortedSet&lt;'T&gt; (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Das Objekt, das die zum Serialisieren des <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekts erforderlichen Informationen enthält.</param>
        <param name="context">Die Struktur, die die Quelle und das Ziel des serialisierten Streams enthält, der dem <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt zugeordnet ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.SortedSet`1" />-Klasse, die serialisierte Daten enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird aufgerufen, während der Deserialisierung ein Objekts wiederherstellen kann, das über einen Stream übertragen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; bool&#xA;override this.Add : 'T -&gt; bool" Usage="sortedSet.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Der Element, das zur Menge hinzugefügt wird.</param>
        <summary>Fügt der Gruppe ein Element hinzu und gibt einen Wert zurück, der angibt, ob es erfolgreich hinzugefügt wurde.</summary>
        <returns>
          <see langword="true" />, wenn der Gruppe <paramref name="item" /> hinzugefügt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.SortedSet%601> Klasse akzeptiert keine doppelte Elemente. Wenn `item` befindet sich bereits in der Menge und gibt diese Methode `false` und löst keine Ausnahme.  
  
 Wenn <xref:System.Collections.Generic.SortedSet%601.Count%2A> bereits die Kapazität entspricht der <xref:System.Collections.Generic.SortedSet%601> Objekt ist, wird die Kapazität wird automatisch angepasst, um das neue Element aufzunehmen.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine sortierte Gruppe Elemente hinzugefügt. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedSet%601> Klasse.  
  
 [!code-csharp[System.Collections.Generic.SortedSet#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.sortedset/cs/program.cs#3)]
 [!code-vb[System.Collections.Generic.SortedSet#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.sortedset/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedSet.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus dem Satz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein `O(n)` -Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IComparer&lt;T&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IComparer`1&lt;!T&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedSet`1.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IComparer&lt;T&gt; ^ Comparer { System::Collections::Generic::IComparer&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IComparer&lt;'T&gt;" Usage="System.Collections.Generic.SortedSet&lt;'T&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Collections.Generic.IComparer`1" />-Objekt ab, das zum Sortieren der Werte in <see cref="T:System.Collections.Generic.SortedSet`1" /> dient.</summary>
        <value>Der Vergleich, der zum Sortieren der Werte in <see cref="T:System.Collections.Generic.SortedSet`1" /> dient.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgegebenen Vergleichs möglich die standardmäßige Vergleichsfunktion des Typs für eine <xref:System.Collections.Generic.SortedSet%601>, oder der Vergleich für ihren Konstruktor verwendet.  
  
 Abrufen des Werts dieser Eigenschaft ist ein `O(1)` Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="sortedSet.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das in der Gruppe gesucht werden soll.</param>
        <summary>Ermittelt, ob die Gruppe ein bestimmtes Element enthält.</summary>
        <returns>
          <see langword="true" />, wenn die Gruppe <paramref name="item" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein `O(log n)` Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert ein <see cref="T:System.Collections.Generic.SortedSet`1" /> teilweise oder vollständig in ein kompatibles eindimensionales Array, wobei am Anfang des Zielarrays oder an einem angegebenen Index begonnen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein `O(n)` -Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="sortedSet.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, in das die Elemente aus <see cref="T:System.Collections.Generic.SortedSet`1" /> kopiert werden.</param>
        <summary>Kopiert das gesamte <see cref="T:System.Collections.Generic.SortedSet`1" /> in ein kompatibles eindimensionales Array, wobei am Anfang des Zielarrays begonnen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Indizierung von `array` nullbasiert sein muss.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente im Quell-<see cref="T:System.Collections.Generic.SortedSet`1" /> ist größer als die Anzahl der Elemente, die das Zielarray enthalten kann.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="sortedSet.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, in das die Elemente aus <see cref="T:System.Collections.Generic.SortedSet`1" /> kopiert werden. Für das Array muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <c>array</c>, ab dem kopiert wird.</param>
        <summary>Kopiert das vollständige <see cref="T:System.Collections.Generic.SortedSet`1" /> in ein kompatibles eindimensionales Array, beginnend am angegebenen Index des Arrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein `O(n)` -Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente im Quellarray ist größer als der verfügbare Platz vom <paramref name="index" /> bis zum Ende des Zielarrays.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.CopyTo(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int * int -&gt; unit" Usage="sortedSet.CopyTo (array, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, in das die Elemente aus <see cref="T:System.Collections.Generic.SortedSet`1" /> kopiert werden. Für das Array muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <c>array</c>, ab dem kopiert wird.</param>
        <param name="count">Die Anzahl der zu kopierenden Elemente.</param>
        <summary>Kopiert eine angegebene Anzahl von Elementen aus <see cref="T:System.Collections.Generic.SortedSet`1" /> in ein kompatibles eindimensionales Array, beginnend ab dem angegebenen Arrayindex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein `O(n)` -Vorgang, in denen `n` ist `count`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente im Quellarray ist größer als der verfügbare Platz vom <paramref name="index" /> bis zum Ende des Zielarrays.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.  
  
- oder -  
 <paramref name="count" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.SortedSet&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente im <see cref="T:System.Collections.Generic.SortedSet`1" /> ab.</summary>
        <value>Die Anzahl der Elemente im <see cref="T:System.Collections.Generic.SortedSet`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abrufen des Werts dieser Eigenschaft ist ein `O(1)` Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSetComparer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein <see cref="T:System.Collections.IEqualityComparer" />-Objekt zurück, mit dem eine Auflistung erstellt werden kann, die einzelne Gruppen enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.SortedSet&lt;T&gt;&gt; CreateSetComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.SortedSet`1&lt;!T&gt;&gt; CreateSetComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.CreateSetComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSetComparer () As IEqualityComparer(Of SortedSet(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEqualityComparer&lt;System::Collections::Generic::SortedSet&lt;T&gt; ^&gt; ^ CreateSetComparer();" />
      <MemberSignature Language="F#" Value="static member CreateSetComparer : unit -&gt; System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.SortedSet&lt;'T&gt;&gt;" Usage="System.Collections.Generic.SortedSet&lt;'T&gt;.CreateSetComparer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.SortedSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Collections.IEqualityComparer" />-Objekt zurück, mit dem eine Auflistung erstellt werden kann, die einzelne Gruppen enthält.</summary>
        <returns>Ein Vergleich zum Erstellen einer Auflistung von Gruppen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.IEqualityComparer> Objekt auf Gleichheit nur auf einer Ebene überprüft, aber Sie können miteinander verketten Vergleiche auf zusätzlichen Ebenen, um tiefere Gleichheitstests auszuführen.  
  
 Das Aufrufen dieser Methode wird ein `O(1)` Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.SortedSet&lt;T&gt;&gt; CreateSetComparer (System.Collections.Generic.IEqualityComparer&lt;T&gt; memberEqualityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.SortedSet`1&lt;!T&gt;&gt; CreateSetComparer(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; memberEqualityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.CreateSetComparer(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSetComparer (memberEqualityComparer As IEqualityComparer(Of T)) As IEqualityComparer(Of SortedSet(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEqualityComparer&lt;System::Collections::Generic::SortedSet&lt;T&gt; ^&gt; ^ CreateSetComparer(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ memberEqualityComparer);" />
      <MemberSignature Language="F#" Value="static member CreateSetComparer : System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.SortedSet&lt;'T&gt;&gt;" Usage="System.Collections.Generic.SortedSet&lt;'T&gt;.CreateSetComparer memberEqualityComparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.SortedSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberEqualityComparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="memberEqualityComparer">Der Vergleich, der zum Erstellen des zurückgegebenen Vergleichs verwendet werden soll.</param>
        <summary>Gibt entsprechend einem angegebenen Vergleich ein <see cref="T:System.Collections.IEqualityComparer" />-Objekt zurück, mit dem eine Auflistung erstellt werden kann, die einzelne Gruppen enthält.</summary>
        <returns>Ein Vergleich zum Erstellen einer Auflistung von Gruppen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `memberEqualityComparer` und der aktuelle <xref:System.Collections.Generic.SortedSet%601> müssen dieselbe Definition für Gleichheit.  
  
 Können Sie den Vergleich von dieser Methode zurückgegebenen in die <xref:System.Collections.Generic.SortedSet%601.%23ctor%28System.Collections.Generic.IEnumerable%7B%600%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType> Konstruktor, um eine Hashtabelle mit den einzelnen Gruppen zu erstellen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Collections.Generic.SortedSet%601.CreateSetComparer%2A> Methode, um eine Gruppe von Gruppen zu erstellen. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedSet%601> Klasse.  
  
 [!code-csharp[System.Collections.Generic.SortedSet#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.sortedset/cs/program.cs#7)]
 [!code-vb[System.Collections.Generic.SortedSet#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.sortedset/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptWith">
      <MemberSignature Language="C#" Value="public void ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member ExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.ExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="sortedSet.ExceptWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Die Auflistung der Elemente, die aus dem <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt entfernt werden sollen.</param>
        <summary>Entfernt alle Elemente in einer angegebenen Auflistung aus dem aktuellen <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entfernt jedes Element in der aktuellen <xref:System.Collections.Generic.SortedSet%601> , das ist auch in `other`. Doppelte Werte in `other` werden ignoriert.  
  
 Diese Methode ist ein `O(n)` -Vorgang, in denen `n` ist die Anzahl der Elemente in der `other` Parameter.  
  
   
  
## Examples  
 Im folgende Beispiel entfernt Elemente aus einem sortierten Satz an, die in einem anderen sortierten Gruppe dupliziert werden. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedSet%601> Klasse.  
  
 [!code-csharp[System.Collections.Generic.SortedSet#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.sortedset/cs/program.cs#6)]
 [!code-vb[System.Collections.Generic.SortedSet#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.sortedset/vb/program.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SortedSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.SortedSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As SortedSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::SortedSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.SortedSet&lt;'T&gt;.Enumerator" Usage="sortedSet.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die <see cref="T:System.Collections.Generic.SortedSet`1" /> durchläuft.</summary>
        <returns>Ein Enumerator, der <see cref="T:System.Collections.Generic.SortedSet`1" /> in sortierter Reihenfolge durchläuft.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn der Auflistung, z. B. das Hinzufügen Änderungen, ändern oder Löschen von Elementen, wenn der Enumerator unwiederbringlich ist ungültig, und der nächste Aufruf von <xref:System.Collections.Generic.SortedSet%601.Enumerator.MoveNext%2A> oder <xref:System.Collections.Generic.SortedSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> löst eine <xref:System.InvalidOperationException>.  
  
 Diese Methode ist ein `O(log n)` Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="sortedSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren des neuen <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekts erforderlichen Informationen.</param>
        <param name="context">Eine <see cref="T:System.Runtime.Serialization.StreamingContext" />-Struktur, die die Quelle und das Ziel des serialisierten Streams enthält, der dem <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt zugeordnet ist.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und gibt die zum Serialisieren eines <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekts erforderlichen Daten zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode wird ein `O(n)` -Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Serialisierungsdiensten. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetViewBetween">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.SortedSet&lt;T&gt; GetViewBetween (T lowerValue, T upperValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.SortedSet`1&lt;!T&gt; GetViewBetween(!T lowerValue, !T upperValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.GetViewBetween(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetViewBetween (lowerValue As T, upperValue As T) As SortedSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::SortedSet&lt;T&gt; ^ GetViewBetween(T lowerValue, T upperValue);" />
      <MemberSignature Language="F#" Value="abstract member GetViewBetween : 'T * 'T -&gt; System.Collections.Generic.SortedSet&lt;'T&gt;&#xA;override this.GetViewBetween : 'T * 'T -&gt; System.Collections.Generic.SortedSet&lt;'T&gt;" Usage="sortedSet.GetViewBetween (lowerValue, upperValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lowerValue" Type="T" />
        <Parameter Name="upperValue" Type="T" />
      </Parameters>
      <Docs>
        <param name="lowerValue">Der niedrigste gewünschte Wert in der Ansicht.</param>
        <param name="upperValue">Der höchste gewünschte Wert in der Ansicht.</param>
        <summary>Gibt eine Ansicht einer Teilmenge in einem <see cref="T:System.Collections.Generic.SortedSet`1" /> zurück.</summary>
        <returns>Eine Teilmengenansicht, die nur die Werte im angegebenen Bereich enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt eine Ansicht des Bereichs von Elementen, die zwischen liegen `lowerValue` und `upperValue`, wie durch den Vergleich definierten. Diese Methode kopiert keine Elemente aus der <xref:System.Collections.Generic.SortedSet%601>, sondern stellt ein Fenster in den zugrunde liegenden <xref:System.Collections.Generic.SortedSet%601> selbst. Sie können Änderungen vornehmen, in der sowohl von der Ansicht und in der zugrunde liegenden <xref:System.Collections.Generic.SortedSet%601>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Collections.Generic.SortedSet%601.GetViewBetween%2A> Methode, um nur die AVI-Dateien aus einem sortierten Satz von Medien-Dateinamen. Der Vergleich wertet Dateinamen entsprechend den zugehörigen Erweiterungen. Die `lowerValue` ist "AVI" und die `upperValue` ist nur ein Wert höher, "AVJ", um die Ansicht aller AVI-Dateien zu erhalten. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedSet%601> Klasse.  
  
 [!code-csharp[System.Collections.Generic.SortedSet#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.sortedset/cs/program.cs#5)]
 [!code-vb[System.Collections.Generic.SortedSet#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.sortedset/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lowerValue" /> ist laut Vergleich größer als <paramref name="upperValue" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein Vorgang, der ausgeführt werden sollte, befand sich außerhalb des von <paramref name="lowerValue" /> und <paramref name="upperValue" /> angegebenen Bereichs.</exception>
      </Docs>
    </Member>
    <Member MemberName="IntersectWith">
      <MemberSignature Language="C#" Value="public virtual void IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub IntersectWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IntersectWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.IntersectWith : seq&lt;'T&gt; -&gt; unit" Usage="sortedSet.IntersectWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt verglichen werden soll.</param>
        <summary>Ändert das aktuelle <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt, sodass es nur Elemente enthält, die in einer angegebenen Auflistung ebenfalls enthalten sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ignoriert alle doppelten Elemente in `other`.  
  
 Wenn die Auflistung von dargestellt die `other` -Parameter ist ein <xref:System.Collections.Generic.SortedSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.SortedSet%601> Objekt ist, wird diese Methode ist ein `O(n)` Vorgang. Hingegen diese Methode ist ein `O(n + m)` -Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A> und `m` ist die Anzahl der Elemente im `other`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="sortedSet.IsProperSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt verglichen werden soll.</param>
        <summary>Bestimmt, ob ein <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt eine echte Teilmenge der angegebenen Auflistung ist.</summary>
        <returns>
          <see langword="true" />, wenn das aktuelle <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt eine echte Teilmenge von <paramref name="other" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine leere Menge ist eine echte Teilmenge von keiner anderen Sammlung. Aus diesem Grund, diese Methode gibt `true` , wenn die Auflistung von der aktuellen dargestellt <xref:System.Collections.Generic.SortedSet%601> ist leer, es sei denn, die `other` Parameter ist auch ein leeres Resultset.  
  
 Diese Methode gibt immer `false` Wenn <xref:System.Collections.Generic.SortedSet%601.Count%2A> ist größer als oder gleich der Anzahl der Elemente im `other`.  
  
 Wenn die Auflistung von dargestellte `other` ist eine <xref:System.Collections.Generic.SortedSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.SortedSet%601> Objekt, und klicken Sie dann diese Methode ist ein `O(n)` Vorgang. Hingegen diese Methode ist ein `O(n + m)` -Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A> und `m` ist die Anzahl der Elemente im `other`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="sortedSet.IsProperSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt verglichen werden soll.</param>
        <summary>Bestimmt, ob ein <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt eine echte Obermenge der angegebenen Auflistung ist.</summary>
        <returns>
          <see langword="true" />, wenn das <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt eine echte Obermenge von <paramref name="other" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine leere Menge ist eine echte Obermenge von keiner anderen Sammlung. Daher diese Methode gibt `true` , wenn die Auflistung von dargestellt die `other` Parameter ist leer. es sei denn, der aktuellen <xref:System.Collections.Generic.SortedSet%601> auch Auflistung leer ist.  
  
 Diese Methode gibt immer `false` Wenn <xref:System.Collections.Generic.SortedSet%601.Count%2A> ist kleiner oder gleich der Anzahl der Elemente im `other`.  
  
 Wenn die Auflistung von dargestellte `other` ist eine <xref:System.Collections.Generic.SortedSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.SortedSet%601> Objekt ist, wird diese Methode ist ein `O(n)` Vorgang. Hingegen diese Methode ist ein `O(n + m)` -Vorgang, in denen `n` ist die Anzahl der Elemente im `other` und `m` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="sortedSet.IsSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt verglichen werden soll.</param>
        <summary>Bestimmt, ob ein <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt eine Teilmenge der angegebenen Auflistung ist.</summary>
        <returns>
          <see langword="true" />, wenn das aktuelle <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt eine Teilmenge von <paramref name="other" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine leere Menge ist eine Teilmenge einer anderen Sammlung, einschließlich einer leeren Menge. aus diesem Grund, diese Methode gibt `true` , wenn die Auflistung von der aktuellen dargestellt <xref:System.Collections.Generic.SortedSet%601> Objekt leer ist, auch wenn die `other` -Parameter ist eine leere Menge.  
  
 Diese Methode gibt immer `false` Wenn <xref:System.Collections.Generic.SortedSet%601.Count%2A> ist größer als die Anzahl der Elemente in `other`.  
  
 Wenn die Auflistung von dargestellte `other` ist eine <xref:System.Collections.Generic.SortedSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.SortedSet%601> Objekt ist, wird diese Methode ist ein `O(n)` Vorgang. Hingegen diese Methode ist ein `O(n + m)` -Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A> und `m` ist die Anzahl der Elemente im `other`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="sortedSet.IsSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt verglichen werden soll.</param>
        <summary>Bestimmt, ob ein <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt eine Obermenge der angegebenen Auflistung ist.</summary>
        <returns>
          <see langword="true" />, wenn das aktuelle <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt eine Obermenge von <paramref name="other" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Auflistungen, einschließlich leerer Mengen, sind eine Obermenge der leeren Zeichensatz. Daher, diese Methode gibt `true` , wenn die Auflistung von dargestellt die `other` Parameter leer ist, selbst wenn die aktuelle <xref:System.Collections.Generic.SortedSet%601> Objekt leer ist.  
  
 Diese Methode gibt immer `false` Wenn <xref:System.Collections.Generic.SortedSet%601.Count%2A> ist kleiner als die Anzahl der Elemente in `other`.  
  
 Wenn die Auflistung von dargestellte `other` ist eine <xref:System.Collections.Generic.SortedSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.SortedSet%601> Objekt ist, wird diese Methode ist ein `O(n)` Vorgang. Hingegen diese Methode ist ein `O(n + m)` -Vorgang, in denen `n` ist die Anzahl der Elemente im `other` und `m` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public T Max { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Max" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedSet`1.Max" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Max As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Max { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Max : 'T" Usage="System.Collections.Generic.SortedSet&lt;'T&gt;.Max" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den durch den Vergleich definierten Höchstwert im <see cref="T:System.Collections.Generic.SortedSet`1" /> ab.</summary>
        <value>Der Höchstwert in der Gruppe.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public T Min { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Min" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedSet`1.Min" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Min As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Min { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Min : 'T" Usage="System.Collections.Generic.SortedSet&lt;'T&gt;.Min" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den durch den Vergleich definierten Mindestwert im <see cref="T:System.Collections.Generic.SortedSet`1" /> ab.</summary>
        <value>Der Mindestwert in der Gruppe.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="protected virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="sortedSet.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Die Quelle des Deserialisierungsereignisses.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und löst das Deserialisierungsereignis aus, sobald die Deserialisierung abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode wird ein `O(n)` -Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Das dem aktuellen <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt zugeordnete <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Overlaps : seq&lt;'T&gt; -&gt; bool&#xA;override this.Overlaps : seq&lt;'T&gt; -&gt; bool" Usage="sortedSet.Overlaps other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt verglichen werden soll.</param>
        <summary>Bestimmt, ob das aktuelle <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt und eine angegebene Auflistung gemeinsame Elemente enthalten.</summary>
        <returns>
          <see langword="true" />, wenn das <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt und <paramref name="other" /> mindestens ein gemeinsames Element enthalten, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle doppelten Elemente in `other` werden ignoriert.  
  
 Diese Methode ist ein `O(n)` -Vorgang, in denen `n` ist die Anzahl der Elemente im `other`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="sortedSet.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das zu entfernende Element.</param>
        <summary>Entfernt ein angegebenes Element aus dem <see cref="T:System.Collections.Generic.SortedSet`1" />.</summary>
        <returns>
          <see langword="true" />, wenn das Element gefunden und erfolgreich entfernt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Collections.Generic.SortedSet%601> Objekt enthält keine das angegebene Element, das Objekt bleibt unverändert und wird keine Ausnahme ausgelöst.  
  
 `item` kann `null` für Verweistypen.  
  
 Diese Methode ist ein `O(log n)` Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveWhere">
      <MemberSignature Language="C#" Value="public int RemoveWhere (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveWhere(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.RemoveWhere(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveWhere (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveWhere(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveWhere : Predicate&lt;'T&gt; -&gt; int" Usage="sortedSet.RemoveWhere match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der Delegat, der die Bedingungen für die Elemente definiert, die entfernt werden sollen.</param>
        <summary>Entfernt alle Elemente aus einer <see cref="T:System.Collections.Generic.SortedSet`1" />-Auflistung, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</summary>
        <returns>Die Anzahl von Elementen, die aus der <see cref="T:System.Collections.Generic.SortedSet`1" />-Auflistung entfernt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `match` nicht ändern, müssen die <xref:System.Collections.Generic.SortedSet%601>. Auf diese Weise kann zu unerwarteten Ergebnissen führen.  
  
 Das Aufrufen dieser Methode wird ein `O(n)` -Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel entfernt unerwünschte Elemente aus einem sortierten Satz. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedSet%601> Klasse.  
  
 [!code-csharp[System.Collections.Generic.SortedSet#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.sortedset/cs/program.cs#4)]
 [!code-vb[System.Collections.Generic.SortedSet#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.sortedset/vb/program.vb#4)]  
[!code-csharp[System.Collections.Generic.SortedSet#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.sortedset/cs/program.cs#8)]
[!code-vb[System.Collections.Generic.SortedSet#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.sortedset/vb/program.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Function Reverse () As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; seq&lt;'T&gt;" Usage="sortedSet.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Generic.SortedSet`1/&lt;Reverse&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Generic.SortedSet`1/&lt;Reverse&gt;d__104))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> zurück, das das <see cref="T:System.Collections.Generic.SortedSet`1" /> in umgekehrter Reihenfolge durchläuft.</summary>
        <returns>Ein Enumerator, der das <see cref="T:System.Collections.Generic.SortedSet`1" /> in umgekehrter Reihenfolge durchläuft.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SetEquals : seq&lt;'T&gt; -&gt; bool&#xA;override this.SetEquals : seq&lt;'T&gt; -&gt; bool" Usage="sortedSet.SetEquals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt verglichen werden soll.</param>
        <summary>Bestimmt, ob das aktuelle <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt und die angegebene Auflistung dieselben Elemente enthalten.</summary>
        <returns>
          <see langword="true" />, wenn das aktuelle <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt und <paramref name="other" /> gleich sind, andernfalls false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ignoriert, die Reihenfolge der Elemente und alle doppelten Elemente in `other`.  
  
 Wenn die Auflistung von dargestellte `other` ist eine <xref:System.Collections.Generic.SortedSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.SortedSet%601> Objekt ist, wird diese Methode ist ein `O(log n)` Vorgang. Hingegen diese Methode ist ein `O(n + m)` -Vorgang, in denen `n` ist die Anzahl der Elemente im `other` und `m` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExceptWith">
      <MemberSignature Language="C#" Value="public void SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SymmetricExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="sortedSet.SymmetricExceptWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt verglichen werden soll.</param>
        <summary>Ändert das aktuelle <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt, sodass es nur Elemente enthält, die entweder im aktuellen Objekt oder in der angegebenen Auflistung, nicht jedoch in beiden vorhanden sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle doppelten Elemente in `other` werden ignoriert.  
  
 Wenn die `other` -Parameter ist ein <xref:System.Collections.Generic.SortedSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.SortedSet%601> Objekt ist, wird diese Methode ist ein `O(n log m)` Vorgang. Hingegen diese Methode ist ein `O(n log m) + O(n log n)` -Vorgang, in denen `n` ist die Anzahl der Elemente im `other` und `m` ist <xref:System.Collections.Generic.SortedSet%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das Objekt, das dem <see cref="T:System.Collections.Generic.ICollection`1" />-Objekt hinzugefügt werden soll.</param>
        <summary>Fügt einem <see cref="T:System.Collections.Generic.ICollection`1" />-Objekt ein Element hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Generic.SortedSet%601>-Instanz in eine <xref:System.Collections.Generic.ICollection%601>-Schnittstelle umgewandelt wird.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> ist kleiner als <xref:System.Collections.Generic.List%601.Capacity%2A>, diese Methode ist ein `O(1)` Vorgang. Wenn die Kapazität erhöht werden muss, um das neue Element aufzunehmen, die diese Methode wird ein `O(n)` -Vorgang, in denen `n` ist <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Generic.ICollection`1" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine <see cref="T:System.Collections.ICollection" /> schreibgeschützt ist.</summary>
        <value>
          <see langword="true" />, wenn die Auflistung schreibgeschützt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Generic.SortedSet%601>-Instanz in eine <xref:System.Collections.Generic.ICollection%601>-Schnittstelle umgewandelt wird.  
  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der verhindert, dass die Auflistung zu ändern; Wenn die zugrunde liegende Auflistung Änderungen vorgenommen werden, spiegelt die schreibgeschützte Auflistung aus diesem Grund diese Änderungen wider.  
  
 Abrufen des Werts dieser Eigenschaft ist ein `O(1)` Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Generic.SortedSet%601>-Instanz in eine <xref:System.Collections.Generic.IEnumerable%601>-Schnittstelle umgewandelt wird.  

 Diese Methode ist ein `O(log n)` Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, in das die Elemente aus <see cref="T:System.Collections.Generic.SortedSet`1" /> kopiert werden. Für das Array muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <c>array</c>, ab dem kopiert wird.</param>
        <summary>Kopiert das vollständige <see cref="T:System.Collections.Generic.SortedSet`1" /> in ein kompatibles eindimensionales Array, beginnend am angegebenen Index des Arrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Generic.SortedSet%601>-Instanz in eine <xref:System.Collections.ICollection>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente im Quellarray ist größer als der verfügbare Platz vom <paramref name="index" /> bis zum Ende des Zielarrays.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedSet`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist.</summary>
        <value>
          <see langword="true" />, wenn der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Generic.SortedSet%601>-Instanz in eine <xref:System.Collections.ICollection>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedSet`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann. In der Standardimplementierung der <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection" /> gibt diese Eigenschaft immer die aktuelle Instanz zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Generic.SortedSet%601>-Instanz in eine <xref:System.Collections.ICollection>-Schnittstelle umgewandelt wird.  
  
 Diese Methode ist ein `O(1)` Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Generic.SortedSet%601>-Instanz in eine <xref:System.Collections.IEnumerable>-Schnittstelle umgewandelt wird.  
  
 Diese Methode ist ein `O(log n)` Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDeserialization (sender As Object) Implements IDeserializationCallback.OnDeserialization" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System::Object ^ sender) = System::Runtime::Serialization::IDeserializationCallback::OnDeserialization;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Die Quelle des Deserialisierungsereignisses.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Serialization.IDeserializationCallback" />-Schnittstelle und löst das Deserialisierungsereignis aus, sobald die Deserialisierung abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Generic.SortedSet%601>-Instanz in eine <xref:System.Runtime.Serialization.IDeserializationCallback>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Das der aktuellen <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Instanz zugeordnete <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren der <see cref="T:System.Collections.Generic.SortedSet`1" />-Instanz erforderlichen Informationen.</param>
        <param name="context">Eine <see cref="T:System.Runtime.Serialization.StreamingContext" />-Struktur, die die Quelle und das Ziel des serialisierten Streams enthält, der der <see cref="T:System.Collections.Generic.SortedSet`1" />-Instanz zugeordnet ist.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und gibt die zum Serialisieren der <see cref="T:System.Collections.Generic.SortedSet`1" />-Instanz erforderlichen Daten zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Generic.SortedSet%601>-Instanz in eine <xref:System.Runtime.Serialization.ISerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Serialisierungsdiensten. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'T *  -&gt; bool" Usage="sortedSet.TryGetValue (equalValue, actualValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" />
        <Parameter Name="actualValue" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalValue">Der zu suchende Wert.</param>
        <param name="actualValue">Der bei der Suche in der Gruppe gefundene Wert, oder der Standardwert von T, wenn die Suche keine Übereinstimmung ergeben hat.</param>
        <summary>Durchsucht die Gruppe nach einem angegebenen Wert und gibt ggf. den identischen Wert zurück, sofern vorhanden.</summary>
        <returns>Ein Wert, der angibt, ob die Suche erfolgreich war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies kann nützlich sein, wenn Sie möchten, um einen zuvor gespeicherten Verweis anstatt einer neu erstellten (sodass erhöhte Freigabe der Verweise auftreten kann) oder wiederzuverwenden, um einen Wert zu suchen, die umfangreichere Daten als der Wert, der Sie derzeit verwenden, obwohl die Comparer-Funktionen Geben Sie, ob sie gleich sind.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionWith">
      <MemberSignature Language="C#" Value="public void UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnionWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member UnionWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.UnionWith : seq&lt;'T&gt; -&gt; unit" Usage="sortedSet.UnionWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt verglichen werden soll.</param>
        <summary>Ändert das aktuelle <see cref="T:System.Collections.Generic.SortedSet`1" />-Objekt, sodass es alle Elemente enthält, die sowohl im aktuellen Objekt als auch in der angegebenen Auflistung vorhanden sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle doppelten Elemente in `other` werden ignoriert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>